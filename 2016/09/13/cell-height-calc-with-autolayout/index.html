<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>项目中Cell自动计算行高的实践 | Ney的技术博客</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">项目中Cell自动计算行高的实践</h1><a id="logo" href="/.">Ney的技术博客</a><p class="description">Learning，sharing，improving</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">项目中Cell自动计算行高的实践</h1><div class="post-meta">Sep 13, 2016<span> | </span><span class="category"><a href="/categories/iOS开发/">iOS开发</a></span></div><div class="post-content"><h1 id="项目中Cell自动计算行高的实践"><a href="#项目中Cell自动计算行高的实践" class="headerlink" title="项目中Cell自动计算行高的实践"></a>项目中Cell自动计算行高的实践</h1><h3 id="在前面总该说些什么"><a href="#在前面总该说些什么" class="headerlink" title="在前面总该说些什么"></a>在前面总该说些什么</h3><p>这篇文章是对团队最近关于使用Autolayout对Cell进行高度计算的总结。</p>
<hr>
<p>接下来你将会看到以下内容：</p>
<blockquote>
<ul>
<li>数据和UI分离式的Cell高度计算的弊端</li>
<li>Self-Sizing Cell的解决方案</li>
<li>UITableView+FDTemplateLayoutCell简介</li>
<li>UITableView+FDTemplateLayoutCell代码分析</li>
<li>UITableView+FDTemplateLayoutCell集成</li>
</ul>
</blockquote>
<h3 id="数据和UI分离式的Cell高度计算的弊端"><a href="#数据和UI分离式的Cell高度计算的弊端" class="headerlink" title="数据和UI分离式的Cell高度计算的弊端"></a>数据和UI分离式的Cell高度计算的弊端</h3><p>通过数据模型的方式计算行高，这样的方式已经从ios4延伸到ios9了，这种方式的核心是在cell或者model里面提供一个方法，传入数据，然后根据内容+各种Margin计算出cell的高度。但是这种方法有个巨大的缺陷就是数据和界面是割裂的，你不得不在调完了UI后还要去计算高度的方法里再改一通。阅读和维护这部分逻辑时也会比较麻烦</p>
<p>或许已经有人想到了把计算高度的方法放到cel里面，然后把那些Margin做成常量，然后把数据传入cell来计算高度，这样当你修改内部的Margin时，高度计算的方法会不用做任何修改。不错，这个办法已经部分解决了上面的部分问题。不过当你调整UI以后对应的高度计算方法肯定会需要根据UI重写一遍，上述的问题还是存在。那有没有什么更简单的方法呢</p>
<p>答案是肯定的。苹果在iOS8提出了Self-Sizing Cell的概念。只要你用Autolayout对cell进行约束布局，当约束足够清晰时，Cell就能自动计算出自己的高度。如果后续UI有变化，也仅仅只需要调整控件以及相关的约束就行。</p>
<h3 id="Self-Sizing-Cell的解决方案"><a href="#Self-Sizing-Cell的解决方案" class="headerlink" title="Self-Sizing Cell的解决方案"></a>Self-Sizing Cell的解决方案</h3><p>理想很丰满，现实很骨感。Self-Sizing Cell可以解决问题，但是它自身也有它自己的问题。</p>
<p>首先Self-Sizing Cell必须使用Autolayout布局，用Frame方式布局从iOS诞生就开始了，只要稍稍有点历史的项目，在维护中肯定会遇到用Frame布局的Cell。所以不能使用纯Autolayout布局的方案。</p>
<p>其次是Self-Sizing Cell本身的设计策略，导致它有一定的性能嫌疑。在iOS8之前，TableView会缓存下Cell的高度，反复滑动Cell不会重复计算；但是在iOS8以后，苹果认为Cell可能会随时改变大小（用户在设置里面调整字体什么的）所以不会做缓存了，这就导致了同一个Cell在反复滑动的时候会反复计算高度。</p>
<p>最后是iOS6、7、8三个版本中关于高度计算API不一致的问题：<br>在iOS6上，我们是在<code>tableView:heightForRowAtIndexPath:</code>方法里返回通过数据计算的高度；而在在iOS7中，出现了<code>estimatedRowHeight</code>相关的属性，苹果通过这个属性把计算的工作从TableView加载时延迟到了Cell出现时，提高了TableView的加载速度；在iOS8中只需要写<code>self.tableView.estimatedRowHeight = RowHeight</code>这样的一行代码就能自动计算出Cell的高度(前提是Cell使用Autolayout写的布局)。可以看到随着苹果对Cell高度计算的不断优化让代码越来越简单，但是越简单的API需要的iOS版本越高，如果App要兼容低版本，就不得不在工程里写很多冗余的兼容性代码。</p>
<p>那如何能解决上面的这些问题呢，答案就是<code>UITableView+FDTemplateLayoutCell</code>。</p>
<h3 id="UITableView-FDTemplateLayoutCell简介"><a href="#UITableView-FDTemplateLayoutCell简介" class="headerlink" title="UITableView+FDTemplateLayoutCell简介"></a><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">UITableView+FDTemplateLayoutCell</a>简介</h3><p>关于UITableView+FDTemplateLayoutCell我就直接把<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">作者</a>的原话扒过来。</p>
<blockquote>
<p>使用<code>UITableView+FDTemplateLayoutCell</code>无疑是解决算高问题的最佳实践之一，既有 iOS8<br>self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。 使用起来大概是这样： </p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;-(CGFloat)<span class="string">tableView:</span>(UITableView *)tableView <span class="string">heightForRowAtIndexPath:</span>(NSIndexPath *)indexPath &#123;</div><div class="line">&gt;     <span class="keyword">return</span> [tableView <span class="string">fd_heightForCellWithIdentifier:</span>@<span class="string">"identifer"</span> <span class="string">cacheByIndexPath:</span>indexPath <span class="string">configuration:</span>^(id cell) &#123;</div><div class="line">&gt;         <span class="comment">// 配置 cell 的数据源，和 "cellForRow" 干的事一致，比如：</span></div><div class="line">&gt;         cell.entity = self.feedEntities[indexPath.row];</div><div class="line">&gt;     &#125;]; &#125; </div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>写完上面的代码后，你就已经使用到了：</p>
<ul>
<li>和每个 UITableViewCell ReuseID 一一对应的 template layout cell<br>这个 cell 只为了参加高度计算，不会真的显示到屏幕上；它通过 UITableView 的 <code>-dequeueCellForReuseIdentifier:</code> 方法 lazy 创建并保存，所以要求这个 ReuseID 必须已经被注册到了 UITableView 中，也就是说，要么是 Storyboard 中的原型 cell，要么就是使用了 UITableView 的 <code>-registerClass:forCellReuseIdentifier:</code> 或 <code>-registerNib:forCellReuseIdentifier:</code>其中之一的注册方法。</li>
<li>根据 autolayout 约束自动计算高度<br>使用了系统在 iOS6 就提供的 API：<code>-systemLayoutSizeFittingSize:</code></li>
<li>根据 index path 的一套高度缓存机制<br>计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了非常可观的多余计算。</li>
<li>自动的缓存失效机制<br>无须担心你数据源的变化引起的缓存失效，当调用如<code>-reloadData</code>，<code>-deleteRowsAtIndexPaths:withRowAnimation:</code>等任何一个触发 UITableView 刷新机制的方法时，已有的高度缓存将以最小的代价执行失效。如删除一个 indexPath 为 [0:5] 的 cell 时，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。</li>
</ul>
</blockquote>
<h3 id="UITableView-FDTemplateLayoutCell代码分析"><a href="#UITableView-FDTemplateLayoutCell代码分析" class="headerlink" title="UITableView+FDTemplateLayoutCell代码分析"></a>UITableView+FDTemplateLayoutCell代码分析</h3><p>好了，上面说了<code>UITableView+FDTemplateLayoutCell</code>具有这么多功能，那这部分就来分析一下这些功能的实现方式。先说一下实现的方式路再上代码。</p>
<h4 id="高度计算"><a href="#高度计算" class="headerlink" title="高度计算"></a>高度计算</h4><p><code>UITableView+FDTemplateLayoutCell</code>在TableVie内部维护了一个模板Cell结构，它不会加入TableView中，模板Cell会自动调用Cell默认的方法实例化，然后根据传入的数据对这个模板进行填充，再计算高度。Cell的高度计算使用了两种方式，一种针对于Autolayout写的Cell调用<code>[cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize]</code>自动计算行高；另一种是对于Frame调用<code>[cell sizeThatFits:CGSizeMake(contentViewWidth, 0)]</code>手动计算行高。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>基于NSDictionary的缓存。如果调用的是带缓存的API，那在计算出高度后会缓存结果，下次再计算时会先查询缓存。这个框架已经把会引起TableView重新加载的方法都做了替换，在这些方法被调用时会先清空缓存再调用以前的方法。</p>
<p><code>- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration;</code></p>
<p>这个方法是高度计算的核心，API很简单，<code>identifier</code>是复用的标识，<code>configuration</code>主要用于你来用数据填充Cell<br>下面来看一下内部的代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)fd_heightForCellWithIdentifier:(<span class="built_in">NSString</span> *)identifier configuration:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> cell))configuration &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">UITableViewCell</span> *templateLayoutCell = [<span class="keyword">self</span> fd_templateCellForReuseIdentifier:identifier];</div><div class="line">    </div><div class="line">    [templateLayoutCell prepareForReuse];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (configuration) &#123;</div><div class="line">        configuration(templateLayoutCell);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> fd_systemFittingHeightForConfiguratedCell:templateLayoutCell];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里为了突出主干逻辑，删掉了断言还有注释以及一部分非必要逻辑。从代码上看流程非常清晰，第一行获取到模板Cell，然后调用Cell的<code>prepareForReuse</code>方法来确保对Cell的调用行为和真实的一样(其实如果你所有的cell都没有在<code>prepareForReuse</code>方法里面写初始化代码的话，那这一行可有可无)。接着调用<code>configuration</code>来配置模板Cell，然后调用<code>[self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell]</code>来计算高度。</p>
<p>下面来深入<code>fd_systemFittingHeightForConfiguratedCell:</code>这个方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)fd_systemFittingHeightForConfiguratedCell:(<span class="built_in">UITableViewCell</span> *)cell &#123;</div><div class="line">    <span class="built_in">CGFloat</span> contentViewWidth = <span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.frame);</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cell.accessoryView) &#123;</div><div class="line">        contentViewWidth -= <span class="number">16</span> + <span class="built_in">CGRectGetWidth</span>(cell.accessoryView.frame);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> systemAccessoryWidths[] = &#123;</div><div class="line">            [<span class="built_in">UITableViewCellAccessoryNone</span>] = <span class="number">0</span>,</div><div class="line">            [<span class="built_in">UITableViewCellAccessoryDisclosureIndicator</span>] = <span class="number">34</span>,</div><div class="line">            [<span class="built_in">UITableViewCellAccessoryDetailDisclosureButton</span>] = <span class="number">68</span>,</div><div class="line">            [<span class="built_in">UITableViewCellAccessoryCheckmark</span>] = <span class="number">40</span>,</div><div class="line">            [<span class="built_in">UITableViewCellAccessoryDetailButton</span>] = <span class="number">48</span></div><div class="line">        &#125;;</div><div class="line">        contentViewWidth -= systemAccessoryWidths[cell.accessoryType];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> fittingHeight = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!cell.fd_enforceFrameLayout &amp;&amp; contentViewWidth &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">        <span class="built_in">NSLayoutConstraint</span> *widthFenceConstraint = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:cell.contentView attribute:<span class="built_in">NSLayoutAttributeWidth</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="literal">nil</span> attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span> multiplier:<span class="number">1.0</span> constant:contentViewWidth];</div><div class="line">        [cell.contentView addConstraint:widthFenceConstraint];</div><div class="line">        </div><div class="line">        fittingHeight = [cell.contentView systemLayoutSizeFittingSize:<span class="built_in">UILayoutFittingCompressedSize</span>].height;</div><div class="line">        [cell.contentView removeConstraint:widthFenceConstraint];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (fittingHeight == <span class="number">0</span>) &#123;</div><div class="line">        fittingHeight = [cell sizeThatFits:<span class="built_in">CGSizeMake</span>(contentViewWidth, <span class="number">0</span>)].height;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> fittingHeight;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法首先获取到Cell的宽度，得到宽度后根据是否有自定义的accessoryView来调整Cell的宽度。（这里关于关于静态数组systemAccessoryWidths的使用可能不太常见，这个是C的写法，就是静态不定长度的数组的初始化，这里面数组的长度等于花括号里面给出的最大索引值+1，其他没有给定明确初始值的都是0）然后调用 <code>[cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize]</code>来自动计算出Cell的高度，这里在计算之前临时添给Cell.contentView添加了一个和Cell等宽的约束是为了让内部View知道自己的父View的大小，减少因无法得知contentView的宽度而导致约束计算失败的情况。最后一步是判断Autolayout计算的结果是否正确，因为需要兼容使用Frame布局的Cell的情况，当Autolayout计算失败后再尝试着调用<code>[cell sizeThatFits:CGSizeMake(contentViewWidth, 0)]</code>来计算高度。</p>
<p>下面来看带缓存的方法:</p>
<p><code>- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration</code></p>
<p><code>- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id&lt;NSCopying&gt;)key configuration:(void (^)(id cell))configuration</code></p>
<p>这两个方法一个是按IndexPath做缓存一个是按Key做缓存。两者都是基于NSDictionary实现的，按Key缓存比较简单，内部实现基本上可以理解为cache[Key]=rowHeight这样的形式，具体的代码就不赘述。IndexPath缓存因为涉及IndexPath数组的增删改的操作而稍稍复杂一点，不过虽然比前者复杂但是本质也是在维护一个NSDictionary，这里就不再详细介绍，而是讲一下IndexPath缓存中实现的比较有意思的地方。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)buildSectionsIfNeeded:(<span class="built_in">NSInteger</span>)targetSection &#123;</div><div class="line">    [<span class="keyword">self</span> enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> section = <span class="number">0</span>; section &lt;= targetSection; ++section) &#123;</div><div class="line">            <span class="keyword">if</span> (section &gt;= heightsBySection.count) &#123;</div><div class="line">                heightsBySection[section] = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法里面有意思的地方在于当你传入的Section如果大于当前的最大Section时，会自动创建后续的所有Section，比如现在Section数组有3个元素，然后你的入参为20，那这个循环会创建剩下的17个Section数组。这里作者用到了一个NSMutableArray的一个不太常用的语法，就是<code>NSMutableArray[最大索引值]=NewItem</code>，这个等价于<code>[NSMutableArray addObject:NewItem]</code>，使用不太常见的语法让代码更精炼的例子在这个框架里面还有几个，可见作者OC的基本功非常扎实。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">fd_deleteSections</span><span class="selector-pseudo">:(NSIndexSet</span> *)<span class="selector-tag">sections</span> <span class="selector-tag">withRowAnimation</span><span class="selector-pseudo">:(UITableViewRowAnimation)animation</span> &#123;</div><div class="line">        <span class="selector-attr">[sections enumerateIndexesUsingBlock:^(NSUInteger section, BOOL *stop) &#123;</span></div><div class="line">            [self.fd_indexPathHeightCache buildSectionsIfNeeded:section];</div><div class="line">            <span class="selector-attr">[self.fd_indexPathHeightCache enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123;</span></div><div class="line">                [heightsBySection removeObjectAtIndex:section];</div><div class="line">            &#125;];</div><div class="line">        &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">fd_moveSection</span><span class="selector-pseudo">:(NSInteger)section</span> <span class="selector-tag">toSection</span><span class="selector-pseudo">:(NSInteger)newSection</span> &#123;</div><div class="line">        <span class="selector-attr">[self.fd_indexPathHeightCache buildSectionsIfNeeded:section]</span>;</div><div class="line">        <span class="selector-attr">[self.fd_indexPathHeightCache buildSectionsIfNeeded:newSection]</span>;</div><div class="line">        <span class="selector-attr">[self.fd_indexPathHeightCache enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123;</span></div><div class="line">            [heightsBySection exchangeObjectAtIndex:section withObjectAtIndex:newSection];</div><div class="line">        &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分代码有意思的地方是作者的编程的思路。删除或者移动索引的时候可能相应的索引可能并不存在，有的人会在这里先判断，然后根据不同情况做不同的处理，这样做肯定是没问题的。不过作者在这里的做法是统统调一遍<code>[self.fd_indexPathHeightCache buildSectionsIfNeeded:section]</code>保证索引肯定存在，避免了加一些冗长的判断语句，代码比显得较干净。这里把未知问题转换成已知问题的思路体现得淋漓尽致，而且特别能体现出程序设计的模块化设计与复用的美感。</p>
<p>好了，到这里<code>UITableView+FDTemplateLayoutCell</code>的分析就写完了，可能有的人会感觉怎么才这点东西。东西确实不多，因为这个框架本身很简单，全部代码加上注释才600多行代码。不过见微知著，寥寥几百行代码体现了作者良好的编程思维以及扎实的语言基本功。这也是我们需要学习的地方。</p>
<h3 id="UITableView-FDTemplateLayoutCell集成"><a href="#UITableView-FDTemplateLayoutCell集成" class="headerlink" title="UITableView+FDTemplateLayoutCell集成"></a>UITableView+FDTemplateLayoutCell集成</h3><p>其实最后一部分内容很少。主要是针对于老的使用Frame布局的Cell使用这个框架的实践。前面也说过如果用Autolayout的Cell是自动计算的，Frame布局的Cell是通过<code>[cell sizeThatFits:CGSizeMake(contentViewWidth, 0)]</code>来做，所以需要把Frame布局的Cell的<code>sizeThatFits</code>方法重载，因为<code>sizeThatFits</code>方法没有入参，所以需要让Cell持有数据Model，然后在<code>sizeThatFits</code>里调用以前计算高度的方法就行了。这里Cell持有数据Model可以用weak的属性来修饰，避免可能的引用循环问题。</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>他山之石，可以攻玉。这篇文章的核心就是基于<code>UITableView+FDTemplateLayoutCell</code>的工程实践，感谢作者sunnyxx的无私奉献。sunnyxx的博客中还有不少有深度的iOS技术分析。这里贴一下他的</p>
<p><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">博客地址：</a><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/</a></p>
<p><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">GitHub地址：</a><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a></p>
</div><div class="tags"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS开发/">iOS开发</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/09/13/cell-height-calc-with-autolayout/">项目中Cell自动计算行高的实践</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Ney的技术博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>