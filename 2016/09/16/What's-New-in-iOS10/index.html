<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>What's New in iOS | Ney的技术博客</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">What's New in iOS</h1><a id="logo" href="/.">Ney的技术博客</a><p class="description">Learning，sharing，improving</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">What's New in iOS</h1><div class="post-meta">Sep 16, 2016<span> | </span><span class="category"><a href="/categories/iOS开发/">iOS开发</a></span></div><div class="post-content"><p>iOS10出现了很多新特性，这些新特性在官方的《What’s New in iOS》文章中做了一个综合性的简介。作为iOS开发者有必要对系统的新特性做一下跟进，所以就把上述提到的那篇文章翻译了一下，希望能对大家有所帮助！</p>
<h2 id="What’s-New-in-iOS"><a href="#What’s-New-in-iOS" class="headerlink" title="What’s New in iOS"></a>What’s New in iOS</h2><p>这篇文章汇总了在iOS10上引入的关于开发方面的重要新特性，也讲了一些关于新特性的细节。</p>
<p>如果想了解最前沿的新闻和已知的issues可以去看<a href="https://developer.apple.com/ios/download/" target="_blank" rel="external">iOS10 Release Notes</a>。至于iOS10新APIs列表，可以看<a href="https://developer.apple.com/library/content/releasenotes/General/iOS10APIDiffs/index.html" target="_blank" rel="external">iOS 10.0 API Diffs</a>。想了解新设备的细节可以去看<a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="external">iOS Device Compatibility Reference</a>。</p>
<p>关于Swift的更新可以看<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/WhatsNewXcode/introduction.html#//apple_ref/doc/uid/TP40004635-SW3" target="_blank" rel="external">Swift Language</a>和<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external">The Swift Programming Language (Swift 3)</a>。</p>
<h3 id="触觉反馈"><a href="#触觉反馈" class="headerlink" title="触觉反馈"></a>触觉反馈</h3><p>在iPhone7和iPhone 7plus上，触觉反馈是一种获取用户注意力和增加交互沉浸感的新方式(可以理解为Force Touch的进一步运用。译者注)，像系统提供的pickers、switches和sliders都已经具有了触觉反馈特性。</p>
<p>UIKit引入了<code>UIFeedbackGenerator</code>类以及相关的3个子类来提供触觉反馈功能，不同的子类对应不同的触觉反馈场景，详情见下表。</p>
<p><img src="/images/Haptic-feedback.png" alt=""></p>
<p>另外你可以调用UIFeedbackGenerator的实例方法<code>prepare</code>来通知系统在经过一小段延迟后生成触觉反馈。</p>
<h3 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h3><p>Siri现在可以和App集成在一起了，不过只能支持特定类型的App。App集成Siri的方式是用<code>Intents</code>和<code>Intents UI frameworks</code>建立一个或多个应用扩展。下面是Siri支持的App类型：</p>
<ul>
<li>音频视频电话</li>
<li>短信</li>
<li>支付</li>
<li>照片搜索</li>
<li>打车</li>
<li>锻炼(可能是让手机开始记录你的健身活动，译者注)</li>
<li>调整设置(只能在支持CarPlay的汽车上，这个是提供给汽车厂商的)</li>
<li>预定餐厅(需要Apple的额外支持)</li>
</ul>
<p>当用户的Siri指令涉及到你的服务时，SiriKit会给你的App扩展发送一个<code>Intent</code>对象，它描述了用户的指令以及相关的信息。你需要根据<code>Intent</code>对象做出具体处理用户指令的应答。一般情况下Siri会接管所有的用户交互，但你也可以自定义UI来显示更多的信息以及增加品牌曝光 。</p>
<p>SiriKit提供了一个接收App内部发生的交互和活动数据的机制。并定义了一个interaction的对象，这个对象包含了之前说到的<code>Intent</code>对象以及诸如指令开始处理的时刻和持续时间等<code>intent-handling</code>过程的信息。如果App注册的可处理的活动类型刚好与用户的intent同名，即使你没有开发Siri应用扩展，系统也会启动你的App，并发送相关的Siri事件信息。</p>
<p>虽说用户通过地图App和Siri都可以打车，而且还能在地图App里订餐。但你的Intent扩展无论是处理从地图App发起的请求还是从Siri发起的，其方式完全一样。当然，你如果是自定义UI的话，仍可以根据不同的来源定制不同的UI。</p>
<p>想进一步了解SiriKit并给用户一种新方式使用你的服务，可以看<a href="https://developer.apple.com/library/content/documentation/Intents/Conceptual/SiriIntegrationGuide/index.html#//apple_ref/doc/uid/TP40016875" target="_blank" rel="external">SiriKit Programming Guide</a>。想了解如何开发<code>Intents</code>扩展可以看<a href="https://developer.apple.com/reference/intents" target="_blank" rel="external">Intents Framework Reference</a>和<a href="https://developer.apple.com/reference/intentsui" target="_blank" rel="external">Intents UI Framework Reference</a>。</p>
<h3 id="基于场景的智能推荐"><a href="#基于场景的智能推荐" class="headerlink" title="基于场景的智能推荐"></a>基于场景的智能推荐</h3><p>iOS10引入了一种新的方式来增加用户体验，那就是基于场景的智能推荐。如果你提供适当的场景信息的话，系统就可以在合适的时机展示你的App。如果你曾适配过iOS9的App搜索，你就明白如何通过Spotlight、Safari搜索结果、Handoff和Siri建议来展示App内容数据。在iOS10以后，你可以提供用户在App内的活动信息来帮助系统在其他地方展示你的App，例如键盘的词汇联想区、地图、CarPlay、应用切换列表(双击Home键切换应用的那个界面，译者注)、Siri交互界面和锁屏界面(仅对音视频App)。这些和系统深度整合的功能由NSUserActivity，Web<br>markup，Core Spotlight、MapKit、UIKit和Media Player等技术提供。</p>
<p>在iOS10，NSUserActivity对象包含了mapItem属性，它能让你提供用于其他场景的位置信息。例如，你的App显示了一个酒店的信息，你可以在mapItem属性里保存酒店的地理位置信息，当用户切换到一个行程规划App中时，你刚刚保存的酒店地理位置信息会自动提供给它。如果你的App支持应用内搜索，你可以在CSSearchableItemAttributeSet中使用新的基于文本的地址属性，比如<code>thoroughfare</code>和<code>postalCode</code>，来完整地描述用户想去的地理位置。另外注意当你使用mapItem属性时，系统会自动把它的内容填充到contentAttributeSet属性中。</p>
<p>如果要共享一个地理位置信息给系统的话，一定要提供经纬度信息，以及指定CSSearchableItemAttributeSet中的地址属性。另外也建议提供 namedLocation属性，用户能看到位置的名字当然是最好的；此外还有phoneNumbers属性，如果指定了它的值的话，用户可以直接用Siri拨打这个电话。</p>
<p>在iOS9上，给应用内容的镜像站点上添加Web Markup信息可以让用户在Spotlight和Safari搜索结果中直接查看App的内容数据。在iOS10上你可以使用定义在Schema.org上的地理位置相关的词汇，如PostalAddress来进一步提高用户体验。例如，当用户查看你的网站上显示的一个位置时，如果用户切换到地图应用，系统会自动显示这个位置的提示。对于Schema.org上的词汇，Safari同时支持JSON-LD和Micordata编码。</p>
<p>UIKit在UITextInputTraits协议中引入了textContentType属性。你可以告诉系统希望用户在文本框所输入内容的含义。当你提供了这些信息以后，系统能在某些场合自动切换到适当类型的键盘以及增进智能推荐的效果。例如，如果你指定UITextContentTypeFullStreetAddress属性来告诉系统你希望用户输入的是一个地址，系统就会自动提示用户最近所浏览的地址信息。</p>
<p>如果你是媒体播放器类型的App，并且使用了<code>MPPlayableContentManager</code>APIs，在iOS10以后，能让用户在锁屏界面就直接通过你的App播放媒体。</p>
<p>如果你是ride-sharing类型的App，并且使用了<code>MKDirectionsRequest</code>API，iOS10以后，当用户想开始行程时能在应用切换界面显示这个App。想要注册ride-share provider，只需要在Info.plist文件中增加<code>MKDirectionsApplicationSupportedModes</code>字段并把值设为<code>MKDirectionsModeRideShare</code>就可以了。如果你的App仅仅支持ride sharing，系统显示的建议的文字会以“Get a ride to…”开头；如果你的App同时支持ride sharing和其他种类的交通路线(比如骑行或者驾车)系统显示的建议的文字会以“Get directions to…”开头。注意你接收到的MKMapItem对象可能不包含经纬度信息，需要手动获取。</p>
<h3 id="Messages-App扩展"><a href="#Messages-App扩展" class="headerlink" title="Messages App扩展"></a>Messages App扩展</h3><p>在iOS10后，你可以创建和Messages App进行交互的App扩展。它能让用户发送文本、表情、媒体文件以及已读反馈。如果把扩展标记为<code>#images</code>类型，那扩展内的表情(图片)资源就会成为公开的，苹果可以对这些公开的表情进行索引和热度排行。</p>
<p>Messages App的扩展有下面两种：</p>
<ul>
<li>表情包</li>
<li>在Messages App内能展现自定义UI的<code>iMessage app</code>，能让用户浏览表情、文本和媒体文件，并创建、发送以及更新消息</li>
</ul>
<p><code>iMessage app</code>可以让用户直接在Messages App内部直接搜索应用内容的镜像站点上的图片。</p>
<p>创建表情包很简单根本不用敲代码，只要在Xcode里把表情包图片文件夹拖到asset catalog中就行了。</p>
<p>开发一个<code>iMessage app</code>需要使用<code>Messages.framework</code>，Messages framework的详细信息参见<a href="https://developer.apple.com/reference/messages" target="_blank" rel="external">Messages Framework Reference</a>。至于如何创建一个扩展可以看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="external">App Extension Programming Guide</a>。</p>
<p><code>#images app</code>展示了当前最火的表情。你在扩展中公开的表情资源经过苹果的爬虫(如Applebot)收录后会被展示到<code>#images app</code>里。经过下面这几个步骤就能把扩展注册为<code>#images app</code>类型：</p>
<ul>
<li>创建一个<code>iMessage app</code></li>
<li>在app的entitlements里添加<code>com.apple.developer.associated-domains</code>字段。包含了你想要被收录的表情(图片)所在的站点的域名列表。每个域名都需要以<code>spotlight-image-search</code>开头，例如<code>spotlight-image-search:yourdomain.com</code></li>
<li>表情(图片)所在的站点上添加一个以<code>apple-app-site-association</code>命名的字典文件(key-val结构，比如json，译者注)。里面需要包含你的app ID(以team ID或者app ID为前缀)和bundle ID。一个<code>#images</code>索引最多能包含500个paths和patterns(website paths的例子可以看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW4" target="_blank" rel="external">Creating and Uploading the Association File</a>)</li>
<li>允许Applebot进行收录(参见<a href="https://support.apple.com/en-us/HT204683" target="_blank" rel="external">About Applebot</a>)</li>
</ul>
<h3 id="推送通知"><a href="#推送通知" class="headerlink" title="推送通知"></a>推送通知</h3><p>iOS10引入了全新的推送通知框架(UserNotifications.framework)，它统一了本地通知和远程推送通知。你可以用新框架根据时间和地点等条件触发的本地通知。现在这个框架还能在设备收到通知后让你拦截和修改通知的内容。</p>
<p>除了上面说的外在iOS10还引入了推送通知UI框架(UserNotificationsUI.framework) ，当通知到达设备上时可以显示自定义的UI了。而且可以开发对应的扩展来响应用户对通知的操作。</p>
<h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><p>iOS10引入了新的连续语音识别框架<code>Speech.framework</code>，除了语音识别外还能把语音转换成文字。另外语音识别和录音可以同时进行。下面是示例代码<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> recognizer = SFSpeechRecognizer()</div><div class="line"><span class="keyword">let</span> <span class="built_in">request</span> = SFSpeechURLRecognitionRequest(url: audioFileURL)</div><div class="line">recognizer?.recognitionTask(<span class="keyword">with</span>: <span class="built_in">request</span>, resultHandler: &#123; (result, <span class="keyword">error</span>) <span class="keyword">in</span></div><div class="line">     print (result?.bestTranscription.formattedString)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>语音识别中为了提高识别率，苹果会把用户的语音数据临时保存在服务器上，所以算是获取到了用户的隐私数据(关于访问用户的隐私数据的细节可以看<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW3" target="_blank" rel="external">Security and Privacy Enhancements</a>)，所以这里需要用户的授权。获取语音识别的授权需要在Info.plist文件里增加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW52" target="_blank" rel="external">NSSpeechRecognitionUsageDescription</a>字段，内容就是你对数据用途的描述。</p>
<p>另外当你在进行语音识别时记得加上明确的UI引导，这样用户体验会更好。</p>
<h3 id="广色域"><a href="#广色域" class="headerlink" title="广色域"></a>广色域</h3><p>系统中大量的图形组件，如Core Graphics、Core Image、Metal和AVFoundation等现在支持更大的色彩空间。UIKit现在已经集成了这个新特性。<br>下面是使用广色域特性的最佳实践：</p>
<ul>
<li>在iOS10上，<code>[UIColor](https://developer.apple.com/reference/uikit/uicolor)</code>使用了扩展的sRGB色彩空间，initializers no longer clamp raw component values to between 0.0 and 1.0. If your app relies on UIKit to clamp component values (whether you’re creating a color or asking a color for its component values), you need to change your app’s behavior when you link against iOS 10.</li>
<li>iPad Pro(9.7寸)上在UIView自定义draw方法时，色彩空间默认就是扩展的sRGB</li>
<li>如果需要渲染自定义图片对象，使用<a href="https://developer.apple.com/reference/uikit/uigraphicsimagerenderer" target="_blank" rel="external">UIGraphicsImageRenderer</a>来控制生成的位图的色彩空间是extended-range还是standard-range</li>
<li>如果在支持宽色域的设备上用Core Graphics、Metal等底层API处理图片，应该用扩展的色彩空间并且要用16位的floating-point component values. When clamping of color values is necessary, you should do so explicitly</li>
<li>Core Graphics、Core Image和Metal执行Shaders时提供了转换颜色和图片的色彩空间的功能</li>
</ul>
<h3 id="True-Tone-Display适配"><a href="#True-Tone-Display适配" class="headerlink" title="True Tone Display适配"></a>True Tone Display适配</h3><p>True Tone display利用环境光传感器根据用户周边的光照自动调整色彩和显示强度。为了True Tone在标准色上产生的色彩偏移不会给应用带来负面影响，可以在Info.plist添加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW31" target="_blank" rel="external">UIWhitePointAdaptivityStyle</a>字段，并指定适当的类型，例如：</p>
<ul>
<li>如果你的应用是照片编辑类的，对色彩精准地还原才是重中之重。可以指定类型为UIWhitePointAdaptivityStylePhoto来减少True Tone产生的色彩偏移</li>
<li>如果你的应用是阅读类的，舒适的阅读环境对用户最重要。可以指定指定类型为UIWhitePointAdaptivityStyleReading来增加True Tone产生的色彩偏移</li>
</ul>
<h3 id="App-Search增强"><a href="#App-Search增强" class="headerlink" title="App Search增强"></a>App Search增强</h3><p>iOS10上Core Spotlight框架得到了一些增强：</p>
<ul>
<li>应用内搜索</li>
<li>Search continuation</li>
<li>Crowdsourcing deep link popularity with differential privacy</li>
<li>Visualization of validation results</li>
</ul>
<p>新的<a href="https://developer.apple.com/reference/corespotlight/cssearchquery" target="_blank" rel="external">CSSearchQuery</a>类支持应用内搜索。使用这个API可以避免自己维护内容索引，并能马上能利用Spotlight技术带来的便利，类似于，邮件、短信和备忘录的搜索，这个完全是在应用内进行。</p>
<p>在iOS9，通过搜索APIs(比如Core Spotlight、NSUserActivity还有web markup)来索引应用内的内容后，用户就能通过Spotlight和Safari搜索来使用它。在iOS10上，Core Spotlight功能进一步增强。当用户通过搜索特定内容启动App时，可以得知用户搜索的内容，并显示出相应的数据。在Info.plist中增加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW43" target="_blank" rel="external">CoreSpotlightContinuation</a>字段并设置为YES就可以启用这个特性。另外需注意如果开启这个特性需要实现对<a href="https://developer.apple.com/reference/corespotlight/csquerycontinuationactiontype" target="_blank" rel="external">CSQueryContinuationActionType</a>类型的activity continuation的处理逻辑。<a href="https://developer.apple.com/reference/uikit/uiapplicationdelegate/1623072-application" target="_blank" rel="external">application:continueUserActivity:restorationHandler:</a>方法回传的<a href="https://developer.apple.com/reference/foundation/nsuseractivity" target="_blank" rel="external">NSUserActivity</a>对象包含了用户信息，通过<a href="https://developer.apple.com/reference/corespotlight/cssearchquerystring" target="_blank" rel="external">CSSearchQueryString</a>可以取到用户的搜索关键字。</p>
<p>iOS10引入了更具隐私的技术来提高你的App内容在用户搜索中的曝光率。新引入的<a href="https://developer.apple.com/reference/foundation/nsuseractivity/1414701-iseligibleforpublicindexing" target="_blank" rel="external">eligibleForPublicIndexing</a>属性可以告诉系统是否把指定内容设为公共的(所有iOS用户都可以查看,译者注)，当用户使用App或者<a href="https://developer.apple.com/reference/foundation/nsuseractivity" target="_blank" rel="external">NSUserActivity</a>包含一个<code>deep link</code>时，如果它们的<code>eligibleForPublicIndexing</code>被设置成了YES，系统就会把对应的数据经过信息哈希算法生成内容摘要(内容摘要是不包含用户数据的字符串，不能反向还原出原内容，译者注)，然后发送到苹果的服务器。苹果的服务器只用统计这些内容摘要的使用频率就能算出热度排行，从而对搜索进行排名，这个过程完全不涉及到具体的用户数据。</p>
<p>当你用App搜索有效性验证工具测试你的website markup和deep links时，它现在有更人性化的视觉展示了。包括支持的markup(具体定义在<a href="http://schema.org/" target="_blank" rel="external">Schema.org</a>上)。这个工具能查看Applebot对你的应用内容的具体收录信息，类似于title、description、URL以及其他的元素。App搜索有效性验证工具在这里：<a href="https://search.developer.apple.com/appsearch-validation-tool。如果想了解如何支持`deep" target="_blank" rel="external">https://search.developer.apple.com/appsearch-validation-tool。如果想了解如何支持`deep</a> links<code>和</code>markup`可以看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8" target="_blank" rel="external">Mark Up Web Content</a>。</p>
<p>想要了解如何让Messages app内的表情(图片)可以被外部搜索到，可以看<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW4" target="_blank" rel="external">Integrating with the Messages App</a>。</p>
<h3 id="Widget增强"><a href="#Widget增强" class="headerlink" title="Widget增强"></a>Widget增强</h3><p>iOS10重新设计了锁屏界面，现在从锁屏界面右滑就能看见widgets。为了保证widget在各种背景下都好看，需要根据情况调用<a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1771278-widgetprimaryvibrancyeffect" target="_blank" rel="external">widgetPrimaryVibrancyEffect</a>或<a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1771277-widgetsecondaryvibrancyeffect" target="_blank" rel="external">widgetSecondaryVibrancyEffect</a>(这两个方法会替代即将废弃的<a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1613917-notificationcentervibrancyeffect" target="_blank" rel="external">notificationCenterVibrancyEffect</a>)。另外widgets现在新增加了显示模式的概念(通过<a href="https://developer.apple.com/reference/notificationcenter/ncwidgetdisplaymode" target="_blank" rel="external">NCWidgetDisplayMode</a>属性获取显示模式)，需要你根据用户选择的模式显示合适的内容。(现在就是”展开”、”收起”两种模式，需要根据用户的选择，来显示较少或更多的内容，译者注)。</p>
<h3 id="Apple-Pay增强"><a href="#Apple-Pay增强" class="headerlink" title="Apple Pay增强"></a>Apple Pay增强</h3><p>iOS10以后用户可以在网站上使用Apple Pay，还能直接用Siri和地图下达支付命令。对于开发者而言，iOS10引入了同时支持iOS和watchOS的新API，并且支持随时更换银行卡和新沙盒测试环境。</p>
<p>iOS10引入的新API可以直接集成到网站上，当网站集成好Apple Pay后，用户通过Safari(iOS和macOS都行)浏览时就能用Apple Pay付款。想要了解更多关于网站集成Apple Pay的知识可以看<a href="https://developer.apple.com/reference/applepayjs" target="_blank" rel="external">ApplePay JS Framework Reference</a>。</p>
<p>PassKit框架(PassKit.framework)引入的新API不依赖UIkit。比如PKPaymentAuthorizationController和PKPaymentAuthorizationControllerDelegate的特性是由PKPaymentAuthorizationViewController和它的委托来实现的。但它也不需要导入UIKit。 尽管是为了让watchOS和其他情况使用Apple Pay而设计的这些API，但建议实现一套统一的代码框架来适配Apple Pay的所有使用场景(Siri、网站、地图，译者注)。想要了解更多关于Siri集成的知识可以看<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW5" target="_blank" rel="external">SiriKit</a>。</p>
<p>PassKit还有一项新特性。就是让发卡商家从他们的应用中显示卡片。<code>PKPaymentButtonTypeInStore</code>类型的button可以给卡片显示Apple Pay的标志。实现<code>presentPaymentPass:</code>方法就能显示卡片。(<code>presentPaymentPass:</code>方法在<a href="https://developer.apple.com/reference/passkit/pkpasslibrary" target="_blank" rel="external">PKPassLibrary</a>中定义)。</p>
<p>当有新的行银片绑定时，应用能自动适应而不需要重新发版。<a href="https://developer.apple.com/reference/passkit/pkpaymentrequest/1833288-availablenetworks" target="_blank" rel="external">availableNetworks</a>方法可以查询当前可用的银行卡。另外<a href="https://developer.apple.com/reference/passkit/pkpaymentrequest/1619329-supportednetworks" target="_blank" rel="external">supportedNetworks</a>属性可以限定所支持的银行卡。想了解更多关于Apple Pay的知识可以去：<a href="https://developer.apple.com/apple-pay/。" target="_blank" rel="external">https://developer.apple.com/apple-pay/。</a></p>
<p>iOS10引入了新的测试技术，可以直接在设备上添加测试卡片。测试环境返回加密的支付数据。需要下面几步来开启测试环境：<br>1<em> 在iTunes Connect上新建一个iCloud测试账号<br>2</em> 在设备上登录测试账号<br>3<em> 设置这个账号所在的地区<br>4</em> 使用<a href="https://developer.apple.com/apple-pay/上列出的银行卡测试" target="_blank" rel="external">https://developer.apple.com/apple-pay/上列出的银行卡测试</a></p>
<p>注意：如果切换iCloud账号，测试环境也会自动切换。所以最好用真实的卡片在生产环境上测试。</p>
<h3 id="安全和隐私的增强"><a href="#安全和隐私的增强" class="headerlink" title="安全和隐私的增强"></a>安全和隐私的增强</h3><p>iOS10增强了代码的安全性以及用户数据的安全性。想了解更多可以看：<a href="https://developer.apple.com/security/。" target="_blank" rel="external">https://developer.apple.com/security/。</a></p>
<ul>
<li>如果应用启用了ATS，但又想在加载web内容的时候使用非安全连接。只需要在Info.plist中添加<code>NSAllowsArbitraryLoadsInWebContent</code>字段就行</li>
<li><code>SecKey</code>API增强了非对称加密key的生成。请使用<code>SecKey</code>API来替代废弃的Common Data Security Architecture (CDSA) APIs</li>
<li>SSL/TLS中已经默认禁用RC4对称加密算法了，而且Secure Transportations API未来也不会再支持SSLv3。建议尽可能地使用SHA-1和3DES加密算法</li>
<li>在iOS10上出现了可以在多台登录iCloud的设备上互相复制粘贴的功能(<a href="https://developer.apple.com/reference/uikit/uipasteboard" target="_blank" rel="external">UIPasteboard</a>)。你可以针对指定的设备把剪贴板功能做限制以及给剪贴板加上超时时间(超过时间不使用里面的内容，剪贴板就会被清空)。另外具名剪贴板不再被持久化了，作为替代你现在可以用共享式的容器。还有就是”Find”剪贴板(通过<a href="https://developer.apple.com/reference/uikit/uipasteboardnamefind" target="_blank" rel="external">UIPasteboardNameFind</a>获取)从iOS10开始被禁用了。</li>
<li>现在访问用户受保护的数据都需要在Info.plist里添加对应的字段，并附上对数据的用途的描述。例如如果要访问日历数据的话就需要在Info.plist中添加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW15" target="_blank" rel="external">NSCalendarsUsageDescription</a>并写上你用日历数据的目的。如果未经允许就读取数据会造成应用闪退。</li>
</ul>
<h3 id="CallKit"><a href="#CallKit" class="headerlink" title="CallKit"></a>CallKit</h3><p>CallKit框架(CallKit.framework)现在允许VoIP应用的呼入直接通过系统来电UI展现出来。这样用户就能直接在锁屏界面接听或拒绝VoIP呼叫，并且这个呼叫会被记录在最近通话之中。</p>
<p>CallKit还引入了来电拦截和骚扰电话识别扩展。利用这些扩展可以根据系统给定的电话号码给出具体的提示或者告诉系统这个电话是否该被拦截。</p>
<h3 id="News-Publisher增强"><a href="#News-Publisher增强" class="headerlink" title="News Publisher增强"></a>News Publisher增强</h3><p>News Publisher现在可以很容易地通过Apple News向用户提供新闻、杂志以及web内容。无论是主流杂志和新闻机构还是独立的记者和博客，任何人都可以注册为News Publisher。想要了解更多关于这方面的信息可以看：<a href="https://newsresources.apple.com。" target="_blank" rel="external">https://newsresources.apple.com。</a></p>
<h3 id="视频订阅账户"><a href="#视频订阅账户" class="headerlink" title="视频订阅账户"></a>视频订阅账户</h3><p>iOS10引入了视频订阅账户框架(VideoSubscriberAccount.framework)来帮助支持授权流媒体/视频的应用从有线电视/卫星电视供应商获取授权。使用这个框架可以达到多个视频应用一键登录的效果(必须是支持VideoSubscriberAccount的应用)，大大提升了用户体验。</p>
<h3 id="App扩展"><a href="#App扩展" class="headerlink" title="App扩展"></a>App扩展</h3><p>iOS10引入了多个新类型的App扩展：</p>
<ul>
<li>Call Directory</li>
<li>Intents</li>
<li>Itents UI</li>
<li>Messages</li>
<li>Notification Content</li>
<li>Notification Service</li>
<li>Sticker Pack</li>
</ul>
<p>另外，iOS10还包含了对第三方键盘的一些增强：</p>
<ul>
<li>可以用<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy" target="_blank" rel="external">UITextDocumentProxy </a>来检测用户正在输入的语言，并据此调整键盘。</li>
<li>新增的handleInputModeListFromView:withEvent:方法能显示系统的键盘切换按钮</li>
</ul>
<p>虽然你能自定义输入法切换按钮的外观，但这个按钮一定要放到和系统键盘一样的位置。想要了解关于应用扩展的信息可以看：<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="external">App Extension Programming Guide</a></p>
<h3 id="其他框架的改动"><a href="#其他框架的改动" class="headerlink" title="其他框架的改动"></a>其他框架的改动</h3><p>除了上述的主要改动外，iOS10还包含了其他的改进。</p>
<h5 id="AVFoundation-Camera-Capture"><a href="#AVFoundation-Camera-Capture" class="headerlink" title="AVFoundation Camera Capture"></a>AVFoundation Camera Capture</h5><p>AVFoundation框架(AVFoundation.framework)中的媒体采集组件包含了多项重要改进。</p>
<h6 id="Dual-Camera-and-Device-Discovery"><a href="#Dual-Camera-and-Device-Discovery" class="headerlink" title="Dual Camera and Device Discovery"></a>Dual Camera and Device Discovery</h6><p>iPhone7 plus的相机有2个镜头，一个为广角镜一个为长焦镜，但它们组合在一起成为一个双镜头相机。当使用这个双镜头相机时，iOS根据环境和设置自动地使用两者或者其中某一个。当你通过<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice" target="_blank" rel="external">AVCaptureDevice</a>来拍照或录视频时可以选择双镜头相机(iOS自动调整两个镜头的使用)或者单独指定是广角镜还是长焦镜。</p>
<p>在iOS10以后可以通过下面的方法使用摄像机：</p>
<ul>
<li>调用<code>defaultDeviceWithDeviceType:mediaType:position:</code>方法。  (指定<code>AVCaptureDeviceTypeBuiltInDuoCamera</code>参数启用双镜头相机。如果返回值为nil，说明设备上没有双镜头相机；指定<code>AVCaptureDeviceTypeBuiltInWideAngleCamera</code>参数启用默认的后置相机)</li>
<li>实例化一个<code>AVCaptureDeviceDiscoverySession</code>对象，指定相关的参数，并从设备列表中选择想要使用的摄像机</li>
</ul>
<p>注意：<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice" target="_blank" rel="external">AVCaptureDevice</a>的<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice/1386237-devices" target="_blank" rel="external">devices</a>和<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice/1390520-deviceswithmediatype" target="_blank" rel="external">devicesWithMediaType:</a>方法在iOS10被弃用。并且不提供访问双镜头相机和广角镜相机的方法。</p>
<p>当使用双镜头相机时，RAW格式和大部分手动控制特性都暂时不可用。这两个特性必须在单镜头相机上才能开启。关于每个镜头的性能参数可以看<a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="external">iOS Device Compatibility Reference</a>。</p>
<h6 id="New-Photo-Capture-API"><a href="#New-Photo-Capture-API" class="headerlink" title="New Photo Capture API"></a>New Photo Capture API</h6><p>新的<a href="https://developer.apple.com/reference/avfoundation/avcapturephotooutput" target="_blank" rel="external">AVCapturePhotoOutput</a>类为图片处理提供了统一的方案。这个方案能提供更细粒度的控制，监听整个采样过程以及支持新的Live Photos、RAW格式等新特性。建议用它替换<a href="https://developer.apple.com/reference/avfoundation/avcapturestillimageoutput" target="_blank" rel="external">AVCaptureStillImageOutput</a>(AVCaptureStillImageOutput在iOS10已经废弃)。</p>
<h6 id="Wide-Color"><a href="#Wide-Color" class="headerlink" title="Wide Color"></a>Wide Color</h6><p>摄像机采样现在已经支持输出宽色域数据(需要在支持宽色域的设备，译者注)。默认情况下<a href="https://developer.apple.com/reference/avfoundation/avcapturesession" target="_blank" rel="external">AVCaptureSession</a>会自动配置是否启用宽色域，具体的细节可以看：<a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="external">iOS Device Compatibility Reference</a></p>
<h5 id="AVFoundation-Media"><a href="#AVFoundation-Media" class="headerlink" title="AVFoundation Media"></a>AVFoundation Media</h5><p>AVFoundation框架(AVFoundation.framework)中的媒体播放和编辑组件包含了下列改进：</p>
<ul>
<li>不用再根据内容是视频文件还是HTTP流媒体来设置不同的<a href="https://developer.apple.com/reference/avfoundation/avplayeritem" target="_blank" rel="external">AVPlayerItem</a>了。在iOS10以后，仅仅需要设置<a href="https://developer.apple.com/reference/avfoundation/avplayer/1388846-rate" target="_blank" rel="external">rate</a>属性，AVFoundation会自动进行后续的配置</li>
<li>新的<a href="https://developer.apple.com/reference/avfoundation/avplayerlooper" target="_blank" rel="external">AVPlayerLooper</a>类让重复播放媒体的部分内容变更容易(就是复读机功能，译者注)</li>
<li>用<a href="https://developer.apple.com/reference/avfoundation/avassetdownloadurlsession" target="_blank" rel="external">AVAssetDownloadURLSession</a>类来离线媒体资源，包括HTTP流媒体等(离线到设备上，然后无网的时候也能看，译者注)。它跟FairPlay Streaming结合在一起时还能离线加密的HTTP流媒体</li>
</ul>
<h5 id="AVKit"><a href="#AVKit" class="headerlink" title="AVKit"></a>AVKit</h5><p>AVKit框架(AVKit.framework)，包含了<code>updatesNowPlayingInfoCenter</code>属性，可以调用它来刷新<code>Now Playing Info Center</code>。</p>
<h5 id="Core-Data"><a href="#Core-Data" class="headerlink" title="Core Data"></a>Core Data</h5><p>Core Data框架(CoreData.framework)包含了下列改进：</p>
<ul>
<li><a href="https://developer.apple.com/reference/coredata/nspersistentstorecoordinator" target="_blank" rel="external">NSPersistentStoreCoordinator</a>现在维护了一个SQLite连接池。<a href="https://developer.apple.com/reference/coredata/nsmanagedobjectcontext" target="_blank" rel="external">NSManagedObjectContext</a>对象(没有父MOCs)透明地支持并发查询and faulting without serializing against each other.</li>
<li><a href="https://developer.apple.com/reference/coredata/nsmanagedobjectcontext" target="_blank" rel="external">NSManagedObjectContext</a>对象和SQLite存储在WAL文件里，<code>journal_model</code>支持现在支持query generation特性。These allow a MOC to be pinned to a version of the database at a point in time and perform all future fetching and faulting against that version of the database. Pinned MOCs are moved to the most recent transaction with any save, and query generations do not survive the process’s life time.</li>
<li>新的<a href="https://developer.apple.com/reference/coredata/nspersistentcontainer" target="_blank" rel="external">NSPersistentContainer</a>类提供了高层API来维护对<code>NSPersistentStoreCoordinator</code>和<a href="https://developer.apple.com/reference/coredata/nsmanagedobjectmodel" target="_blank" rel="external">NSManagedObjectModel</a>以及其他配置源的引用</li>
<li>Core Data现在进一步地与Xcode集成在一起。并能自动生成和更新<a href="https://developer.apple.com/reference/coredata/nsmanagedobject" target="_blank" rel="external">NSManagedObject</a></li>
<li><code>NSManagedObject</code>包含了多个获取和创建其子类的快捷方法。<code>NSManagedObject</code> subclasses that have a 1:1 relationship with an entity now support <code>entity</code>.</li>
<li>Core Data对API进行了一些Swift friendly式的调整，包括像参数化的<a href="https://developer.apple.com/reference/coredata/nsfetchrequest" target="_blank" rel="external">NSFetchRequest</a>对象</li>
</ul>
<p>更多信息参见<a href="https://developer.apple.com/reference/coredata" target="_blank" rel="external">Core Data Framework Reference</a></p>
<h5 id="Core-Image"><a href="#Core-Image" class="headerlink" title="Core Image"></a>Core Image</h5><p>Core Image框架(CoreImage.framework)包含了下面这些改进。</p>
<p>搭载A8、A9CPU的设备开始支持RAW格式的图片。对于第三方相机产生的RAW格式的图片CoreImage也能很好地支持，使用RAW格式的图片需要调用<a href="https://developer.apple.com/reference/coreimage/cifilter/1437879-init" target="_blank" rel="external">filterWithImageData:options:</a>或<a href="https://developer.apple.com/reference/coreimage/cifilter/1438096-init" target="_blank" rel="external">filterWithImageURL:options:</a>来创建一个<a href="https://developer.apple.com/reference/coreimage/cifilter" target="_blank" rel="external">CIFilter</a>对象，再根据RAW Image Options选项调整RAW数据，最后从<a href="https://developer.apple.com/reference/coreimage/cifilter/1438169-outputimage" target="_blank" rel="external">outputImage</a>属性中得到处理后的图片数据。</p>
<p>现在可以用<a href="https://developer.apple.com/reference/coreimage/ciimage/1639637-withextent" target="_blank" rel="external">imageWithExtent:processorDescription:argumentDigest:inputFormat:outputFormat:options:roiCallback:processor:</a>方法在Core Image滤镜中插入自定义的处理逻辑。这个方法添加了一个回调Block，这个Block会在处理图片数据和输出图片数据之间的一个时刻被调用。在Block里能获取到像素数据或Metal纹理数据，你在这里可以运行自定义的图形算法。</p>
<p>在写自定义图形处理逻辑或重写滤镜内核时除了Core Image的contex的色彩空间外还能用其他的色彩空间，可以用 <a href="https://developer.apple.com/reference/coreimage/ciimage/1645898-matchedfromworkingspace" target="_blank" rel="external">imageByColorMatchingWorkingSpaceToColorSpace:</a>和<a href="https://developer.apple.com/reference/coreimage/ciimage/1645896-matchedtoworkingspace" target="_blank" rel="external">imageByColorMatchingColorSpaceToWorkingSpace:</a>方法来互相转换。</p>
<p>在Core Image框架的优化下渲染<a href="https://developer.apple.com/reference/uikit/uiimage" target="_blank" rel="external">UIImage</a>对象的效率得到大幅提升(比如用<a href="https://developer.apple.com/reference/uikit/uiimage/1624114-init" target="_blank" rel="external">initWithCIImage:</a>方法初始化)。另外UIImageView中的宽色域的支持是由它内部的Core Image对象实现的。</p>
<p>Core Image核心代码现在可以指定输出像素格式。</p>
<p>Core Image引入了5个新滤镜：</p>
<ul>
<li>CINinePartTiled</li>
<li>CINinePartStretched</li>
<li>CIHueSaturationValueGradient</li>
<li>CIEdgePreserveUpsampleFilter</li>
<li>CIClamp</li>
</ul>
<h5 id="Core-Motion"><a href="#Core-Motion" class="headerlink" title="Core Motion"></a>Core Motion</h5><p>Core Motion框架(CoreMotion.framework)引入了计步器事件，它可以实时监听手机用户的运动状态，包括跑步、暂停等。在支持这个特性的设备上可以用<a href="https://developer.apple.com/reference/coremotion/cmpedometer" target="_blank" rel="external">CMPedometer</a>APIs来注册并接受实时计步事件。</p>
<h5 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h5><p>Foundation框架(Foundation.framework)包含了下列增强：</p>
<ul>
<li>新的<a href="https://developer.apple.com/reference/foundation/nsdateinterval" target="_blank" rel="external">NSDateInterval</a>类提供了判断某个时刻是否处于指定的时间段内。</li>
<li><a href="https://developer.apple.com/reference/foundation/nslocale" target="_blank" rel="external">NSLocale</a>增加了获取本地化信息的属性</li>
<li>新的<a href="https://developer.apple.com/reference/foundation/nsmeasurement" target="_blank" rel="external">NSMeasurement</a>类能把尺寸转换成不同的单位，并在两种尺寸之间进行计算。新的<a href="https://developer.apple.com/reference/foundation/measurementformatter" target="_blank" rel="external">NSMeasurementFormatter</a>类可以把尺寸进行本地化(转换成当地惯用单位，译者注)</li>
<li>新的<a href="https://developer.apple.com/reference/foundation/unit" target="_blank" rel="external">NSUnit</a>类以其子类<a href="https://developer.apple.com/reference/foundation/nsdimension" target="_blank" rel="external">NSDimension</a>能表示特定的计量单位</li>
</ul>
<h5 id="GameKit"><a href="#GameKit" class="headerlink" title="GameKit"></a>GameKit</h5><p>GameKit框架(GameKit.framework)包含了下列改进：</p>
<ul>
<li>Game Center应用现在已经被移除。如果游戏中实现了GameKit特性，需要自定义相关的UI。例如，你的游戏支持排行榜，你可以直接从Game Center获取相关数据并用自定义的视图展示(当然，直接用<a href="https://developer.apple.com/reference/gamekit/gkgamecenterviewcontroller" target="_blank" rel="external">GKGameCenterViewController</a>对象也行)</li>
<li>新的账户类型，由<a href="https://developer.apple.com/reference/gamekit/gkcloudplayer" target="_blank" rel="external">GKCloudPlayer</a>实现，支持iCloud-only游戏账号</li>
<li>Game Center对其内部的数据持久化提供了新的解决方案。一个游戏会话(<a href="https://developer.apple.com/reference/gamekit/gkgamesession" target="_blank" rel="external">GKGameSession</a>)拥有参与这个会话的玩家列表。你需要做的是决定何时以及如何从服务端存储和遍历数据或在玩家之间传输数据。游戏会话技术非常适用于回合制比赛、实时比赛以及其他多人互动游戏上</li>
</ul>
<h5 id="GameplayKit"><a href="#GameplayKit" class="headerlink" title="GameplayKit"></a>GameplayKit</h5><p>GameplayKit框架(GameplayKit.framework)包含了下列的改进：</p>
<ul>
<li>用于增强游戏场景效果的声音合成器。以及看起来更自然的纹理和更真实的相机移动。</li>
<li>空间隔离减少了游戏数据处理复杂度，让数据搜索效率更高</li>
<li>新的Monte Carlo策略(<a href="https://developer.apple.com/reference/gameplaykit/gkmontecarlostrategist" target="_blank" rel="external">GKMonteCarloStrategist</a>)类能帮你免除对可能产生的动作进行详尽地计算</li>
<li>新的决策树API能让游戏的AI设计起来更方便(前提是你的游戏AI是通过玩家行为数据用决策树来生成的)</li>
<li><a href="https://developer.apple.com/reference/gameplaykit/gkagent3d" target="_blank" rel="external">GKAgent3D</a>和<a href="https://developer.apple.com/reference/gameplaykit/gkgraphnode3d" target="_blank" rel="external">GKGraphNode3D</a>类引入了对existing agent和path-finding的3D支持</li>
<li><a href="https://developer.apple.com/reference/gameplaykit/gkobstaclegraph" target="_blank" rel="external">GKObstacleGraph</a>有了性能更好的替代品——<a href="https://developer.apple.com/reference/gameplaykit/gkmeshgraph" target="_blank" rel="external">GKMeshGraph</a>它能生成更自然的路径</li>
<li>新的<a href="https://developer.apple.com/reference/gameplaykit/gkscene" target="_blank" rel="external">GKScene</a>、<a href="https://developer.apple.com/reference/gameplaykit/gksknodecomponent" target="_blank" rel="external">GKSKNodeComponent</a>和SpriteKit以及Xcode editor的结合让集成GameplayKit、SpriteKit变得前所未有地简单</li>
</ul>
<h5 id="HealthKit"><a href="#HealthKit" class="headerlink" title="HealthKit"></a>HealthKit</h5><p>HealthKit框架(HealthKit.framework)包含了下列改进：</p>
<ul>
<li>新的<a href="https://developer.apple.com/reference/healthkit/hkcdadocument" target="_blank" rel="external">HKCDADocument</a>类，代表CDA文件(遵循Clinical Document Architecture标准的文件)</li>
<li>新的<a href="https://developer.apple.com/reference/healthkit/hkworkoutconfiguration" target="_blank" rel="external">HKWorkoutConfiguration</a>类，能让你为一项锻炼指定<a href="https://developer.apple.com/reference/healthkit/hkworkoutconfiguration/1649492-activitytype" target="_blank" rel="external">activityType</a>和<a href="https://developer.apple.com/reference/healthkit/hkworkoutconfiguration/1649491-locationtype" target="_blank" rel="external">locationType</a></li>
<li>新的<a href="https://developer.apple.com/reference/healthkit/hkwheelchairuseobject" target="_blank" rel="external">HKWheelchairUseObject</a>特征对象类型和<a href="https://developer.apple.com/reference/healthkit/hkhealthstore" target="_blank" rel="external">HKHealthStore</a>相关的方法<a href="https://developer.apple.com/reference/healthkit/hkhealthstore/1648356-wheelchairuse" target="_blank" rel="external">wheelchairUseWithError:</a></li>
<li>新的代表天气的元数据key，比如<a href="https://developer.apple.com/reference/healthkit/hkweathercondition/hkweatherconditionclear" target="_blank" rel="external">HKWeatherConditionClear</a>和<a href="https://developer.apple.com/reference/healthkit/hkweathercondition/hkweatherconditioncloudy" target="_blank" rel="external">HKWeatherConditionCloudy</a>。还有锻炼类的，比如<a href="https://developer.apple.com/reference/healthkit/hkworkoutactivitytype/1649808-flexibility" target="_blank" rel="external">HKWorkoutActivityTypeFlexibility</a>和<a href="https://developer.apple.com/reference/healthkit/hkworkoutactivitytype/hkworkoutactivitytypewheelchairrunpace" target="_blank" rel="external">HKWorkoutActivityTypeWheelchairRunPace</a></li>
</ul>
<h5 id="HomeKit"><a href="#HomeKit" class="headerlink" title="HomeKit"></a>HomeKit</h5><p>iOS10以后，iPad可以变成家庭控制中心，允许进行远程访问，运行自动任务触发器以及共享用户授权。另外HomeKit框架(HomeKit.framework)添加了对摄像机和门铃的支持，并引入了很多新API：</p>
<ul>
<li>调用并控制网络摄像机，显示实时视频流和截图以及控制摄像机、扬声器和话筒</li>
<li>Access new services and characteristics</li>
<li>For the primary service, link services and valid values to provide more context and configuration about the accessories</li>
</ul>
<p>现在可以用Apple家居设备设置流程来添加或者设置家居设备。想要了解更多可以看<a href="https://developer.apple.com/reference/homekit" target="_blank" rel="external">HomeKit Framework Reference</a></p>
<h5 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a>Metal</h5><p>iOS10以后Metal引入了一些新特性并对某些方面进行了增强，比如：</p>
<ul>
<li>支持tessellation。允许3D游戏和应用进行更细致地渲染</li>
<li>函数专精化。这样就能开发出高度优化的函数来处理材质和光照</li>
<li>资源堆和更小内存的渲染目标。在未来会对资源分配进行更细粒度的控制来优化性能</li>
</ul>
<h5 id="ModelIO"><a href="#ModelIO" class="headerlink" title="ModelIO"></a>ModelIO</h5><p>ModelIO框架(ModelIO.framework)包含了下列改进：</p>
<ul>
<li>支持USD格式</li>
<li>新的<code>MDLMaterialPropertyGraph</code>类让运行时修改models更容易</li>
<li><a href="https://developer.apple.com/reference/modelio/mdlvoxelarray" target="_blank" rel="external">MDLVoxelArray</a>类现在支持signed distance fields</li>
<li>可以实现<code>MDLLightProbeIrradianceDataSource</code>协议来添加assisted light probe</li>
</ul>
<h5 id="Photos"><a href="#Photos" class="headerlink" title="Photos"></a>Photos</h5><p>Photos框架(Photos.framework)现在支持对Live Photo进行编辑了。特别是新<a href="https://developer.apple.com/reference/photos/phlivephotoeditingcontext" target="_blank" rel="external">PHLivePhotoEditingContext</a>类允许你编辑视频和Live Photo中的静态内容。Core Image的性能增强在这里也得以体现，想要了解更多请看<a href="https://developer.apple.com/reference/coreimage/ciimageprocessorinput" target="_blank" rel="external">CIImageProcessorInput</a>和<a href="https://developer.apple.com/reference/coreimage/ciimageprocessoroutput" target="_blank" rel="external">CIImageProcessorOutput</a>。</p>
<h5 id="ReplayKit"><a href="#ReplayKit" class="headerlink" title="ReplayKit"></a>ReplayKit</h5><p>ReplayKit框架(ReplayKit.framework)包含了下列增强：</p>
<ul>
<li>ReplayKit支持广播服务，用户可以通过第三方广播自己的屏幕内容。使用下面这些API就能够集成这个新特性 <a href="https://developer.apple.com/reference/replaykit/rpscreenrecorder" target="_blank" rel="external">RPScreenRecorder</a>、<a href="https://developer.apple.com/reference/replaykit/rpbroadcastactivityviewcontroller" target="_blank" rel="external">RPBroadcastActivityViewController</a>、<a href="https://developer.apple.com/reference/replaykit/rpbroadcastcontroller" target="_blank" rel="external">RPBroadcastController</a></li>
<li>若要参与ReplayKit广播，第三方广播服务商需要实现相应的应用扩展。这个扩展应该具有让用户接入并配置广播的功能</li>
</ul>
<h5 id="SceneKit"><a href="#SceneKit" class="headerlink" title="SceneKit"></a>SceneKit</h5><p>The SceneKit framework (SceneKit.framework) includes several enhancements.</p>
<p>A new Physically Based Rendering (PBR) system allows you to leverage the latest in 3D graphics research to create more realistic results with simpler asset authoring. Specifically:</p>
<ul>
<li><p>Use the new <a href="https://developer.apple.com/reference/scenekit/scnmaterial.lightingmodel/1640553-physicallybased" target="_blank" rel="external">SCNLightingModelPhysicallyBased</a> shading model to opt into PBR shading for materials. PBR materials require only three fundamental properties—<a href="https://developer.apple.com/reference/scenekit/scnmaterial/1462589-diffuse" target="_blank" rel="external">diffuse</a>, <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1640554-metalness" target="_blank" rel="external">metalness</a>, and <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1640555-roughness" target="_blank" rel="external">roughness</a>—to produce a wide range of realistic shading effects. (The <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1462542-normal" target="_blank" rel="external">normal</a>, <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1462579-ambientocclusion" target="_blank" rel="external">ambientOcclusion</a>, and selfIllumination material properties also remain useful for PBR materials, but you can now ignore the large number of other properties used for traditional materials.)</p>
</li>
<li><p>PBR shading works best with environment-based lighting, which causes even diffuse surfaces to pick up the colors of the scene around them. Use the <a href="https://developer.apple.com/reference/scenekit/scnscene/1639532-lightingenvironment" target="_blank" rel="external">lightingEnvironment</a> property to assign global image-based lighting to an entire scene, and place light probes in the Xcode scene editor to pick up the local lighting contributions from objects within your scene.<br>Authors of PBR scene content often prefer working in physically based terms, so you can now define lighting using intensity (in lumens) and color temperature (in degrees Kelvin), and import specifications for real-world light fixtures using the IESProfileURL property.</p>
</li>
</ul>
<p>Add even more realism with the new HDR features and effects in the <a href="https://developer.apple.com/reference/scenekit/scncamera" target="_blank" rel="external">SCNCamera</a> class. With HDR rendering, SceneKit captures a much wider range of brightness and contrast in a scene, then allows you to customize the tone mapping that adapts that scene for the narrower range of a device’s display. Enable exposure adaptation to create automatic effects when, for example, the player in your game moves from a darkened area into sunlight. Or use vignetting, color fringing, and color grading to add a filmic look to your game.</p>
<p>Although linear, more color-accurate rendering is the basis for PBR shading and HDR camera features, it produces better results even for traditional rendering. By default, SceneKit now performs all color calculations in a linear (not gamma-adjusted) color space, and uses the P3 color gamut of devices that include wide-color displays. This feature is enabled automatically for all apps linking against the iOS 10 SDK, and has a few ramifications for content design and asset management:</p>
<ul>
<li>SceneKit color matches all colors. In previous versions, SceneKit would read only the color values from material colors specified as <a href="https://developer.apple.com/reference/appkit/nscolor" target="_blank" rel="external">NSColor</a> or <a href="https://developer.apple.com/reference/uikit/uicolor" target="_blank" rel="external">UIColor</a> objects, ignoring color profile information and assuming the sRGB color space.</li>
<li>SceneKit interprets color component values specified within shader modifier or custom Metal or OpenGL shader code in linear RGB space.</li>
<li>SceneKit reads and adjusts for color profile information in texture images. Design textures for a linear brightness ramp, and use Asset Catalogs in Xcode to make sure your images use the correct color profile.</li>
<li>If necessary, you can disable linear space rendering with the <code>SCNDisableLinearSpaceRendering</code> key in your app’s Info.plist file, and wide color rendering with the <code>SCNDisableWideGamut</code> key.<br>Geometry can now be loaded from scene files or programmatically defined using arbitrary polygon primitives (<a href="https://developer.apple.com/reference/scenekit/scngeometryprimitivetype/scngeometryprimitivetypepolygon" target="_blank" rel="external">SCNGeometryPrimitiveTypePolygon</a>). SceneKit automatically triangulates polygon meshes for rendering, but makes use of the underlying polygon mesh for more accurate surface subdivision (to learn more, see the <a href="https://developer.apple.com/reference/scenekit/scngeometry/1524177-subdivisionlevel" target="_blank" rel="external">subdivisionLevel</a> property).</li>
</ul>
<h5 id="SpriteKit"><a href="#SpriteKit" class="headerlink" title="SpriteKit"></a>SpriteKit</h5><p>The SpriteKit framework (SpriteKit.framework) includes the following enhancements:</p>
<ul>
<li>A new tilemap solution supports square, hexagonal, and isometric tilemaps that make it easy to create 2D, 2.5D, and side-scroller games. The Xcode editor provides comprehensive support for organizing your tiles and creating your tilemap. For more information, see the <code>SKTileMapNode</code>, <code>SKTileGroup</code>, <code>SKTileGroupRule</code>, and <code>SKTileSet</code> classes .</li>
<li>The new <code>SKWarpGeometry</code> class is used to stretch or distort how a <a href="https://developer.apple.com/reference/spritekit/skspritenode" target="_blank" rel="external">SKSpriteNode</a> or <a href="https://developer.apple.com/reference/spritekit/skeffectnode" target="_blank" rel="external">SKEffectNode</a> object is rendered. The warp is specified by a set of control points. New <a href="https://developer.apple.com/reference/spritekit/skaction" target="_blank" rel="external">SKAction</a> types can be used to animate between different warp effects.</li>
<li>A custom shader can use attributes that can be configured separately by each node that uses the shader. To add an attribute, create an <code>SKAttribute</code> object and attach it to your shader. Then, for each node that uses that shader, attach an <code>SKAttributeValue</code> object.]</li>
<li>The <a href="https://developer.apple.com/reference/spritekit/skview" target="_blank" rel="external">SKView</a> class defines new methods that give you finer control over when and how your scene is rendered.</li>
</ul>
<h5 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h5><p>UIKit框架(UIKit.framework)包含了大量的改进，包括：</p>
<ul>
<li>新的基于对象互动式动画系统，可以很方便的持有它，并和用户手势进行交互。想要了解更多请看<a href="https://developer.apple.com/reference/uikit/uiviewanimating" target="_blank" rel="external">UIViewAnimating Protocol Reference</a>、<a href="https://developer.apple.com/reference/uikit/uiviewpropertyanimator" target="_blank" rel="external">UIViewPropertyAnimator Class Reference</a>、<a href="https://developer.apple.com/reference/uikit/uitimingcurveprovider" target="_blank" rel="external">UITimingCurveProvider Protocol Reference</a>、<a href="https://developer.apple.com/reference/uikit/uicubictimingparameters" target="_blank" rel="external">UICubicTimingParameters Class Reference</a>、 <a href="https://developer.apple.com/reference/uikit/uispringtimingparameters" target="_blank" rel="external">UISpringTimingParameters Class Reference</a></li>
<li>新的<a href="https://developer.apple.com/reference/uikit/uipreviewinteraction" target="_blank" rel="external">UIPreviewInteraction</a>类和 <a href="https://developer.apple.com/reference/uikit/uipreviewinteractiondelegate" target="_blank" rel="external">UIPreviewInteractionDelegate</a>协议可以为peek和pop操作提供自定义界面</li>
<li><code>UIAccessibilityCustomRotor</code>以及相关的类可以让应用更好地集成辅助性技术，类似于向VoiceOver提供朗读内容。你可以创建自定义的rotor，返回拼写错误的单词的位置来让用户得知文档中的拼写错误</li>
<li><code>UIAccessibilityIsAssistiveTouchRunning</code>和<code>UIAccessibilityAssistiveTouchStatusDidChangeNotification</code>可以在AssistiveTouch激活的时候通知你。<code>UIAccessibilityHearingDevicePairedEar</code>和<code>UIAccessibilityHearingDevicePairedEarDidChangeNotification</code>能让你得知MFi助听器的配对状态</li>
<li>新的<a href="https://developer.apple.com/reference/uikit/uipasteboard" target="_blank" rel="external">UIPasteboard</a>提供了对大部分类实例兼容类型的声明，以及提供了对剪贴板内对象的生命周期进行限制的选项</li>
<li><a href="https://developer.apple.com/reference/uikit/uipasteboard" target="_blank" rel="external">UIPasteboard</a>的新选项</li>
<li><a href="https://developer.apple.com/reference/uikit/uifont" target="_blank" rel="external">UIFont</a>的<code>preferredFontForTextStyle:compatibleWithTraitCollection:</code>方法提供了对labels、text fields和其他文本控件的动态字体支持</li>
<li>当设备的<code>UIContentSizeCategory</code>改变时<code>UIContentSizeCategoryAdjusting</code>协议提供了<code>adjustsFontForContentSizeCategory</code>属性来帮你更新相关的字体</li>
<li>对tab bar item的badge外观的更多控制，诸如背景颜色和text attributes</li>
<li>所有的scrol view及其子类都支持refresh control了</li>
<li><a href="https://developer.apple.com/reference/uikit/uiapplication" target="_blank" rel="external">UIApplication</a>的新方法<code>openURL:options:completionHandler:</code>为异步执行，并在主线程执行回调(这个方法将来要取代<a href="https://developer.apple.com/reference/uikit/uiapplication/1622961-openurl" target="_blank" rel="external">openURL:</a>)</li>
<li>新的<code>UICloudSharingController</code>类和<code>UICloudSharingControllerDelegate</code>协议可以初始化Cloudkit分享操作，并向用户展示一个相关配置选项的界面</li>
<li>增强了<a href="https://developer.apple.com/reference/uikit/uicollectionview" target="_blank" rel="external">UICollectionView</a>以及新增了<a href="https://developer.apple.com/reference/uikit/uicollectionviewdatasourceprefetching" target="_blank" rel="external">UICollectionViewDataSourcePrefetching</a>协议，通过提前获取cell的方式增强了滑动体验</li>
</ul>
<h5 id="WebKit"><a href="#WebKit" class="headerlink" title="WebKit"></a>WebKit</h5><p>WebKit框架(WebKit.framework)的<a href="https://developer.apple.com/reference/webkit/wkwebview" target="_blank" rel="external">WKWebView</a>增强了peek和pop操作。在iOS10上用户可以使用<a href="https://developer.apple.com/reference/webkit/wkuidelegate/1648359-webview" target="_blank" rel="external">webView:shouldPreviewElement:</a>方法来决定是否在指定的链接上显示预览页面。</p>
<h3 id="Deprecated-APIs"><a href="#Deprecated-APIs" class="headerlink" title="Deprecated APIs"></a>Deprecated APIs</h3><p>iOS10把下列的APIs标记为废弃：</p>
<ul>
<li><a href="https://developer.apple.com/reference/cloudkit/ckdiscoverallcontactsoperation" target="_blank" rel="external">CloudKit CKDiscoverAllContactsOperation</a>、<a href="https://developer.apple.com/reference/cloudkit/ckdiscovereduserinfo" target="_blank" rel="external">CKDiscoveredUserInfo</a>、<a href="https://developer.apple.com/reference/cloudkit/ckdiscoveruserinfosoperation" target="_blank" rel="external">CKDiscoverUserInfosOperation</a>, <a href="https://developer.apple.com/reference/cloudkit/ckfetchrecordchangesoperation" target="_blank" rel="external">CKFetchRecordChangesOperation</a>。作为替代可以使用 <a href="https://developer.apple.com/reference/cloudkit/ckdiscoveralluseridentitiesoperation" target="_blank" rel="external">CKDiscoverAllUserIdentitiesOperation</a>、<a href="https://developer.apple.com/reference/cloudkit/ckuseridentity" target="_blank" rel="external">CKUserIdentity</a>、<a href="https://developer.apple.com/reference/cloudkit/ckdiscoveruseridentitiesoperation" target="_blank" rel="external">CKDiscoverUserIdentitiesOperation</a>和 <a href="https://developer.apple.com/reference/cloudkit/ckfetchrecordzonechangesoperation" target="_blank" rel="external">CKFetchRecordZoneChangesOperation</a>。<br>多个<a href="https://developer.apple.com/reference/cloudkit/cksubscription" target="_blank" rel="external">CKSubscription</a>的APIs，比如zone-based subscriptions相关的方法和属性(用<code>CKRecordZoneSubscription</code>替代)</li>
<li><a href="NSPersistentStoreCoordinator">NSPersistentStoreCoordinator</a>相关的常量</li>
<li><a href="https://developer.apple.com/reference/uikit/uiviewcontroller" target="_blank" rel="external">UIViewController</a>中的<a href="https://developer.apple.com/reference/iad/adbannerview" target="_blank" rel="external">ADBannerView</a>和<a href="https://developer.apple.com/reference/iad/adinterstitialad" target="_blank" rel="external">ADInterstitialAd</a>类以及相关常量</li>
<li><a href="https://developer.apple.com/reference/spritekit/skuniform" target="_blank" rel="external">SKUniform</a>相关的浮点常量。可以在适当的情况下用<code>initWithName:vectorFloat2:</code>和<code>uniformWithName:matrixFloat2x2:</code>作为替代</li>
<li>UIkit相关的通知，诸如<a href="https://developer.apple.com/reference/uikit/uilocalnotification" target="_blank" rel="external">UILocalNotification</a>、<a href="https://developer.apple.com/reference/uikit/uimutableusernotificationaction" target="_blank" rel="external">UIMutableUserNotificationAction</a>、<a href="https://developer.apple.com/reference/uikit/uimutableusernotificationcategory" target="_blank" rel="external">UIMutableUserNotificationCategory</a>、<a href="https://developer.apple.com/reference/uikit/uiusernotificationaction" target="_blank" rel="external">UIUserNotificationAction</a>、<a href="https://developer.apple.com/reference/uikit/uiusernotificationcategory" target="_blank" rel="external">UIUserNotificationCategory</a>和<a href="https://developer.apple.com/reference/uikit/uiusernotificationsettings" target="_blank" rel="external">UIUserNotificationSettings</a>。请使用User Notifications框架作为替代(<a href="https://developer.apple.com/reference/usernotifications" target="_blank" rel="external">Notifications Framework Reference</a>)</li>
<li><a href="https://developer.apple.com/reference/watchkit/wkinterfacecontroller/1619516-handleactionwithidentifier" target="_blank" rel="external">handleActionWithIdentifier:forLocalNotification:</a>、<a href="https://developer.apple.com/reference/watchkit/wkinterfacecontroller/1619530-handleactionwithidentifier" target="_blank" rel="external">handleActionWithIdentifier:forRemoteNotification:</a>、<a href="https://developer.apple.com/reference/watchkit/wkusernotificationinterfacecontroller/1619534-didreceivelocalnotification" target="_blank" rel="external">didReceiveLocalNotification:withCompletion:</a>和 <a href="https://developer.apple.com/reference/watchkit/wkusernotificationinterfacecontroller/1619568-didreceiveremotenotification" target="_blank" rel="external">didReceiveRemoteNotification:withCompletion:</a>等方法。请使用<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate/1628138-handleactionwithidentifier" target="_blank" rel="external">handleActionWithIdentifier:forNotification:</a>和<a href="https://developer.apple.com/reference/watchkit/wkusernotificationinterfacecontroller/1648287-didreceive" target="_blank" rel="external">didReceiveNotification:withCompletion:</a>作为替代。<br>同样还有<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate" target="_blank" rel="external">WKExtensionDelegate</a>的通知处理方法，诸如<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate/1628170-didreceiveremotenotification" target="_blank" rel="external">didReceiveRemoteNotification:</a>和<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate/1628138-handleactionwithidentifier" target="_blank" rel="external">handleActionWithIdentifier:forRemoteNotification:</a>作为使用上述方法的替代方案，首先实例化一个遵循<a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenterdelegate" target="_blank" rel="external">UNUserNotificationCenterDelegate</a>协议的托对象并实现适当的方法，然后把这个实例对象赋值给<a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenter" target="_blank" rel="external">UNUserNotificationCenter</a>单例的<a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenter/1649522-delegate" target="_blank" rel="external">delegate</a>属性</li>
</ul>
<p>完整的API废弃列表请看<a href="https://developer.apple.com/library/content/releasenotes/General/iOS10APIDiffs/index.html" target="_blank" rel="external">iOS 10.0 API Diffs</a>。</p>
</div><div class="tags"></div><div class="post-nav"><a href="/2017/02/06/HTTP权威指南/" class="pre">《HTTP权威指南》笔记</a><a href="/2016/09/13/cell-height-calc-with-autolayout/" class="next">项目中Cell自动计算行高的实践</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CS基础/">CS基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS开发/">iOS开发</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/02/20/iOS平台Webview和原生代码交互/">iOS平台Webview和原生代码交互</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/06/HTTP权威指南/">《HTTP权威指南》笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/16/What's-New-in-iOS10/">What's New in iOS</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/13/cell-height-calc-with-autolayout/">项目中Cell自动计算行高的实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/28/iOS-worst-practice/">iOS worst practice</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/25/Autolayout-自定义View/">Autolayout笔记:自定义View</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/18/AutoLayout-基础概念/">Autolayout笔记:基本概念</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Ney的技术博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>