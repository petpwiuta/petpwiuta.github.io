<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ney的技术博客</title>
  
  <subtitle>Learning，sharing，improving</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://petpwiuta.github.io/"/>
  <updated>2019-04-01T02:46:11.687Z</updated>
  <id>http://petpwiuta.github.io/</id>
  
  <author>
    <name>Ney</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UIStackView</title>
    <link href="http://petpwiuta.github.io/2019/03/30/UIStackView/"/>
    <id>http://petpwiuta.github.io/2019/03/30/UIStackView/</id>
    <published>2019-03-30T06:06:02.347Z</published>
    <updated>2019-04-01T02:46:11.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h1><p>UIStackview是一个流式布局的工具。贼好用😝😝</p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>UIStackView可以说是Auto Layout最强有力的助手，通过它能大幅简化多个view规律性的布局逻辑。stack view所管理的view都在它的 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616232-arrangedsubviews" target="_blank" rel="external"><code>arrangedSubviews</code></a> 属性里。stack view会把这些view根据其在数组中的先后顺序沿着横向/纵向（取决于<a href="https://developer.apple.com/documentation/uikit/uistackview/1616223-axis" target="_blank" rel="external"><code>axis</code></a>属性）排列，然当具体的排列效果还和 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616233-distribution" target="_blank" rel="external"><code>distribution</code></a>, <a href="https://developer.apple.com/documentation/uikit/uistackview/1616243-alignment" target="_blank" rel="external"><code>alignment</code></a>, <a href="https://developer.apple.com/documentation/uikit/uistackview/1616225-spacing" target="_blank" rel="external"><code>spacing</code></a>, 等属性有关。</p><p><img src="/images/stackview.png" style="zoom:40%"></p><p>在Storyboard中使用stack view很简单，打开控件库，选择Horizontal Stack View 或 Vertical Stack View拖到view上，再拖一些其他控件到stack view里面就行了。如果约束足够明确的话Interface Builder会根据你的内容自动调整stack view的大小。另外还有一个快速使用stack view的小技巧，就是选中一组控件以后点击Interface Builder右下角的 <strong>Embed In</strong> <img src="/images/embedin.png" style="zoom:20%"> 按钮选择stack view就能快速用stack view把选中的控件wrap起来。</p><h3 id="Stack-View-和-Auto-Layout"><a href="#Stack-View-和-Auto-Layout" class="headerlink" title="Stack View 和 Auto Layout"></a>Stack View 和 Auto Layout</h3><p>stack view通过自动布局来确定所管理的view的大小和位置。<code>axis</code>决定了stack view是水平排列还是垂直排列。如果设置 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616220-islayoutmarginsrelativearrangeme" target="_blank" rel="external"><code>isLayoutMarginsRelativeArrangement</code></a> 属性为 <code>true</code> ，stack view会基于margin来决定view之间位置（不设置的话就是基于视图的边缘来计算）。</p><p><code>distribution</code>属性用来设置沿着axis方向的各个view的排列方式。当axis是<code>UILayoutConstraintAxisHorizontal</code>就是设置水平方向各个view的排列关系，当axis是<code>UILayoutConstraintAxisVertical</code>就是设置垂直方向各个view的排列关系。</p><p>stack view对子view进行排列时，会依次调用view的<a href="https://developer.apple.com/documentation/uikit/uiview/1622600-intrinsiccontentsize" target="_blank" rel="external"><code>intrinsicContentSize</code></a>属性来确定其大小。有一个例外，就是distribution设置成<a href="https://developer.apple.com/documentation/uikit/uistackview/distribution/fillequally" target="_blank" rel="external"><code>UIStackView.Distribution.fillEqually</code></a>时，此时stack view会尽量把所有的view拉伸成同样的长度，均匀地填充整个容器。stack view在拉伸时会尝试把其他的view拉得和最长的那个一样长。</p><p><code>alignment</code>属性用来设置垂直于axis方向的各个view的对齐方式。当axis是<code>UILayoutConstraintAxisHorizontal</code>就是设置垂直方向各个view的对齐关系，当axis是<code>UILayoutConstraintAxisVertical</code>就是设置水平方向各个view的对齐关系。</p><p>stack view对子view进行对齐时，也会依次调用view的<a href="https://developer.apple.com/documentation/uikit/uiview/1622600-intrinsiccontentsize" target="_blank" rel="external"><code>intrinsicContentSize</code></a>属性来确定其大小。当然也有一个例外，就是alignment设置为<a href="https://developer.apple.com/documentation/uikit/uistackview/alignment/fill" target="_blank" rel="external"><code>UIStackView.Alignment.fill</code></a> 时，此时stack view会尽量把所有的view拉伸成同样的高度，均匀地填充整个容器。stack view在拉伸时会尝试把其他的view拉得和最高的那个一样高。</p><h3 id="Stack-View的位置和大小"><a href="#Stack-View的位置和大小" class="headerlink" title="Stack View的位置和大小"></a>Stack View的位置和大小</h3><p>stack view可以根据所管理的view推导出自己的大小，但是它无法确定自己的位置。所需要明确地写出位置约束。只要指定两个的相邻边的位置stack view就能确定其自身的位置。与此同时stack view也会根据内容来自动调整自己的宽度和高度：</p><ul><li>沿着axis方向的宽度等于其管理的所有view的尺寸加上view之间的间距</li><li>垂直于axis方向的高度等于所管理的view中最高的那个</li><li>如果stack view的 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616220-islayoutmarginsrelativearrangeme" target="_blank" rel="external"><code>isLayoutMarginsRelativeArrangement</code></a> 属性设置为 <code>true</code>, stack view的尺寸会包含margins的大小</li></ul><p>当然，上面的这些都是默认的行为，如果不能满足要求还能直接给stack view加高度或宽度的约束。stack view会根据 <a href="https://developer.apple.com/documentation/uikit/uistackview/distribution" target="_blank" rel="external"><code>UIStackView.Distribution</code></a> 和 <a href="https://developer.apple.com/documentation/uikit/uistackview/alignment" target="_blank" rel="external"><code>UIStackView.Alignment</code></a> 等设置来调整子view的排列和对齐来满足约束条件。 </p><p>虽然stack view仅仅只是一个布局容器，但是它也支持基于first/last baseline的布局：</p><ul><li>horizontal方向的stack view <a href="https://developer.apple.com/documentation/uikit/uiview/1622452-forfirstbaselinelayout" target="_blank" rel="external"><code>forFirstBaselineLayout</code></a>和 <a href="https://developer.apple.com/documentation/uikit/uiview/1622633-forlastbaselinelayout" target="_blank" rel="external"><code>forLastBaselineLayout</code></a> 会返回所管理的view中最高的那个对应的属性。 如果最高的那个也是stack view的话会进行递归调用，直到返回正常结果</li><li>vertical方向的stack view <code>forFirstBaselineLayout</code>会返回所管理的第一个子view，<code>forLastBaselineLayout</code>会返回最后一个。同样的如果第一个/最后一个还是stack view的话也会递归式调用</li></ul><blockquote><p>注意</p><p>Baseline alignment 仅仅只能在view的frame高度等于自己的intrinsic.height时才能正常工作，换句话说就是view如果被压缩或拉伸的话baseline alignment可能就会有bug</p></blockquote><h3 id="Stack-View的常用属性"><a href="#Stack-View的常用属性" class="headerlink" title="Stack View的常用属性"></a>Stack View的常用属性</h3><p>stack view虽然是view的子类，它只负责管理其排列视图的位置和大小，本身不会被渲染出来。所以一些外观相关的属性（如<a href="https://developer.apple.com/documentation/uikit/uiview/1622591-backgroundcolor" target="_blank" rel="external"><code>backgroundColor</code></a>）对它没有效果，也不能重载 <a href="https://developer.apple.com/documentation/uikit/uiview/1622626-layerclass" target="_blank" rel="external"><code>layerClass</code></a>, <a href="https://developer.apple.com/documentation/uikit/uiview/1622529-draw" target="_blank" rel="external"><code>draw(_:)</code></a>等方法。</p><ul><li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616223-axis" target="_blank" rel="external"><code>axis</code></a> 确定了stack的方向，选项是vertically/horizontally.</li><li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616233-distribution" target="_blank" rel="external"><code>distribution</code></a> 用来设置沿着axis方向的各个view的排列方式</li><li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616243-alignment" target="_blank" rel="external"><code>alignment</code></a> 用来设置垂直与axis方向的各个view的对齐方式</li><li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616225-spacing" target="_blank" rel="external"><code>spacing</code></a> view之间的最小间距</li><li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616224-isbaselinerelativearrangement" target="_blank" rel="external"><code>isBaselineRelativeArrangement</code></a> 当axis设置为垂直方向时才有用。垂直方向的view是否用基于baseline排列，这个属性在排列一些文本控件时很管用</li><li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616220-islayoutmarginsrelativearrangeme" target="_blank" rel="external"><code>isLayoutMarginsRelativeArrangement</code></a> 是否基于margin进行排列</li></ul><h3 id="Stack-View的Arranged-Views和Subviews"><a href="#Stack-View的Arranged-Views和Subviews" class="headerlink" title="Stack View的Arranged Views和Subviews"></a>Stack View的Arranged Views和Subviews</h3><p>stack view保证 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616232-arrangedsubviews" target="_blank" rel="external"><code>arrangedSubviews</code></a> 属性一直是其 <a href="https://developer.apple.com/documentation/uikit/uiview/1622614-subviews" target="_blank" rel="external"><code>subviews</code></a> 的子集. 具体规则如下:</p><ul><li><p>当stack view添加view到<code>arrangedSubviews</code> 时, 它也会把view添加到自己的subviews数组里面（如果已经添加过就不重复添加）</p></li><li><p>当一个view从stack view的subview中移除时，它也会从 <code>arrangedSubviews</code> 中移除</p></li><li><p>当一个view从stack view的 <code>arrangedSubviews</code> 中移除时，这个view<font color="red"> <strong>并不会</strong></font>从stack view的<code>arrangedSubviews</code>中移除</p></li></ul><p>  虽然<code>arrangedSubviews</code>属性一直是其<code>subviews</code>的子集，但这两个数组内的元素顺序并不一定是一致的。</p><ul><li><code>arrangedSubviews</code>中的顺序决定了view在容器中出现的顺序。在水平方向的stack view中，view是沿着阅读方向（绝大部分语言是从左到右，阿拉伯语是从右到左。不过这个不取决于系统语言设置，取决于布局是用left/right还是leading/trailing）排列的。index小的在前，index大的在后</li><li>而<code>subviews</code> 中的顺序决定子view的Z-order。Z-order高的会把低的view盖住</li></ul><h3 id="Stack-View-动态内容"><a href="#Stack-View-动态内容" class="headerlink" title="Stack View 动态内容"></a>Stack View 动态内容</h3><p>当对stack view<a href="https://developer.apple.com/documentation/uikit/uistackview/1616232-arrangedsubviews" target="_blank" rel="external"><code>arrangedSubviews</code></a> 进行添加/插入/删除，以及对它所管理的子view的属性进行修改时，stack view的内容会自动更新。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Appears to remove the first arranged view from the stack.</span></div><div class="line"><span class="comment">// The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout.</span></div><div class="line"><span class="keyword">let</span> firstView = stackView.arrangedSubviews[<span class="number">0</span>]</div><div class="line">firstView.isHidden = <span class="literal">true</span></div></pre></td></tr></table></figure><p>同样的，如果修改stack view的属性，它的内容也会根据属性的变化而动态地调整。比如设置<a href="https://developer.apple.com/documentation/uikit/uistackview/1616223-axis" target="_blank" rel="external"><code>axis</code></a>动态地改变stack view的方向。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Toggle between a vertical and horizontal stack</span></div><div class="line"><span class="keyword">if</span> stackView.axis == .<span class="type">Horizontal</span> &#123;</div><div class="line">    stackView.axis = .<span class="type">Vertical</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    stackView.axis = .<span class="type">Horizontal</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>也可以在动画block里面调整子view的属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Animates removing the first item in the stack.</span></div><div class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.25</span>) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">let</span> firstView = stackView.arrangedSubviews[<span class="number">0</span>]</div><div class="line">    firstView.isHidden = <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      UIStackView 官方文档翻译
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>pod install 特别慢的终极解决方案😋</title>
    <link href="http://petpwiuta.github.io/2019/03/27/pod%20install%20%E7%89%B9%E5%88%AB%E6%85%A2%E7%9A%84%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://petpwiuta.github.io/2019/03/27/pod install 特别慢的终极解决方案/</id>
    <published>2019-03-27T12:31:04.370Z</published>
    <updated>2019-04-03T02:50:44.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pod-install-特别慢的终极解决方案😋"><a href="#pod-install-特别慢的终极解决方案😋" class="headerlink" title="pod install 特别慢的终极解决方案😋"></a>pod install 特别慢的终极解决方案😋</h2><p><strong>pod install 在终端更新慢</strong> 其实真正慢的并不在 <strong>pod</strong> 命令，而是在于 <strong>github</strong>访问速度慢，那么真正的解决方案就是要加快 <strong>git</strong>命令的速度。当然，加速<strong>git</strong>的方法就是开代理。</p><p>我使用的 <strong>shadowsocks代理</strong>，默认代理端口为<strong>1080</strong>，打开小飞机，配置好代理之后，去终端输入<strong>git</strong>配置命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1086</div><div class="line">#socks5://127.0.0.1:1086 1086端口号是shadowsocks的默认设置，实际以自己的机器为准</div></pre></td></tr></table></figure><p>如此就从根本上解决了问题。<strong>代理前 10k/s ☹️ 代理后 600k/s</strong> 😍</p><p>如果要恢复/移除上面设置的 <strong>git</strong>代理，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global --unset http.https://github.com.proxy</div></pre></td></tr></table></figure><h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><ul><li><a href="https://blog.csdn.net/wuquan0625/article/details/47401235" target="_blank" rel="external">https://blog.csdn.net/wuquan0625/article/details/47401235</a></li></ul>]]></content>
    
    <summary type="html">
    
      用git内置的proxy提高github访问速度
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Jenkins进行iOS项目自动化发布</title>
    <link href="http://petpwiuta.github.io/2019/01/14/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8CiOS%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B8%83/"/>
    <id>http://petpwiuta.github.io/2019/01/14/使用Jenkins进行iOS项目自动化发布/</id>
    <published>2019-01-14T13:02:38.218Z</published>
    <updated>2019-01-16T02:11:04.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用Jenkins进行iOS项目自动化发布"><a href="#使用Jenkins进行iOS项目自动化发布" class="headerlink" title="使用Jenkins进行iOS项目自动化发布"></a>使用Jenkins进行iOS项目自动化发布</h3><p>前段时间把iOS发布逻辑迁移到fastlane平台，现在发布调一下fastlane脚本就好，对开发人员极度友好。不过后来发现虽然开发人员用得爽了，不过还是要被测试妹子催着打包，于是想釜底抽薪，把这个功能做得更彻底一点，直接让测试妹子自己来打包，这样就把iOS开发同学彻底解放了～</p><p>公司内网已经部署了一台linux系统的jenkins服务器，上面集成了一些后端和前端的发布逻辑，所以直接添加一个iOS项目的发布流程就行。Xcode环境只能跑在Mac OS上，所以iOS项目的发布流程势必要做远程服务。</p><p>在调研的时候打算在Mac OS上启一个http server，自己写相关的逻辑。后来发现jenkins有远程job互调用的功能，所以方案就变成在Mac OS上也部署一套jenkins，暴露出一些打包服务，然后在公司的jenkins中调用。因为有两套jenkins环境的配置（提供服务的和使用服务的），姑且称之为调用端和执行端。下面就来简单说一下这两部分的具体配置。</p><h4 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h4><p><img src="/images/jenkins-ios/c-1.png" alt="c-1"></p><h4 id="执行端"><a href="#执行端" class="headerlink" title="执行端"></a>执行端</h4><p>执行端主要就是提供一个http服务，用http协议来触发构建任务。下面是具体步骤：</p><ol><li>在jenkins中新建一个任务，这里选“自由风格的软件项目”</li></ol><p><img src="/images/jenkins-ios/a-0.png" alt="a-0"></p><ol><li>然后在General中勾选“参数化构建过程”，这里因为需要接收主调方发送的构建参数，所以要选这一项。因为要通知调用方执行结果，所以构建参数里增加“callbackurl”</li></ol><p><img src="/images/jenkins-ios/a-1.png" alt="a-1"></p><ol><li>接着在构建触发器中勾选“触发远程构建”，并填写身份证令牌。这里的身份证令牌和用户无关，仅仅只是这个job的api令牌，这里可以随便填一个，只要不太容易被猜到就行</li></ol><p><img src="/images/jenkins-ios/a-2.png" alt="a-2"></p><ol><li>最后在构建中增加“执行shell”选项。这里可以写执行任务的逻辑，我这儿就是简单的切换到工程目录，再调用fastlane打包，结束后回调完成的url</li></ol><p><img src="/images/jenkins-ios/a-3.png" alt="a-3"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~/projectPath          <span class="comment">#项目路径</span></div><div class="line">git checkout branch       <span class="comment">#切换到指定分支</span></div><div class="line">fastlane inhousepackage   <span class="comment">#调用fastlane完成打包</span></div><div class="line">curl  <span class="variable">$&#123;callbackurl&#125;</span>      <span class="comment">#调用回调url，通知调用方任务完成</span></div></pre></td></tr></table></figure><ol><li>到了这一步就完成了项目配置，不过因为用户认证相关的设置还没有完成，所以这个任务还不能被远程触发。点击右上角用户名可以进入到用户设置页面，点击设置，在“API Token”中添加一个token，使用这个token和用户名就能在其他机器上触发任务</li></ol><p><img src="/images/jenkins-ios/a-5.png" alt="a-5"></p><ol><li><p>完成上面这些设置后，会得到下列信息。主调方有了这些信息就能触发远程构建</p><blockquote><ul><li><p>用户名(userName)</p></li><li><p>用户令牌(userToken)</p></li><li>任务令牌(jobToken)</li><li>执行任务的机器ip地址，jenkins服务端口号码</li><li>jenkins任务名字(jobName)</li><li>回调url，这个非必须，不过不传的话无法知道任务是否已经结束(callbackurl)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment">#最后用上面这些信息拼接成类似下面这样的URL，通过http协议访问就能触发这台机器上的远程任务</span></div><div class="line">&gt; jobTriggerURL = <span class="string">"http://<span class="variable">$&#123;userName&#125;</span>:<span class="variable">$&#123;userToken&#125;</span>@<span class="variable">$&#123;jobServerIPAndPort&#125;</span>/job/<span class="variable">$&#123;jobName&#125;</span>/buildWithParameters?token=<span class="variable">$&#123;jobToken&#125;</span>&amp;callbackurl=<span class="variable">$&#123;callbackurl&#125;</span>"</span></div><div class="line">&gt; curl jobTriggerURL</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote></li></ol><h4 id="调用端"><a href="#调用端" class="headerlink" title="调用端"></a>调用端</h4><p>当执行端设置好以后，调用端的设置就比较简单了。</p><ol><li>在jenkins中新建一个任务，这里选“流水线”，因为调用端的逻辑用到了一些pipeline插件，而且还有一些逻辑要处理，用流水线可以实现更精确控制</li></ol><p><img src="/images/jenkins-ios/b-1.png" alt="b-1"></p><ol><li>在“高级项目选项”中的“流水线”里写下下面的逻辑：</li></ol><p><img src="/images/jenkins-ios/b-2.png" alt="b-2"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">stage (<span class="string">"Wait remote iOS package job finish."</span>) &#123;</div><div class="line">    node &#123;</div><div class="line">        hook = registerWebhook()   <span class="comment">#这里使用了Webhook Step Plugin插件</span></div><div class="line"></div><div class="line">        </div><div class="line">        ip = sh (</div><div class="line">            script: <span class="string">"ifconfig en0 | sed -n 's/[\\s\\t]*inet \\([0-9\\.]*\\) .*/\\1/p' | tr -d '\\t\\n'"</span>,</div><div class="line">            <span class="built_in">return</span>Stdout: <span class="literal">true</span></div><div class="line">        )</div><div class="line"></div><div class="line">        </div><div class="line">        url = sh (</div><div class="line">            script: <span class="string">"echo \"<span class="variable">$&#123;hook.getURL()&#125;</span>\" | sed -n 's/localhost:[0-9]*/<span class="variable">$&#123;ip&#125;</span>:8080/p'"</span>,</div><div class="line">            <span class="built_in">return</span>Stdout: <span class="literal">true</span></div><div class="line">        )</div><div class="line">        </div><div class="line">        <span class="comment">#$&#123;hook.getURL()&#125;获取的回调url中host部分是localhost，所以需要用本机ip替换</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#这里的所有信息都是在执行实际任务的机器上获取的，具体细节看“执行端”部分</span></div><div class="line">        user =  <span class="string">"username"</span>  <span class="comment">#用户名字</span></div><div class="line">        userToken = <span class="string">""</span>      <span class="comment">#用户认证token</span></div><div class="line">        jobToken = <span class="string">"triggertoken123"</span>  <span class="comment">#任务token</span></div><div class="line">        jobServerIP = <span class="string">"172.20.24.122:8080"</span> </div><div class="line">        jobName = <span class="string">"iOS"</span></div><div class="line">        </div><div class="line">       </div><div class="line">        <span class="comment">#获取到上面的这些信息以后拼接成下面这个样式的url，发送get请求就能触发远程job</span></div><div class="line">        <span class="comment">#因为有些参数包含特殊字符，所以需要加上--data-urlencode来进行转义</span></div><div class="line">        jobTriggerURL = <span class="string">"http://<span class="variable">$&#123;user&#125;</span>:<span class="variable">$&#123;userToken&#125;</span>@<span class="variable">$&#123;jobServerIP&#125;</span>/job/<span class="variable">$&#123;jobName&#125;</span>/buildWithParameters"</span></div><div class="line">        <span class="built_in">echo</span> <span class="string">"job url:<span class="variable">$&#123;jobTriggerURL&#125;</span>"</span></div><div class="line">        sh(<span class="string">"curl --data-urlencode \"token=<span class="variable">$&#123;jobToken&#125;</span>\" --data-urlencode \"callbackurl=<span class="variable">$&#123;url&#125;</span>\" <span class="variable">$&#123;jobTriggerURL&#125;</span>"</span>)</div><div class="line">        </div><div class="line">   </div><div class="line">        <span class="built_in">echo</span> <span class="string">"Webhook called with data: <span class="variable">$&#123;url&#125;</span>"</span></div><div class="line">        data = <span class="built_in">wait</span>ForWebhook hook</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>脚本的主要逻辑是调用远程job，然后等待远程任务发送回调请求。这里用到了<a href="https://wiki.jenkins.io/display/JENKINS/Webhook+Step+Plugin" target="_blank" rel="external">Webhook Step Plugin</a>插件，它主要作用是获取一个回调URL，并挂起当前执行的脚本，直到回调url被调用以后再继续执行。</p><p>经过上面的配置后就能在公司jenkins上进行iOS项目自动化发布了。如果jenkins是在外网，则会麻烦一些，需要连vpn或者在NAT上做一个端口映射才行。</p>]]></content>
    
    <summary type="html">
    
      使用Jenkins进行iOS项目自动化发布
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS Fastlane打包教程</title>
    <link href="http://petpwiuta.github.io/2018/12/25/iOS%20Fastlane%E6%89%93%E5%8C%85%E6%95%99%E7%A8%8B/"/>
    <id>http://petpwiuta.github.io/2018/12/25/iOS Fastlane打包教程/</id>
    <published>2018-12-25T07:31:45.216Z</published>
    <updated>2018-12-26T06:22:44.633Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iOS-Fastlane打包教程"><a href="#iOS-Fastlane打包教程" class="headerlink" title="iOS Fastlane打包教程"></a>iOS Fastlane打包教程</h3><p><a href="https://fastlane.tools/" target="_blank" rel="external">Fastlane</a>是一套由Ruby编写的自动打包以及分发工具集。它的设计类似于Unix中的shell pipeline，每个功能由特定的工具实现，通过不同的工具的连接组合成强大的功能。</p><blockquote><p>下面这些是Fastlane提供的常用工具：</p><ul><li><p><code>gym</code>: 打包 iOS App，是对<em>xcodebuild</em>的封装</p></li><li><p><code>match</code>: 用于在团队中同步证书和配置文件的工具</p></li></ul><ul><li><code>deliver</code>: 将应用截图，元数据和 app 上传到 App Store</li><li><code>produce</code>: 使用命令行在 iTunes Connect 后台和 Dev Portal 创建新的 iOS app</li></ul></blockquote><p>这里仅仅是列出了最常用的工具，Fastlane标准安装包中的<a href="https://docs.fastlane.tools/actions/" target="_blank" rel="external"><strong>工具</strong></a>非常多，而且还有<a href="https://www.jianshu.com/p/0520192c9bd7" target="_blank" rel="external"><strong>自定义插件</strong></a>功能，这里就不赘述。</p><h4 id="1-安装Fastlane"><a href="#1-安装Fastlane" class="headerlink" title="1 安装Fastlane"></a>1 安装Fastlane</h4><p> Fastlane本质是一个Ruby脚本的集合，所以机器上首先得安装Ruby。OS X 10.9(Mavericks)以后默认安装的是 Ruby 2.0 本。可能有些脚本或者工具要求更高的版本，所以安装的时候尽量选最新版的Ruby。</p><p>这里用<a href="https://brew.sh/" target="_blank" rel="external">Homebrew</a>作为包管理器来安装Ruby：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$brew install ruby</div></pre></td></tr></table></figure><p>安装完Ruby以后才是我们的主角Fastlane：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo gem install fastlane</div></pre></td></tr></table></figure><p>等安装脚本执行完就可以开始Fastlane之旅啦！</p><h4 id="2-Fastlane设置"><a href="#2-Fastlane设置" class="headerlink" title="2 Fastlane设置"></a>2 Fastlane设置</h4><p>当Fastlane安装好以后，切换到想要用Fastlane进行打包的工程目录，然后初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fastlane init</div></pre></td></tr></table></figure><p>输入上面这个命令以后Fastlane会调用交互式脚本会询问你关于App的一些信息，按照实际信息填写完以后会生成下面这个结构的目录</p><p><img src="/images/fastlant-folder-structure.png" style="zoom:50%" align="left/"></p><p>fastlane文件夹里面包含了Appfile、Fastfile等文件，它们其实都是ruby语法的脚本文件。上面这些都不用手动添加，运行对应的工具以后就会由工具自动生成，配置文件按需生成，不运行特定工具就不会有对应配置文件产生，如Matchfile，它在你运行<code>fastlane match</code>并输入相关信息后才会出现。</p><p>下面是常见的配置文件的用途：</p><ul><li>Appfile 记录了app_identifier、apple_id、itc_team_id、team_id等信息</li><li>Fastfile 最核心的文件。自己编写的Fastlane脚本逻辑都写在这个文件中</li><li>Matchfile 如果是用Match来管理证书的话会有这个文件，里面记录了Match工具在运行时所需要的app_identifier、team_id、username、git_url等信息</li></ul><p>fastlane的很多工具既可以写在Fastfile中当一个函数来调用，也可以直接在shell命令行用<code>fastlane 工具名</code>这种方式当命令来使（实际上是一样的，都是执行了对应的ruby脚本）。</p><p>上述文件里的配置信息会同步到Fastfile脚本的执行context中，如果用户在脚本里调用工具时没有指定这些字段的值，就会使用配置文件中的，反之就会以脚本里指定的为准。比如在Appfile中有app_identifier字段，你在Appfile中写的是a，在Fastfile中调用match时如果不写app_identifier就会取Appfile中的值也就是a，如果明确指定app_identifier为b，则会以b为准。不过在脚本中指定app_identifier为新值并不会把Appfile中的也改掉。</p><p>除了上面说的以外还有一种情况，就是在Matchfile和Appfile中都指定了app_identifier，这到底以哪个为准？这种情况下会以你运行的命令对应的配置文件为准，比如你运行的是match，它有自己的配置文件Matchfile，则app_identifier会以Matchfile中的为准。如果拿不准的话可以看fastlane的输出log，里面会详细列出脚本执行时的各种环境变量。</p><h4 id="3-Fastfile样例"><a href="#3-Fastfile样例" class="headerlink" title="3 Fastfile样例"></a>3 Fastfile样例</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">default_platform <span class="symbol">:ios</span></div><div class="line"></div><div class="line"></div><div class="line">platform <span class="symbol">:ios</span> <span class="keyword">do</span></div><div class="line">  before_all <span class="keyword">do</span>   </div><div class="line">    backup_project_info_file()</div><div class="line">    cocoapods()</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  after_all <span class="keyword">do</span> <span class="params">|lane|</span></div><div class="line">    restore_project_info_file()</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  error <span class="keyword">do</span> <span class="params">|lane, exception|</span></div><div class="line">    restore_project_info_file()</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  desc <span class="string">"Deploy a new enterprise version"</span></div><div class="line">  lane <span class="symbol">:inhouse</span> <span class="keyword">do</span></div><div class="line"></div><div class="line">    <span class="comment">#start archive</span></div><div class="line">    build_app(</div><div class="line">      <span class="symbol">workspace:</span> <span class="string">"Demo.xcworkspace"</span>,</div><div class="line">      <span class="symbol">scheme:</span> <span class="string">"Demo"</span>,</div><div class="line">      <span class="symbol">configuration:</span> <span class="string">"Release"</span>,</div><div class="line">      <span class="symbol">clean:</span> <span class="literal">true</span>,</div><div class="line">      <span class="symbol">export_options:</span> <span class="string">"./fastlane/EnterpriseExportOptions.plist"</span>,</div><div class="line">      <span class="symbol">build_path:</span> <span class="string">"./Build/"</span>,</div><div class="line">      <span class="symbol">output_directory:</span> <span class="string">"./Build/"</span>,</div><div class="line">      <span class="symbol">include_symbols:</span> <span class="literal">false</span>,  <span class="comment">#ipa包中包含符号文件</span></div><div class="line">      <span class="symbol">output_name:</span> <span class="string">"Demo.ipa"</span>,</div><div class="line">    )</div><div class="line"></div><div class="line">    <span class="comment">#make change log from commit history</span></div><div class="line">    log = changelog_from_git_commits(<span class="symbol">merge_commit_filtering:</span> <span class="string">"exclude_merges"</span>)</div><div class="line"></div><div class="line">    <span class="comment">#upload to pger</span></div><div class="line">    pgyer(<span class="symbol">api_key:</span> <span class="string">"api key"</span>, <span class="symbol">user_key:</span> <span class="string">"ukey"</span> ,<span class="symbol">update_description:</span> log)</div><div class="line"></div><div class="line">    <span class="comment">#post notification by dingding</span></div><div class="line">    dingding_noti(</div><div class="line">      <span class="string">"./Build/Demo.ipa"</span>,  <span class="comment">#ipa path</span></div><div class="line">      <span class="string">""</span>,   <span class="comment">#ipa url</span></div><div class="line">      <span class="string">""</span>, <span class="comment">#icon url</span></div><div class="line">      log <span class="comment">#change log</span></div><div class="line">    )</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><hr><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lane <span class="symbol">:inhouse</span> <span class="keyword">do</span></div><div class="line">    <span class="comment">#自定义逻辑</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>上面这个格式就是定义一个action，当你使用<code>fastlane inhouse</code>时里面的自定义代码就会被运行。</p><p>这是一个典型的Fastfile逻辑，先是调用build_app来archive并导出ipa文件，再调用changelog_from_git_commits生成change log，然后把ipa上传到蒲公英分发系统，最后再用钉钉通知任务完成。这里是在单个target以及证书和相关profile都配置好的情况下的demo。不过在实际中往往会有动态修改target信息，用match更新证书和profile等逻辑，最终的脚本就要比这个复杂很多。</p><h4 id="4-Fastlane-Jenkins"><a href="#4-Fastlane-Jenkins" class="headerlink" title="4 Fastlane+Jenkins"></a>4 Fastlane+Jenkins</h4><p>其实Jenkins对移动端的打包支持的并不好，所以在Fastlane成熟以后很多人都把打包逻辑迁移到Fastlane上了。这里Jenkins就演变成变成一个CI控制台，仅仅用来做权限控制和脚本触发器。</p><p>Jenkins中集成Fastlane就很简单了，在编译的环节直接调用本地的Fastlane脚本就行。</p><h4 id="5-题外话"><a href="#5-题外话" class="headerlink" title="5 题外话"></a>5 题外话</h4><p>Fastlane踩坑下来发现这套方案功能确实很强大，然而也很复杂。你得学Ruby（有些逻辑不一定能找到现成的插件，得自己写），然后还得把Fastlane的运行逻辑搞清楚，学习成本还是有一点的。所以Fastlane方案适合产品比较多，发版逻辑比较复杂的中大型公司。</p><p>在前几年专门做移动端CI的服务商还还不多，但现在移动领域CI集成方案已经很丰富。并且Xcode Server在经过几个版本的迭代以后基本上已经能满足大部分CI需求。所以Fastlane并非是唯一的选择，根据自己的需求选择合适的方案就行，<a href="https://medium.com/xcblog/five-options-for-ios-continuous-delivery-without-fastlane-2a32e05ddf3d" target="_blank" rel="external">这篇文章</a>详细介绍了除Fastlane以外其他的CI方案。</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li><p><a href="https://xiaozhuanlan.com/topic/4591867203" target="_blank" rel="external">Fastlane 的神秘花园</a></p></li><li><p><a href="https://medium.com/xcblog/five-options-for-ios-continuous-delivery-without-fastlane-2a32e05ddf3d" target="_blank" rel="external">Five Options for iOS Continuous Delivery without Fastlane</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      iOS Fastlane打包教程
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>移动开发中的CI方案简介</title>
    <link href="http://petpwiuta.github.io/2018/12/25/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84CI%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B/"/>
    <id>http://petpwiuta.github.io/2018/12/25/移动开发中的CI方案简介/</id>
    <published>2018-12-25T03:46:24.205Z</published>
    <updated>2018-12-26T06:12:45.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="移动开发中的CI方案简介"><a href="#移动开发中的CI方案简介" class="headerlink" title="移动开发中的CI方案简介"></a>移动开发中的CI方案简介</h3><p> <a href="https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/" target="_blank" rel="external">Continuous integration</a> (CI) 是软件工程中的重要概念，以前在传统的软件开发中用的比较多（以前常说的daily build or nightly build意思和CI差不多）。现在随着移动App的流行，相关的工具以及方法论在移动开发中也有所体现。这里简单说一下现在移动研发领域的CI现状（CI工具一般都是跨语言的，所以下面列出的这些工具大部分也能在前后端开发中使用）。</p><p>现在CI的解决方案很多，有开源的也有收费的。开源的免费，绝大部分功能都够用，不过出问题得自己处理，不过如果选热门的开源解决方案的话基本上常见问题都有人帮你踩坑了，所以这点不用担心（反之如果选冷门开源方案一定要做好自己改代码的心理准备）。商业方案除了贵以外没啥缺点，一般就是衡量价格、功能，以及各厂商的差异化功能。</p><h4 id="开源方案"><a href="#开源方案" class="headerlink" title="开源方案"></a>开源方案</h4><ul><li><p><a href="https://jenkins.io/" target="_blank" rel="external">Jenkins</a></p><p>Jenkins是一款著名的开源CI工具，除了界面丑点，其他功能基本上和一般收费方案没什么区别。很多公司团队会基于Jenkins做二次开发，把后端、前端和移动端的CI都集成到Jenkins中。</p></li><li><p><a href="https://travis-ci.com/" target="_blank" rel="external">Travis CI</a></p><p>Travis CI是一个开源的在线<a href="https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88" target="_blank" rel="external">持续集成</a>服务，用来构建和测试托管在Github上的代码。它和Github类似，对开源项目免费，其他项目要收费。这个用来做个人项目比较方便，如果公司要用的话可以选它的付费企业版服务。</p></li><li><p><a href="https://about.gitlab.com/" target="_blank" rel="external">GitLab</a></p><p>GitLab是互联网公司常用的开源代码管理工具，在8.0版本上也有CI功能了。</p></li></ul><h4 id="收费方案"><a href="#收费方案" class="headerlink" title="收费方案"></a>收费方案</h4><ul><li><p><a href="https://circleci.com/" target="_blank" rel="external">Circle CI</a></p><p>Circle CI本身是在线服务，不过企业版支持私有化部署。</p></li><li><p><a href="https://www.bitrise.io/" target="_blank" rel="external">Bitrise</a></p><p>Bitrise是专门为移动应用而设计的CI在线服务，企业版支持私有化部署。</p></li><li><p><a href="https://visualstudio.microsoft.com/zh-hans/app-center/" target="_blank" rel="external">Visual Studio App Center</a></p><p>Visual Studio App Center和Bitrise一样，是微软专门为移动应用而设计的CI在线服务</p></li></ul><p>这里只是对市面上常见的CI方案做了下汇总，如果想看看各种方案的详细对比可以看<a href="https://hackernoon.com/top-ci-cd-tools-for-your-android-and-ios-projects-8d356b983b3b" target="_blank" rel="external">这篇文章</a>。</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li><a href="https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/" target="_blank" rel="external">Continuous integration</a></li><li><a href="https://hackernoon.com/top-ci-cd-tools-for-your-android-and-ios-projects-8d356b983b3b" target="_blank" rel="external">Best Jenkins alternatives. Top CI/CD Tools for your Android and iOS projects</a></li></ul>]]></content>
    
    <summary type="html">
    
      移动开发中的CI方案简介
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Match工具介绍</title>
    <link href="http://petpwiuta.github.io/2018/12/06/Match%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    <id>http://petpwiuta.github.io/2018/12/06/Match工具介绍/</id>
    <published>2018-12-06T09:45:05.064Z</published>
    <updated>2018-12-26T06:11:28.955Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Match工具介绍"><a href="#Match工具介绍" class="headerlink" title="Match工具介绍"></a>Match工具介绍</h3><p>Match是Fastlane工具集中非常重要的一个，它负责iOS应用生命周期中的各种证书和profile的创建和维护。想想各位被各种证书和profile问题所支配的恐惧就知道它的厉害之处。</p><h4 id="1-功能特性"><a href="#1-功能特性" class="headerlink" title="1 功能特性"></a>1 功能特性</h4><ul><li><p>创建、更新和删除Xcode所需的各种证书和Profiles</p></li><li><p>使用Git管理上述的文件，达到团队内共享证书和Profiles的目的</p></li><li><p>证书和Profiles在进入Git仓库时会进行加密，进一步保证安全性</p></li><li><p>支持多账户，多target</p></li></ul><h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h4><p>Match内部使用cert、sign来分别进行证书以及profiles的管理。cert、sign是对苹果官方的API的二次封装，使用它们配置好证书和profiles以后，再指定一个Git仓库的地址，以及加密证书和profiles的密码，Match就会用指定的密码把证书和profiles加密，然后在把加密后的文件commit到版本库，并push到Git仓库地址。当其他成员需要这些信息的时候使用Match命令，它就会从Git仓库pull加密过的文件，并询问密码，得到密码后再把这些文件解密并添加到keychain和Profiles目录。这样就像Git管理代码一样实现了团队内共享证书和Profiles的目的。</p><h4 id="3-用法"><a href="#3-用法" class="headerlink" title="3 用法"></a>3 用法</h4><h5 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ fastlane match init</div></pre></td></tr></table></figure><p>会进入交互式shell环境，按照实际情况输入app_identifier、team_id、username、git_url等信息后会在fastlane目录生成Matchfile。</p><h5 id="3-2-生成并同步证书和profile"><a href="#3-2-生成并同步证书和profile" class="headerlink" title="3.2 生成并同步证书和profile"></a>3.2 生成并同步证书和profile</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 开发环境证书</span></div><div class="line">$ fastlane match development</div><div class="line"><span class="comment"># 产品环境证书</span></div><div class="line">$ fastlane match appstore</div><div class="line"><span class="comment"># 内测环境证书</span></div><div class="line">$ fastlane match adhoc</div></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li><p><a href="http://icyleaf.com/2017/03/fastlane-match-in-action/" target="_blank" rel="external">你虐我千百遍，我待你如初恋，直到我遇到 match</a></p></li><li><p><a href="https://docs.fastlane.tools/actions/match/" target="_blank" rel="external">match doc</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      Match工具介绍
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Xcode Signing 机制</title>
    <link href="http://petpwiuta.github.io/2018/12/06/Xcode%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/"/>
    <id>http://petpwiuta.github.io/2018/12/06/Xcode签名机制/</id>
    <published>2018-12-06T09:45:05.064Z</published>
    <updated>2018-12-26T06:12:11.715Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Xcode-Signing-机制"><a href="#Xcode-Signing-机制" class="headerlink" title="Xcode Signing 机制"></a>Xcode Signing 机制</h3><h4 id="历史遗留问题"><a href="#历史遗留问题" class="headerlink" title="历史遗留问题"></a>历史遗留问题</h4><p>做iOS开发经验稍长的同学都知道Xcode8以前的证书管理机制做的比较简单。就是一旦发现你的机器没有provisionProfile所关联的证书，就会在界面上显示红色按钮，你点击“Fix it”，然后Xcode就revoke provisionProfile所关联的证书，然后在帮你申请一个新的。</p><p>这个单人单机的情况下没有什么问题，不过你如果有2台以上的mac就会发现“Fix it”这个按钮不能随便点。多台mac一般都是把私钥copy到每一台电脑上，如果在哪台电脑上点了“Fix it”，这时辛辛苦苦复制好的私钥就会revoke，瞬间所有mac都不能正常干活了。如果是一个人有多台电脑还好点，这个问题在团队里面更严重，多人有多人电脑时，很可能会有人误点到“Fix it”按钮，而造成整个团队罢工的情况。所以一般小组成员都会互相告诫不能随便点“Fix it”按钮，甚至有人还写了插件来禁用这个按钮。</p><p>这种痛苦的情况在Xcode8上得到了彻底解决。</p><h4 id="Xcode8引入的新的开发证书的更新机制"><a href="#Xcode8引入的新的开发证书的更新机制" class="headerlink" title="Xcode8引入的新的开发证书的更新机制"></a>Xcode8引入的新的开发证书的更新机制</h4><p>Xcode8引入的最大改变就是provisionProfile中关联的证书变成了多个，一个develop版本的provisionProfile中可以关联所有开发人员自己的证书。只要在机器上有列表中的任何一个证书就能进行代码签名，这样在新成员来时仅仅更新它自己的证书以及provisionProfile就行，并不会影响其他人，这个步骤在Xcode8中非常简单，只需要一个点击就能搞定</p><p>Xcode的这些操作都是在后台进行的，不过你如果想要了解估计的细节可以在左侧的“Show the Report navigator(最后一个选项)”选项卡中看到<br><img src="/images/xcode-sign.png" alt=""></p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ul><li><p>Automatically manage signning<br>在这种模式下每个开发人员都会有自己的develop证书，这时尽量用自己develop证书来archive，而不要用公共的开发证书，避免了别人不小心把公用证书revoke导致的一系列问题</p></li><li><p>manully manage signning<br>手动管理证书的时候主要不要选和自己帐号相关联的证书，因为自己的帐号只有自己有，到团队其他成员的机器上就不能工作了。这时候就选develope这样的默认值就行了</p></li></ul><h4 id="相关引用"><a href="#相关引用" class="headerlink" title="相关引用"></a>相关引用</h4><ul><li><a href="https://developer.apple.com/videos/play/wwdc2017/403/" target="_blank" rel="external">What’s New in Signing for Xcode and Xcode Server - WWDC2017</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2016/401" target="_blank" rel="external">What’s New in Xcode App Signing - WWDC2016</a></li></ul>]]></content>
    
    <summary type="html">
    
      Xcode Signing 机制
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Symbolicatecrash符号化crash日志</title>
    <link href="http://petpwiuta.github.io/2018/11/14/%E4%BD%BF%E7%94%A8Symbolicatecrash%E7%AC%A6%E5%8F%B7%E5%8C%96crash%E6%97%A5%E5%BF%97/"/>
    <id>http://petpwiuta.github.io/2018/11/14/使用Symbolicatecrash符号化crash日志/</id>
    <published>2018-11-14T09:24:09.651Z</published>
    <updated>2018-12-26T06:30:18.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Symbolicatecrash符号化crash日志"><a href="#使用Symbolicatecrash符号化crash日志" class="headerlink" title="使用Symbolicatecrash符号化crash日志"></a>使用Symbolicatecrash符号化crash日志</h2><ol><li><p>准备工作<br>解析crash日志需要3个文件：</p><ul><li><code>.crash</code>文件</li><li><code>.dSYM</code>文件</li><li><code>symbolicatecrash</code>工具</li></ul></li><li><p>配置symbolicatecrash<br>Xcode的symbolicatecrash路径如下：<br><code>/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash</code><br>如果在该路径下找不到工具的话可能是因为不同版本这个工具的位置不一样，可以用下面的命令搜索：<br><code>find /Applications/Xcode.app -name symbolicatecrash -type f</code></p><p> 到找symbolicatecrash以后还需要倒入环境变量才能使用，不然会报</p><blockquote><p>Error: “DEVELOPER_DIR” is not defined at ./symbolicatecrash<br>的错误</p></blockquote><p> 用<code>export DEVELOPER_DIR=&quot;/Applications/Xcode.app/Contents/Developer&quot;</code>就能设置环境变量，如果报错可能是安装了多个xcode，xcod的名字被修改了，如果是这样执行<code>xcode-select --print-path</code> 找到DEVELOPER_DIR，然后再执行上面的命令</p><p> 当然，设置环境变量也有一劳永逸的办法，就是把环境变量直接加到<code>~/.bash_profile</code>中，如果是zsh的话就是<code>~/.zshrc</code>。打开配置文件，在末尾添加</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># <span class="type">Add</span> environment variable <span class="type">DEVELOPER_DIR</span>  </div><div class="line">export <span class="type">DEVELOPER_DIR</span>=/<span class="type">Applications</span>/<span class="type">Xcode</span>.app/<span class="type">Contents</span>/<span class="type">Developer</span></div></pre></td></tr></table></figure></li></ol><p>然后重启终端或者执行source命令刷新<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># <span class="type">Add</span> environment variable <span class="type">DEVELOPER_DIR</span>  </div><div class="line">source ~/.bash_profile</div><div class="line">source ~/.zshrc</div></pre></td></tr></table></figure></p><ol><li><p>符号化crash文件<br>到这一步就是调用symbolicatecrash工具进行符号化了，代码如下：<br><code>symbolicatecrash [.crash 文件] [.dSYM文件] &gt; [输出文件]</code></p></li><li><p>参考</p><ul><li><a href="https://www.jianshu.com/p/2ccb50520cb1" target="_blank" rel="external"> Xcode 7.3 解析（符号化） iOS Crash 文件（.crash）</a></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      使用Symbolicatecrash符号化crash日志
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>中国互联网拓扑结构</title>
    <link href="http://petpwiuta.github.io/2018/11/13/%E4%B8%AD%E5%9B%BD%E4%BA%92%E8%81%94%E7%BD%91%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/"/>
    <id>http://petpwiuta.github.io/2018/11/13/中国互联网拓扑结构/</id>
    <published>2018-11-13T15:28:24.497Z</published>
    <updated>2018-12-26T06:31:59.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中国互联网拓扑结构"><a href="#中国互联网拓扑结构" class="headerlink" title="中国互联网拓扑结构"></a>中国互联网拓扑结构</h2><h3 id="1-中国7大骨干网运营商"><a href="#1-中国7大骨干网运营商" class="headerlink" title="1 中国7大骨干网运营商"></a>1 中国7大骨干网运营商</h3><p>目前中国有七家骨干网运营商，分别是中国电信、中国联通、中国移动、中国教育和科研计算机网、中国科技网 、中国国际电子商务网和中国长城互联网。</p><ul><li>中国电信，拥有2张全国骨干网：中国公用计算机互联网（CHINANET / CHINA163）和中国电信下一代承载网（ChinaNet Next Carrying Network，简称CN2）。</li><li>中国联通，拥有2张全国骨干网：中国网通互联网（CHINA169）和旧中国网通互联网（CNCNET）。原中国金桥信息网(CHINAGBN)由吉通公司负责建设、运营和管理，2002年5月16日，吉通公司并入中国网通；2009年中国网通与中国联通合并。2009年工业和信息化部同意原中国网通互联网骨干网（CHINA169）和原中国联通互联网骨干网（UNINET）实施网络融合，并将 UNINET 作为下级网络接入 CHINA169。中国网通互联网（CHINA169）是从中国公用计算机互联网（CHINA163）拆分而来，但中国网通从中国电信拆分前已经拥有一张独立的网络（CNCNET），自治域为AS9929，现在也称作中国联通工业互联网（China Unicom Industrial Internet，简称CUII），定位为主要提供国际和国内跨地市MPLS VPN和大客户互联网专线任务的承载，常用于企业宽带和IDC，已经极少见于家用宽带。</li><li>中国移动，拥有1张全国骨干网：中国移动互联网（CMNET），于2000年1月组建。</li><li>中国教育和科研计算机网（CERNET）：始建于1994年，由中国教育部投资并管理，是中国最大的公益性、学术性计算机互联网络，网络总控中心设在清华大学。</li><li>中国科技网（CSTNET）：中国科技网的前身是中国科学院于1989年8月建立的中关村教育与科研示范网络（NCFC）。1994年4月，NCFC与美国NSFNET直接互联，实现了中国与国际互联网的首次全功能网络连接。1996年2月，以NCFC为基础发展起来的中国科学院院网（CASNET）更名为中国科技网（CSTNET）。</li><li>中国国际经济贸易互联网（CIETNET）：全国外贸系统企事业单位专用，由中国国际电子商务中心负责组建、运行和维护，不设国际出口带宽。</li><li>中国长城互联网（CGWNET）：军队专用，不设国际出口带宽。</li></ul><h3 id="2-骨干网的基本技术概念"><a href="#2-骨干网的基本技术概念" class="headerlink" title="2 骨干网的基本技术概念"></a>2 骨干网的基本技术概念</h3><ul><li>骨干网（backbone  network）：核心节点互相连接组成的网络，保障核心节间信息转发，不负责直接接入用户</li><li>支撑网：监管业务网的网络。类似于管理磁盘的软件本身就要占用一部分磁盘空间，管理网络的系统也需要使用一部分网络资源。</li><li>接入网（Access Network）：指骨干网络到用户终端之间的网络。因为终端网络介质较多，所以网络类型也很多，如有线的光纤，双绞线；无线的wifi，蜂窝移动网，卫星等</li></ul><h3 id="3-中国电信网络拓扑结构"><a href="#3-中国电信网络拓扑结构" class="headerlink" title="3 中国电信网络拓扑结构"></a>3 中国电信网络拓扑结构</h3><h4 id="中国电信163"><a href="#中国电信163" class="headerlink" title="中国电信163"></a>中国电信163</h4><p>163网络分为骨干网和城域网两层结构。骨干网层面，又可分为三层：核心层、汇接层和接入层，另外核心层还连接有国际出入口层、互联互通层。骨干网分为3大片区：北京、上海、广州。</p><p>骨干网3大片区又细分为9个大区：<br>北京片区：北京大区、天津大区、西安大区<br>上海片区：上海大区、南京大区、杭州大区<br>广州片区：广州大区、武汉大区、成都大区</p><ul><li><p>核心层：<br>  超级核心：北京、上海、广州<br>  普通核心：天津、西安、南京、杭州、武汉、成都<br>  核心节点间Full-Mesh连接<br>  负责各省份间信息交互，超级核心还负责与国内其他运营商、国际访问的流量交互</p></li><li><p>汇接层：<br>  北方省份落地设备，南方省份省网汇聚设备<br>  各省份双方向上联，分别连接到一个超级核心和一个普通核心节点，部分省份三方向上联</p></li></ul><ul><li>接入层：<br>未完成扁平化的省份还有地市接入层设备，用于接入省内城域网</li><li><p>中国电信ChinaNet网络骨干拓扑<br><img src="/images/networking-structure/Picture1.png" alt="中国电信ChinaNet网络骨干拓扑"></p></li><li><p>中国电信ChinaNet网络省内拓扑结构<br><img src="/images/networking-structure/Picture2.png" alt="中国电信ChinaNet网络省内拓扑结构"></p></li><li>国内互联互通层：<br>在北京、上海、广州三个超级核心设有互联互通设备（E路由器） ，互联互通设备（E路由器）直接连接在超级核心C路由器</li><li>ChinaNet通过互联互通设备与部分其它运营商互联和流量互访<br><img src="/images/networking-structure/Picture3.png" alt="ChinaNet通过互联互通设备与部分其它运营商互联和流量互访"></li><li>ChinaNet－国际网间互联拓扑<br><img src="/images/networking-structure/Picture4.png" alt="ChinaNet－国际网间互联拓扑"></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E9%AA%A8%E5%B9%B2%E7%BD%91%E8%BF%90%E8%90%A5%E5%95%86" target="_blank" rel="external">中国骨干网运营商</a></li><li><a href="https://wenku.baidu.com/view/4e3ab12681c758f5f71f67b9.html?from=search" target="_blank" rel="external">中国电信运营商骨干网络架构</a></li><li><a href="http://blog.51cto.com/juispan/2095304" target="_blank" rel="external">中国运营商网络分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      中国互联网拓扑结构
    
    </summary>
    
      <category term="CS基础" scheme="http://petpwiuta.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>给Xcode8安装插件</title>
    <link href="http://petpwiuta.github.io/2017/11/13/%E7%BB%99Xcode8%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/"/>
    <id>http://petpwiuta.github.io/2017/11/13/给Xcode8安装插件/</id>
    <published>2017-11-13T06:20:41.000Z</published>
    <updated>2017-11-13T08:03:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="给Xcode8安装插件"><a href="#给Xcode8安装插件" class="headerlink" title="给Xcode8安装插件"></a>给Xcode8安装插件</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Xcode8以后安装以前<a href="http://alcatraz.io/" target="_blank" rel="external">Alcatraz</a>上的插件就行不通了，不过网上也有很多方案，主要是重新给Xcode签名。这里把这些文章做一个汇总。</p><p>在Xcode8以后，苹果为了安全性(比如防止再次出现XcodeGhost事件)，把Xcode增加了签名校验，不会再加载以前Alcatraz下载的插件。并给出了自己的插件机制(<a href="https://developer.apple.com/videos/play/wwdc2016/414/" target="_blank" rel="external">Xcode Source Editor Extension</a>)，但是这个插件机制实用性很低。所以很多人就想着要继续使用以前的插件。</p><p>现在的主流方案是是把Xcode复制一份，一个没有重签名，用来打包上线。另外一份重签名后，重新使用以前的插件，仅仅用来写代码。下面就来说说<strong>如何进行Xcode重签名</strong>、以及<strong>如何让以往的插件能在重签名的Xcode上跑起来</strong>。</p><h4 id="Xcode重签名"><a href="#Xcode重签名" class="headerlink" title="Xcode重签名"></a>Xcode重签名</h4><ol><li>创建自签名证书<br>打开钥匙串，创建新证书，名称填XcodeSigner，证书类型选择代码签名(名字里面尽量不要包含空格，免得在命令行容易出错)<br><img src="/images/Xcod8plugin/xcode8_resign_1.png" alt=""><br><img src="/images/Xcod8plugin/xcode8_resign_2.png" alt=""></li><li><p>复制Xcode。这里因为要留一份未重签名的Xcode来打包，所以这里先复制一份，并重命名为XcodeSigner</p></li><li><p>给Xcode重签名(这里的Xcode已经重命名为XcodeSigner)<br><code>sudo codesign -f -s XcodeSigner /Applications/XcodeSigner.app</code></p></li></ol><p>经过上面这些步骤Xcode就已经被重签名了，什么？你说为什么三步，能一步到位吗，恩、问得好。还真有一步到位的解决方案。<br><a href="https://github.com/fpg1503/MakeXcodeGr8Again" target="_blank" rel="external">MakeXcodeGr8Again</a>把上面说的这三步合在了一起，并提供了CLI和GUI两种使用方式。一步到位！</p><p>运行重新签名过后的Xcode很多人会发现以前的插件还是没有工作。这个问题在以前就有。原因是插件的<code>DVTPlugInCompatibilityUUIDs</code>包含了可运行的Xcode版本id，Xcode更新以后需要把新Xcode的id添加到插件的<code>DVTPlugInCompatibilityUUIDs</code>中。</p><h4 id="把Xcode-id加入DVTPlugInCompatibilityUUIDs"><a href="#把Xcode-id加入DVTPlugInCompatibilityUUIDs" class="headerlink" title="把Xcode id加入DVTPlugInCompatibilityUUIDs"></a>把Xcode id加入DVTPlugInCompatibilityUUIDs</h4><ol><li><p>获取Xcode的uuid<br>Xcode的Info.plist里就保存了自己的uuid。</p><p>可以<code>右键点击Xcode</code>-&gt;<code>显示包内容</code>-&gt;<code>Contents/Info.plist</code>-&gt;<code>复制DVTPlugInCompatibilityUUID</code>来获取</p><p>也可以通过<code>defaults read /Applications/Xcode.app/Contents/Info.plist DVTPlugInCompatibilityUUID</code>命令来获取</p></li><li><p>把uuid加入插件的DVTPlugInCompatibilityUUIDs<br>Xcode插件放在<code>~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins</code>为xcplugin格式。通过显示包内容可以看到xcplugin中有个<code>Info.plist</code>，DVTPlugInCompatibilityUUIDs字段就是。</p></li></ol><p>把uuid更新到插件中需要两步，但是！插件有很多个，一个个来肯定要把人逼疯，这里当然有all in one的解决方案。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/Xcode.app/Contents/Info.plist DVTPlugInCompatibilityUUID`</div></pre></td></tr></table></figure><p>这个命令主要做了这些：<br>通过<code>find</code>在插件目录下找到所有插件的Info.plist文件。<br>通过<code>xargs</code>对上一步的搜索结果进行枚举，针对每一个Info.plist文件，利用<code>defaults write</code>命令将当前Xcode版本的uuid加到DVTPlugInCompatibilityUUIDs中。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="http://www.jianshu.com/p/309da7b2119d" target="_blank" rel="external">如何在Xcode8上安装插件</a></li><li><a href="http://joeshang.github.io/2015/04/10/fix-xcode-upgrade-plugin-invalid/" target="_blank" rel="external">Xcode升级后插件失效的原理与修复办法</a></li></ul>]]></content>
    
    <summary type="html">
    
      Xcode8上继续使用老插件
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>NSURLProtocol总结</title>
    <link href="http://petpwiuta.github.io/2017/09/10/NSURLProtocol%E4%BB%8B%E7%BB%8D/"/>
    <id>http://petpwiuta.github.io/2017/09/10/NSURLProtocol介绍/</id>
    <published>2017-09-10T12:59:55.000Z</published>
    <updated>2017-09-10T15:49:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NSURLProtocol总结"><a href="#NSURLProtocol总结" class="headerlink" title="NSURLProtocol总结"></a>NSURLProtocol总结</h2><p>NSURLProtocol可以说是苹果允许的一个中间人攻击组件，功能非常强大。但是关于NSURLProtocol的官方文档不多，不过业内已经有很多人踩坑，网上相关的文章比较多，这里把网上搜集到的相关文章做一个汇总</p><h3 id="NSURLProtocol介绍"><a href="#NSURLProtocol介绍" class="headerlink" title="NSURLProtocol介绍"></a>NSURLProtocol介绍</h3><p>NSURLProtocol是URL Loading System中的一个模块，能拦截这个系统中发出的所有请求，那具体是哪些类发出的请求呢？<code>NSURLConnection</code>、<code>NSURLSession</code>、<code>UIWebVIew(页面内部的所有请求包括ajax)</code>、<code>WKWebVIew(不能直接拦截，需要hack)</code>，以及基于他们的封装如<code>AFNetworking</code>、<code>Alamofire</code>等都是能拦截的，而基于<code>CFNetwork</code>的请求则不能被拦截</p><p>进行拦截以后可以做非常多的自定义行为，比如说：</p><ul><li>拦截图片加载请求，转为从本地文件加载</li><li>对HTTP返回内容进行mock和stub</li><li>对发出请求的header进行格式化</li><li>对发出的媒体请求进行签名</li><li>创建本地代理服务，用于数据变化时对URL请求的更改</li><li>故意制造畸形或非法返回数据来测试程序的鲁棒性</li><li>过滤请求和返回中的敏感信息</li><li>在既有协议基础上完成对 NSURLConnection 的实现且与原逻辑不产生矛盾</li></ul><h3 id="NSURLProtocol的用法"><a href="#NSURLProtocol的用法" class="headerlink" title="NSURLProtocol的用法"></a>NSURLProtocol的用法</h3><h4 id="新建、注册子类"><a href="#新建、注册子类" class="headerlink" title="新建、注册子类"></a>新建、注册子类</h4><p><code>NSURLProtocol</code>是一个抽象类，必须被子类化之后才能使用，所以要新建一个继承于它的子类。</p><p>基于NSURLConnection或者使用[NSURLSession sharedSession]创建的网络请求，调用registerClass方法即可<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSURLProtocol</span> registerClass:NetworkURLProtocol.class];   <span class="comment">//注册</span></div><div class="line">[<span class="built_in">NSURLProtocol</span> unregisterClass:NetworkURLProtocol.class]; <span class="comment">//注销</span></div></pre></td></tr></table></figure></p><p>而基于NSURLSession的网络请求，需要通过配置NSURLSessionConfiguration对象的protocolClasses属性来注册。(网络上有<a href="http://tech.lede.com/2017/02/15/rd/iOS/iOS_NSURLProtocol/" target="_blank" rel="external">文章</a>说protocolClasses这个数组里只有第一个NSURLProtocol会起作用。并以OHHTTPStubs库为例子，它是在注册先NSURLProtocol插入到protocolClasses的第一个，进行拦截。拦截完成之后又进行移除。这个还没有做实验证实)<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *sessionConfiguration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">sessionConfiguration.protocolClasses = @[NetworkURLProtocol.class];</div><div class="line"><span class="comment">//取消注册的话直接把protocol从数组中移除就行</span></div></pre></td></tr></table></figure></p><h4 id="重载必要的方法"><a href="#重载必要的方法" class="headerlink" title="重载必要的方法"></a>重载必要的方法</h4><p>(1)当遍历到我们自定义的NSURLProtocol时，系统先会调用<code>canInitWithRequest:</code>这个方法。顾名思义，这是整个流程的入口，只有这个方法返回YES我们才能够继续后续的处理。我们可以在这个方法的实现里面进行请求的过滤，筛选出需要进行处理的请求<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//是否有已编辑的标识，用来识别是第一次过来的请求还是已经改写过的请求</span></div><div class="line">    <span class="built_in">BOOL</span> isEditedRequest = [[<span class="built_in">NSURLProtocol</span> propertyForKey:<span class="string">@"NetworkURLProtocol"</span> inRequest:request] boolValue];</div><div class="line">    </div><div class="line">    <span class="comment">//根据配置来过滤请求</span></div><div class="line">    <span class="built_in">BOOL</span> configDeny = ![[NetworkManager sharedManager].config canCaptureRequest:request];</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (isEditedRequest || configDeny) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>(2)<code>canInitWithRequest</code>返回YES后系统会把请求回调到这里。在这里完成请求的编辑/替换工作。需要注意的是系统会以这个方法返回值为参数，再次调用上面说到的<code>canInitWithRequest</code>方法，所以这里一定要添加一些标志变量来区分请求是否被编辑，不然系统就会因为循环调用这两个方法而陷入死循环<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request  </div><div class="line">&#123;  </div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [request mutableCopy];</div><div class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@YES</div><div class="line">                        forKey:<span class="string">@"NetworkURLProtocol"</span></div><div class="line">                     inRequest:mutableReqeust];</div><div class="line">    <span class="keyword">return</span> [mutableReqeust <span class="keyword">copy</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>(3)处理开始和结束的状态<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Request被编辑完后，系统会调用这个方法，这里一般用来发起请求</span></div><div class="line"><span class="comment">//这里方法里一定要有手动发起网络请求的逻辑，否则整个流程就不会往下走</span></div><div class="line">- (<span class="keyword">void</span>)startLoading  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:[[<span class="keyword">self</span> <span class="keyword">class</span>] canonicalRequestForRequest:<span class="keyword">self</span>.request] delegate:<span class="keyword">self</span> startImmediately:<span class="literal">YES</span>];</div><div class="line">&#125;</div><div class="line"><span class="comment">//请求结束后会调用这个方法，在这里取消请求，以及做一些数据处理工作</span></div><div class="line">- (<span class="keyword">void</span>)stopLoading</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span>.connection cancel];</div><div class="line">&#125;</div><div class="line"><span class="comment">//用于判断你的自定义reqeust是否相同，这里返回默认实现即可。主要应用场景是某些直接使用缓存而非再次请求网络的地方。如果不是用来做缓存的话这个方法可以不实现</span></div><div class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> requestIsCacheEquivalent:a toRequest:b];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="调用NSURLProtocolClient协议方法"><a href="#调用NSURLProtocolClient协议方法" class="headerlink" title="调用NSURLProtocolClient协议方法"></a>调用NSURLProtocolClient协议方法</h4><p>NSURLProtocol给了一次机会让我们接管请求，我们在完成接管的过程中还是需要向我们的客户端(发起请求的业务代码)提供服务。NSURLProtocol实例中有个<code>id &lt;NSURLProtocolClient&gt; client</code>属性来帮我们做到这一点，我们只需要在合适的时机来调用<code>NSURLProtocolClient</code>协议规定的方法就行。<br>注意我们的模拟行为需要尽可能的和系统保持一致，所以<code>NSURLProtocolClient</code>协议规定的方法最好在对应的时机都要有相应的调用，换句话说就是<code>NSURLProtocolClient</code>协议规定的每一个方法都至少调用一遍</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSURLConnectionDelegate</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</div><div class="line">  didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didFailWithError:error];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)connectionShouldUseCredentialStorage:(<span class="built_in">NSURLConnection</span> *)connection &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</div><div class="line">didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge &#123;</div><div class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didReceiveAuthenticationChallenge:challenge];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</div><div class="line">didCancelAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge &#123;</div><div class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didCancelAuthenticationChallenge:challenge];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSURLConnectionDataDelegate</span></div><div class="line">- (<span class="built_in">NSURLRequest</span> *)connection:(<span class="built_in">NSURLConnection</span> *)connection willSendRequest:(<span class="built_in">NSURLRequest</span> *)request redirectResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</div><div class="line">    <span class="comment">//并非重定向请求才会走这个方法，一般的请求也会回调到这里。如果不做判断话会导致把一般请求当成重定向，而且在ios8.1上会直接崩溃</span></div><div class="line">    <span class="keyword">if</span> (response != <span class="literal">nil</span>)&#123;</div><div class="line">        <span class="keyword">self</span>.response = response;</div><div class="line">        [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> wasRedirectedToRequest:request redirectResponse:response];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> request;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</div><div class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageAllowed</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didLoadData:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSCachedURLResponse</span> *)connection:(<span class="built_in">NSURLConnection</span> *)connection willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse &#123;</div><div class="line">    <span class="keyword">return</span> cachedResponse;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</div><div class="line">    [[<span class="keyword">self</span> client] URLProtocolDidFinishLoading:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="NSURLProtocol的注意事项"><a href="#NSURLProtocol的注意事项" class="headerlink" title="NSURLProtocol的注意事项"></a>NSURLProtocol的注意事项</h3><p>(1) NSURLProtocol多线程问题。有同学可能会想到网络请求中多个request都会走NSURLProtocol的代理方法，那会不会有并发的问题。其实每个网络请求都会实例化一个NSURLProtocol的子类对象，所以每个网络请求之间不会互相影响</p><p>(2) NSURLProtocolClient回调必须跟发起请求的代码发送保持在一个线程、相同的Runloop。这个也很好理解，因为我们的改写逻辑对客户端(一般是业务代码)应该是透明的，所以行为和状态都应该和系统的网络请求框架保持一致：因此我们要在start方法中记录当前线程和Runloop模式。然后在记录的线程以相同的Runloop模式回调NSURLProtocolClient的方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> performSelector:onThread:withObject:waitUntilDone:modes:];</div></pre></td></tr></table></figure></p><p>(3) NSURLSession的POST请求拿不到HTTPBody。苹果官方的解释是Body是NSData类型，而且还没有大小限制。为了性能考虑，拦截时就没有拷贝</p><p>(4) WKWebview不能直接拦截。WKWebView在独立于app进程之外的进程中执行网络请求，请求数据不经过主进程，因此在WKWebView上直接使用NSURLProtocol无法拦截请求。需要hack一下，具体的技术方案请看”<a href="https://blog.yeatse.com/2016/10/26/support-nsurlprotocol-in-wkwebview/" target="_blank" rel="external">让WKWebView支持NSURLProtocol</a>“</p><p>(5) 多个NSURLProtocol嵌套使用。若一个项目中存在多个NSURLProtocol，那么NSURLProtocol的拦截顺序跟注册的方式和顺序有关。<br>对于使用registerClass方法注册：多个NSURLProtocol拦截顺序为注册顺序的反序，即后注册的的NSURLProtocol先拦截。<br>对于通过配置NSURLSessionConfiguration对象的protocolClasses属性来注册的：<br>protocolClasses这个数组里据说只有第一个NSURLProtocol会起作用。(还没做实验证实)</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://developer.apple.com/library/content/samplecode/CustomHTTPProtocol/Introduction/Intro.html" target="_blank" rel="external">CustomHttpProtocol苹果官方示例</a></li><li><a href="http://blog.csdn.net/jingcheng345413/article/details/54967739" target="_blank" rel="external">NSURLProtocol概述</a></li><li><a href="http://tech.lede.com/2017/02/15/rd/iOS/iOS_NSURLProtocol/" target="_blank" rel="external">NSURLProtocol全攻略</a></li><li><a href="https://blog.yeatse.com/2016/10/26/support-nsurlprotocol-in-wkwebview/" target="_blank" rel="external">让WKWebView支持NSURLProtocol</a></li><li><a href="https://github.com/AliSoftware/OHHTTPStubs" target="_blank" rel="external">OHHTTPStubs库</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653578513&amp;idx=1&amp;sn=961bf5394eecde40a43060550b81b0bb&amp;chksm=84b3b716b3c43e00ee39de8cf12ff3f8d475096ffaa05de9c00ff65df62cd73aa1cff606057d&amp;mpshare=1&amp;scene=1&amp;srcid=0214nkrYxApaVTQcGw3U9Ryp" target="_blank" rel="external">WKWebView那些坑</a></li></ul>]]></content>
    
    <summary type="html">
    
      NSURLProtocol可以说是苹果允许的一个中间人攻击组件，功能非常强大。但是关于NSURLProtocol的官方文档不多，不过业内已经有很多人踩坑，网上相关的文章比较多，这里把网上搜集到的相关文章做一个汇总
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS平台Webview和原生代码交互</title>
    <link href="http://petpwiuta.github.io/2017/02/20/iOS%E5%B9%B3%E5%8F%B0Webview%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BB%A3%E7%A0%81%E4%BA%A4%E4%BA%92/"/>
    <id>http://petpwiuta.github.io/2017/02/20/iOS平台Webview和原生代码交互/</id>
    <published>2017-02-20T05:41:21.000Z</published>
    <updated>2017-02-20T05:44:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS平台Webview和原生代码交互"><a href="#iOS平台Webview和原生代码交互" class="headerlink" title="iOS平台Webview和原生代码交互"></a>iOS平台Webview和原生代码交互</h1><p>最近遇到很多原生和前端进行交互的业务逻辑，前前后后做了一些调研。现在把常用的方法总结一下。<br>前端和原生交互大致分为这几种方式:拦截URL、WKWebView、JavaScriptCore，下面来分别说一下这几种方式的实现以及优缺点。</p><h2 id="1-拦截URL"><a href="#1-拦截URL" class="headerlink" title="1.拦截URL"></a>1.拦截URL</h2><h3 id="1-1-通过Webview的委托方法拦截"><a href="#1-1-通过Webview的委托方法拦截" class="headerlink" title="1.1 通过Webview的委托方法拦截"></a>1.1 通过Webview的委托方法拦截</h3><p>UIWebview<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(<span class="type">BOOL</span>)webView:(<span class="type">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="type">NSURLRequest</span> *)request navigationType:(<span class="type">UIWebViewNavigationType</span>)navigationType</div><div class="line">&#123;</div><div class="line">    <span class="type">NSString</span> *url = request.<span class="type">URL</span>.absoluteString;</div><div class="line"><span class="comment">//判断url特征，进行对应的逻辑处理</span></div><div class="line">    <span class="keyword">return</span> <span class="type">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>WKWebview<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(void)webView:(<span class="type">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="type">WKNavigationAction</span> *)navigationAction decisionHandler:(void (^)(<span class="type">WKNavigationActionPolicy</span>))decisionHandler</div><div class="line">&#123;</div><div class="line">    <span class="type">NSString</span> *url = navigationAction.request.<span class="type">URL</span>.absoluteString;</div><div class="line">    <span class="comment">//判断url特征，进行对应的逻辑处理</span></div><div class="line">    decisionHandler(<span class="type">WKNavigationActionPolicyAllow</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>优势：实现简单方便</li><li>缺点：如果是用GET请求的话在原生和webview之间传参会有长度限制。而POST请求的话需要只能在UIWebview上才能获取到请求体，在WKWebview里面是无法获取到POST请求体的。</li></ul><h3 id="1-2-使用WebViewJavascriptBridge"><a href="#1-2-使用WebViewJavascriptBridge" class="headerlink" title="1.2 使用WebViewJavascriptBridge"></a>1.2 使用WebViewJavascriptBridge</h3><p>这个是iOS上使用的比较多的js交互框架，也是基于拦截URL的方式来实现的。不过在自己公司项目中用的不多，所以没有做深入的了解。</p><h3 id="1-3-通过NSURLProtocol拦截"><a href="#1-3-通过NSURLProtocol拦截" class="headerlink" title="1.3 通过NSURLProtocol拦截"></a>1.3 通过NSURLProtocol拦截</h3><p>这个是利用了NSURLProtocol会拦截webview的网络请求而实现的，本质上和通过Webview的委托方法拦截差不多。不过据说WKWebView貌似不支持NSURLProtocol，没有做实验，具体是否可行还需要测试。</p><h2 id="2-WKWebView"><a href="#2-WKWebView" class="headerlink" title="2.WKWebView"></a>2.WKWebView</h2><p>iOS8，苹果新推出了WebKit，用WKWebView代替UIWebView和WebView。相关的使用和特性可以细读<a href="http://nshipster.cn/wkwebkit/" target="_blank" rel="external">WKWebView</a>和<a href="http://www.appcoda.com/webkit-framework-intro/" target="_blank" rel="external">A Look at the WebKit</a>、<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView那些坑</a>(林泽水原创发表在bugly公众号上的一篇文章，基本上把它的缺陷都点出来了，入坑前必读)。</p><p>优点:功能比UIWebview强大很多，调用js的时候可以返回对象以及错误状态；而且js也可以直接反向回调<br>缺点:WKWebview的坑很多，参见上一段落提到的“<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebview那些坑</a>”</p><ul><li><p>App调用js<br>WKWebView调用js方法和UIWebView类似，一个是<code>evaluateJavaScript</code>，一个是<code>stringByEvaluatingJavaScriptFromString</code>。不过获取返回值的方式不同，WKWebView用的是闭包回调;UIWebview返回的是一个string。</p></li><li><p>js调用App<br>UIWebView中js是没办法直接回调App的(只能用url的方式间接回调)，而在WKWebView中有了改进。具体步骤分为App注册handler，js调用，App处理handler委托三个步骤</p><ol><li><p>注册handler</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">config = <span class="type">WKWebViewConfiguration</span>()</div><div class="line"> <span class="comment">//注册js方法</span></div><div class="line">config.userContentController.addScriptMessageHandler(<span class="keyword">self</span>, name: <span class="string">"WebApp"</span>)</div><div class="line"> <span class="comment">// 初始化</span></div><div class="line">webView = <span class="type">WKWebView</span>(frame: <span class="keyword">self</span>.webWrap.frame, configuration: config)</div></pre></td></tr></table></figure></li><li><p>js调用<br>通过window.webkit.messageHandlers.WebApp找到之前注册的handler对象，然后调用postMessage方法把数据传到WebApp通过上一步的方法解析方法名和参数。WebApp是之前注册的name。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = &#123;</div><div class="line">                 'method' : 'hello',</div><div class="line">                 'param1' : 'liuyanwei',</div><div class="line">               &#125;;</div><div class="line"> window.webkit.messageHandlers.<span class="type">WebApp</span>.postMessage(message);</div></pre></td></tr></table></figure></li><li><p>处理handler委托<br>之前初始化Webview时指定的MessageHandler要实现WKScriptMessageHandler的协议方法<code>userContentController(userContentController: WKUserContentController, didReceiveScriptMessage message: WKScriptMessage)</code>然后在这里面处理事件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">userContentController</span><span class="params">(<span class="number">_</span> userContentController: WKUserContentController, didReceive message: WKScriptMessage)</span></span> &#123;</div><div class="line">       <span class="comment">//根据传过来数据从而决定app调用的方法</span></div><div class="line">       <span class="keyword">let</span> dict = message.body <span class="keyword">as</span>! <span class="type">Dictionary</span>&lt;<span class="type">String</span>,<span class="type">Any</span>&gt;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li></ol></li></ul><h2 id="3-JavaScriptCore"><a href="#3-JavaScriptCore" class="headerlink" title="3.JavaScriptCore"></a>3.JavaScriptCore</h2><p>JavaScriptCore中类及协议：<br>JSContext：给JavaScript提供运行的上下文环境,通过-evaluateScript:方法就可以执行js代码<br>JSValue：封装了js与OC中的对应的类型，以及调用js的API等<br>JSManagedValue：管理数据和方法的类<br>JSVirtualMachine：处理线程相关，使用较少<br>JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议，在协议中声明的API都会在js中暴露出来，才能调用</p><ul><li><p>OC调用js<br>在JavaScriptCore中提供的调用js的方法<code>-(JSValue *)evaluateScript:(NSString *)script</code>方法就可以执行一段JavaScript脚本，并且如果其中有方法、变量等信息都会被存储在其中以便在需要的时候使用。<br>JSValue提供了<code>-(JSValue *)callWithArguments:(NSArray *)arguments</code>方法来将参数传进去调用方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个JSContext对象，就类似于js中的window</span></div><div class="line"> <span class="comment">// 只需要创建一次即可。</span></div><div class="line"><span class="type">JSContext</span> *context = [[<span class="type">JSContext</span> alloc] <span class="keyword">init</span>];</div><div class="line"><span class="comment">// 执行一段js</span></div><div class="line">[context evaluateScript:@<span class="string">"function add(a, b) &#123; return a + b; &#125;"</span>];</div><div class="line"><span class="comment">// 根据下标取出方法</span></div><div class="line"><span class="type">JSValue</span> *add = context[@<span class="string">"add"</span>];</div><div class="line"><span class="type">NSLog</span>(@<span class="string">"Func: %@"</span>, add);</div><div class="line"><span class="comment">// 传入参数 调用取到的方法</span></div><div class="line"><span class="type">JSValue</span> *sum = [add callWithArguments:@[@(<span class="number">7</span>), @(<span class="number">21</span>)]];</div><div class="line"><span class="type">NSLog</span>(@<span class="string">"Sum: %d"</span>,[sum toInt32]);</div><div class="line"><span class="comment">//OutPut:</span></div><div class="line"><span class="comment">// Func: function add(a, b) &#123; return a + b; &#125;</span></div><div class="line"><span class="comment">// Sum: 28</span></div></pre></td></tr></table></figure></li><li><p>js调用OC<br>使用JavaScriptCore在JS端调用原生代码的时候主要有两种方式：block和方法注入。</p><ol><li><p>Block方式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    <span class="type">JSContext</span> *context = [[<span class="type">JSContext</span> alloc] <span class="keyword">init</span>];</div><div class="line"><span class="comment">// 定义一个block</span></div><div class="line">context[@<span class="string">"log"</span>] = ^() &#123;</div><div class="line">    <span class="type">NSArray</span> *args = [<span class="type">JSContext</span> currentArguments];</div><div class="line">    <span class="keyword">for</span> (<span class="type">JSValue</span> *jsVal <span class="keyword">in</span> args) &#123;</div><div class="line">   <span class="type">NSLog</span>(@<span class="string">"%@"</span>, jsVal);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="type">JSValue</span> *this = [<span class="type">JSContext</span> currentThis];</div><div class="line"><span class="type">NSLog</span>(@<span class="string">"this: %@"</span>,this);</div><div class="line"><span class="type">NSLog</span>(@<span class="string">"-------End Log-------"</span>);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 调用js执行log方法</span></div><div class="line"> [context evaluateScript:@<span class="string">"log('ider', [7, 21],&#123; hello:'world', js:100 &#125;);"</span>];</div></pre></td></tr></table></figure></li><li><p>OC方法注入<br>这里需要原生自定义一个协议，并且它还需要遵守JSExport协议。协议里的方法，就是暴露给js端的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@<span class="class"><span class="keyword">protocol</span> <span class="title">JavaScriptObjectiveCDelegate</span> &lt;<span class="title">JSExport</span>&gt;</span></div><div class="line">-(<span class="title">void</span>)<span class="title">callWithDict</span>:(<span class="title">NSDictionary</span> *)<span class="title">params</span>;</div><div class="line">@<span class="title">end</span></div></pre></td></tr></table></figure></li></ol></li></ul><p>然后自定义一个对象，让这个对象来实现上面所说的协议<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 此模型用于注入JS的模型，这样就可以通过模型来调用方法。</span></div><div class="line">@interface <span class="type">HYBJsObjCModel</span> : <span class="type">NSObject</span> &lt;<span class="type">JavaScriptObjectiveCDelegate</span>&gt;</div><div class="line">@property (nonatomic, <span class="keyword">weak</span>) <span class="type">JSContext</span> *jsContext;</div><div class="line">@property (nonatomic, <span class="keyword">weak</span>) <span class="type">UIWebView</span> *webView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation <span class="type">HYBJsObjCModel</span></div><div class="line">- (void)callWithDict:(<span class="type">NSDictionary</span> *)params &#123;</div><div class="line"> <span class="type">NSLog</span>(@<span class="string">"Js调用了OC的方法，参数为：%@"</span>, params);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p><p>对象实现完了，在哪里注入呢。在controller的webView加载完成后我们是通过webView的valueForKeyPath获取的，其路径为documentView.webView.mainFrame.javaScriptContext。这样就可以获取到js的context，然后为这个context注入我们的模型对象。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)webViewDidFinishLoad:(<span class="type">UIWebView</span> *)webView </div><div class="line">&#123;</div><div class="line"> <span class="keyword">self</span>.jsContext = [webView valueForKeyPath:@<span class="string">"documentView.webView.mainFrame.javaScriptContext"</span>];</div><div class="line">  <span class="comment">// 通过模型调用方法，这种方式更好些。</span></div><div class="line">  <span class="type">HYBJsObjCModel</span> *model  = [[<span class="type">HYBJsObjCModel</span> alloc] <span class="keyword">init</span>];</div><div class="line">  <span class="comment">// 模型</span></div><div class="line">  <span class="keyword">self</span>.jsContext[@<span class="string">"OCModel"</span>] = model;</div><div class="line">  model.jsContext = <span class="keyword">self</span>.jsContext;</div><div class="line">  model.webView = <span class="keyword">self</span>.webView;</div><div class="line">  <span class="comment">// 增加异常的处理</span></div><div class="line">  <span class="keyword">self</span>.jsContext.exceptionHandler = ^(<span class="type">JSContext</span> *context,   </div><div class="line"> <span class="type">JSValue</span> *exceptionValue) &#123;</div><div class="line">    context.exception = exceptionValue;</div><div class="line">    <span class="type">NSLog</span>(@<span class="string">"异常信息：%@"</span>, exceptionValue);</div><div class="line"> &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对应的在js端调用的代码如下<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 100px"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>OC方法注入<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Call OC method"</span> <span class="attr">onclick</span>=<span class="string">"OCModel.callWithDict()"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>JavaScript调用本地方法是在子线程中执行的，这里要根据实际情况考虑线程之间的切换。</p><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考:"></a>相关参考:</h2><ul><li><a href="http://www.jianshu.com/p/0042d8eb67c0" target="_blank" rel="external">WebView与JS的几种交互</a></li><li><a href="http://www.jianshu.com/p/f896d73c670a" target="_blank" rel="external">Objective-C与JavaScript交互的那些事</a></li></ul>]]></content>
    
    <summary type="html">
    
      iOS平台Webview和原生代码交互
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>《HTTP权威指南》笔记</title>
    <link href="http://petpwiuta.github.io/2017/02/06/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <id>http://petpwiuta.github.io/2017/02/06/HTTP权威指南/</id>
    <published>2017-02-06T04:01:56.000Z</published>
    <updated>2017-02-06T04:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《HTTP权威指南》"><a href="#《HTTP权威指南》" class="headerlink" title="《HTTP权威指南》"></a>《HTTP权威指南》</h1><h3 id="第一部分-HTTP：Web的基础"><a href="#第一部分-HTTP：Web的基础" class="headerlink" title="第一部分 HTTP：Web的基础"></a>第一部分 HTTP：Web的基础</h3><h4 id="2-URL与资源"><a href="#2-URL与资源" class="headerlink" title="2 URL与资源"></a>2 URL与资源</h4><p>在Web和URL出现之前,人们要靠分类杂乱的应用程序来访问分布在网络中的数据。大多数人都不会幸运地拥有所有合适的应用程序,或者不能够理解,也没有足够的耐心来使用这些程序。</p><p>在URL出现之前,要想和朋友共享complete-catalog.xls文件,就得说这样一些话:“用FTP连接到 ftp.joes-hardware.com上。用匿名登录,然后输入你的用户名作为密码。变换到pub目录。转换为二进制模式。现在,可以将名为complete-catalog.xls的文件下载到本地文件系统,并在那里浏览这个文件了。”</p><p>现在,像网景的Navigator和微软的Internet Explorer这样的浏览器都将很多这样的功能捆绑成一个便捷包。通过URL,这些应用程序就可以通过一个接口,以统一的方式去访问许多资源了。只要说“将浏览器指向 ftp://ftp.lots-o-books.com/pub/complete-catalog.xls”就可以取代上面那些复杂的指令了。</p><p>URL 为应用程序提供了一种访问资源的手段。实际上,很多用户可能都不知道他们的浏览器在获取所请求资源时所使用的协议和访问方法。</p><p>有了Web浏览器,就不再需要用新闻阅读器来阅读因特网新闻,或者用FTP客户端来访问FTP服务器上的文件了,而且也无需用电子邮件程序来收发E-mail报文了。URL告知浏览器如何对资源进行访问和处理,这有助于简化复杂的网络世界。应用程序可以使用URL来简化信息的访问过程。</p><p>URL为用户及他们的浏览器提供了找到信息所需的所有条件。URL定义了用户所需的特定资源,它位于何处以及如何获取它。</p><h4 id="3-HTTP报文结构"><a href="#3-HTTP报文结构" class="headerlink" title="3 HTTP报文结构"></a>3 HTTP报文结构</h4><ul><li>HTTP报文由起始行、首部和报文体(可选)组成</li><li>HTTP的方法除了GET以外还有很多种，HEAD是代表让服务器只返回首部，一般用于查看资源的状态、尺寸、类型、是否存在等 。PUT是就是让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档,或者,如果那个URL已经存在的话,就用这个主体来替代它。Trace是用于诊断，收到Trace请求的服务端会把收到的请求完整地回传给客户端。OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法,或者对某些特殊资源支持哪些方法。服务端的响应中的Allow首部会列出所有支持的方法</li><li>HTTP的方法是可以扩展的，只要服务端能正常理解和反馈就行</li><li>常见状态码：1xx，信息状态码；2xx，成功状态码；3xx重定向状态码、注意当服务端有缓存内容的时候也会返回重定向状态码；4xx客户端错误码；5xx服务端错误码</li><li>HTTP的首部就是key-val形式的信息、可以分为通用、请求、响应、实体状态描述等几个大类</li></ul><h4 id="4-HTTP链接管理"><a href="#4-HTTP链接管理" class="headerlink" title="4 HTTP链接管理"></a>4 HTTP链接管理</h4><ul><li>TCP/IP是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集。TCP会把数据拆解成多个分组然后封装成IP数据包发送</li><li>一个IP数据包通常包含了一个IP分组首部(通常为20字节); 一个TCP段首部(通常为 20 字节); 一个TCP数据块(0 个或多个字节)。IP 首部包含了源和目的IP地址、长度和其他一些标记。TCP段的首部包含了TCP端口号、TCP 控制标记,以及用于数据排序和完整性检查的一些数字值</li><li>HTTP的延迟主要由于以下几个原因造成：（1）DNS查询没有命中 （2）TCP握手 （3）HTTP报文传输 （4）回送HTTP响应</li><li>TCP握手：（1）发送SYN=i （2）回送ACK=i+1，SYN=k （3）再发送ACK=k+1，以及载荷数据</li><li>延迟确认：在接收方接收到数据后都要发送回执，这个回执会在一定的窗口期(100-200ms)内寻找发送到接收方的数据包来搭便车。所以如果在一段时间内都是单项数据传输的话，可能会因此产生延迟确认现象</li><li>TCP慢启动：为了防止网络突然拥堵，TCP实现了慢启动机制。一个TCP连接会随着它成功发送的数据量的增大而提速</li><li>TCP的TCP_NODELAY参数：在TCP连接中尽量要发送全尺寸数据（局域网中是1500字节，广域网中为几百字节），所以TCP会启用Nagle算法来尽量把数据赞起来直到达到一个全尺寸的数据包为止。这里就会因为攒数据而产生延迟</li><li>当某个TCP端点关闭TCP连接时,会在内存中维护一个小的控制块,用来记录最近所关闭连接的IP地址和端口号。TIME_WAIT端口耗尽是很严重的性能问题,会影响到性能基准,但在现实中相对较少出现</li><li>对HTTP对应的TCP进行优化的方案：</li><li>并行连接：浏览器并发发起HTTP请求</li><li>TCP持久连接：HTTP1.1中默认使用了持久连接。而在HTTP1.0中需要加上Connection: Keep-Alive 首部</li><li>管道化连接：现在HTTP1.1中还可以在持久的TCP链接上发送多个请求</li></ul><h3 id="第二部分-HTTP结构"><a href="#第二部分-HTTP结构" class="headerlink" title="第二部分 HTTP结构"></a>第二部分 HTTP结构</h3><h4 id="5-Web服务器"><a href="#5-Web服务器" class="headerlink" title="5 Web服务器"></a>5 Web服务器</h4><ul><li>高性能的Web服务器能够同时支持数千条连接。 因为请求可能会在任意时刻到达,所以Web服务器会不停地观察有无新的Web请求。不同的Web服务器结构会以不同的方式为请求服务。服务器一般分为一下几种：（1）单线程Web服务器（2）多进程及多线程Web服务器 （3）复用 I/O 的服务器（4）复用的多线程Web服务器</li></ul><h4 id="7-缓存"><a href="#7-缓存" class="headerlink" title="7 缓存"></a>7 缓存</h4><ul><li>缓存命中、再验证命中。再验证命中需要向服务端请求数据，如果没有改变就是回传一个304、如果改变了就回传新内容并更新缓存、如果资源被删除就返回404并删除缓存</li><li>缓存在现实中是分层次的，如果小的缓存没有命中会把请求发向父级缓存</li><li>HTTP的资源附带有过期日期，它是通过Cache-Control首部和Expires 首部告知客户端。当缓存在过期日期之内可以无限次使用缓存，如果过期则会进行再验证。验证如果发现内容没有变化会获取新的首部（包含新的过期日期）</li><li>条件方法进行再验证：If-Modified-Since:日期  和 If-None-Match:ETag首部</li><li>ETag是为了解决经常被修改，但是文件本身内容却不会变化或者变化不大的情况。这时候通过Etag给资源一个标示符，然后通过标示符来检测文档是否变化</li><li>响应首部Cache-Control的取值:no-store禁止存储副本、no-cache会存储副本，但是只有进行再验证后才会回送、must-revalidate、max-age</li></ul><h3 id="第三部分-识别、认证与安全"><a href="#第三部分-识别、认证与安全" class="headerlink" title="第三部分 识别、认证与安全"></a>第三部分 识别、认证与安全</h3><ul><li>Cookies。服务端在相应首部使用Set-cookie可以让浏览器在本地设置Cookies</li><li>HTTP提供了一个原生的质询 / 响应(challenge/response)框架,简化了对用户的认<br>证过程。 但是这个认证安全性太弱了，所以现在提出了摘要认证。不过这个摘要认证的安全性也比较弱</li><li>数字签名。RSA的私钥和公钥可以互相加解密，RSA证明了签名的作者，而摘要算法保证了内容的真实性</li><li>数字证书的真实性由数字签名保证，而数字证书的作用是清晰而真实地公开一个实体所持有的RSA公钥</li><li>不要在自己的系统里面轻易的安装非CA签发的证书</li></ul>]]></content>
    
    <summary type="html">
    
      HTTP是人类科技史上伟大的发明
    
    </summary>
    
      <category term="CS基础" scheme="http://petpwiuta.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>What&#39;s New in iOS</title>
    <link href="http://petpwiuta.github.io/2016/09/16/What&#39;s-New-in-iOS10/"/>
    <id>http://petpwiuta.github.io/2016/09/16/What&#39;s-New-in-iOS10/</id>
    <published>2016-09-16T08:01:19.000Z</published>
    <updated>2016-10-08T07:29:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS10出现了很多新特性，这些新特性在官方的《What’s New in iOS》文章中做了一个综合性的简介。作为iOS开发者有必要对系统的新特性做一下跟进，所以就把上述提到的那篇文章翻译了一下，希望能对大家有所帮助！</p><h2 id="What’s-New-in-iOS"><a href="#What’s-New-in-iOS" class="headerlink" title="What’s New in iOS"></a>What’s New in iOS</h2><p>这篇文章汇总了在iOS10上引入的关于开发方面的重要新特性，也讲了一些关于新特性的细节。</p><p>如果想了解最前沿的新闻和已知的issues可以去看<a href="https://developer.apple.com/ios/download/" target="_blank" rel="external">iOS10 Release Notes</a>。至于iOS10新APIs列表，可以看<a href="https://developer.apple.com/library/content/releasenotes/General/iOS10APIDiffs/index.html" target="_blank" rel="external">iOS 10.0 API Diffs</a>。想了解新设备的细节可以去看<a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="external">iOS Device Compatibility Reference</a>。</p><p>关于Swift的更新可以看<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/WhatsNewXcode/introduction.html#//apple_ref/doc/uid/TP40004635-SW3" target="_blank" rel="external">Swift Language</a>和<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external">The Swift Programming Language (Swift 3)</a>。</p><h3 id="触觉反馈"><a href="#触觉反馈" class="headerlink" title="触觉反馈"></a>触觉反馈</h3><p>在iPhone7和iPhone 7plus上，触觉反馈是一种获取用户注意力和增加交互沉浸感的新方式(可以理解为Force Touch的进一步运用。译者注)，像系统提供的pickers、switches和sliders都已经具有了触觉反馈特性。</p><p>UIKit引入了<code>UIFeedbackGenerator</code>类以及相关的3个子类来提供触觉反馈功能，不同的子类对应不同的触觉反馈场景，详情见下表。</p><p><img src="/images/Haptic-feedback.png" alt=""></p><p>另外你可以调用UIFeedbackGenerator的实例方法<code>prepare</code>来通知系统在经过一小段延迟后生成触觉反馈。</p><h3 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h3><p>Siri现在可以和App集成在一起了，不过只能支持特定类型的App。App集成Siri的方式是用<code>Intents</code>和<code>Intents UI frameworks</code>建立一个或多个应用扩展。下面是Siri支持的App类型：</p><ul><li>音频视频电话</li><li>短信</li><li>支付</li><li>照片搜索</li><li>打车</li><li>锻炼(可能是让手机开始记录你的健身活动，译者注)</li><li>调整设置(只能在支持CarPlay的汽车上，这个是提供给汽车厂商的)</li><li>预定餐厅(需要Apple的额外支持)</li></ul><p>当用户的Siri指令涉及到你的服务时，SiriKit会给你的App扩展发送一个<code>Intent</code>对象，它描述了用户的指令以及相关的信息。你需要根据<code>Intent</code>对象做出具体处理用户指令的应答。一般情况下Siri会接管所有的用户交互，但你也可以自定义UI来显示更多的信息以及增加品牌曝光 。</p><p>SiriKit提供了一个接收App内部发生的交互和活动数据的机制。并定义了一个interaction的对象，这个对象包含了之前说到的<code>Intent</code>对象以及诸如指令开始处理的时刻和持续时间等<code>intent-handling</code>过程的信息。如果App注册的可处理的活动类型刚好与用户的intent同名，即使你没有开发Siri应用扩展，系统也会启动你的App，并发送相关的Siri事件信息。</p><p>虽说用户通过地图App和Siri都可以打车，而且还能在地图App里订餐。但你的Intent扩展无论是处理从地图App发起的请求还是从Siri发起的，其方式完全一样。当然，你如果是自定义UI的话，仍可以根据不同的来源定制不同的UI。</p><p>想进一步了解SiriKit并给用户一种新方式使用你的服务，可以看<a href="https://developer.apple.com/library/content/documentation/Intents/Conceptual/SiriIntegrationGuide/index.html#//apple_ref/doc/uid/TP40016875" target="_blank" rel="external">SiriKit Programming Guide</a>。想了解如何开发<code>Intents</code>扩展可以看<a href="https://developer.apple.com/reference/intents" target="_blank" rel="external">Intents Framework Reference</a>和<a href="https://developer.apple.com/reference/intentsui" target="_blank" rel="external">Intents UI Framework Reference</a>。</p><h3 id="基于场景的智能推荐"><a href="#基于场景的智能推荐" class="headerlink" title="基于场景的智能推荐"></a>基于场景的智能推荐</h3><p>iOS10引入了一种新的方式来增加用户体验，那就是基于场景的智能推荐。如果你提供适当的场景信息的话，系统就可以在合适的时机展示你的App。如果你曾适配过iOS9的App搜索，你就明白如何通过Spotlight、Safari搜索结果、Handoff和Siri建议来展示App内容数据。在iOS10以后，你可以提供用户在App内的活动信息来帮助系统在其他地方展示你的App，例如键盘的词汇联想区、地图、CarPlay、应用切换列表(双击Home键切换应用的那个界面，译者注)、Siri交互界面和锁屏界面(仅对音视频App)。这些和系统深度整合的功能由NSUserActivity，Web<br>markup，Core Spotlight、MapKit、UIKit和Media Player等技术提供。</p><p>在iOS10，NSUserActivity对象包含了mapItem属性，它能让你提供用于其他场景的位置信息。例如，你的App显示了一个酒店的信息，你可以在mapItem属性里保存酒店的地理位置信息，当用户切换到一个行程规划App中时，你刚刚保存的酒店地理位置信息会自动提供给它。如果你的App支持应用内搜索，你可以在CSSearchableItemAttributeSet中使用新的基于文本的地址属性，比如<code>thoroughfare</code>和<code>postalCode</code>，来完整地描述用户想去的地理位置。另外注意当你使用mapItem属性时，系统会自动把它的内容填充到contentAttributeSet属性中。</p><p>如果要共享一个地理位置信息给系统的话，一定要提供经纬度信息，以及指定CSSearchableItemAttributeSet中的地址属性。另外也建议提供 namedLocation属性，用户能看到位置的名字当然是最好的；此外还有phoneNumbers属性，如果指定了它的值的话，用户可以直接用Siri拨打这个电话。</p><p>在iOS9上，给应用内容的镜像站点上添加Web Markup信息可以让用户在Spotlight和Safari搜索结果中直接查看App的内容数据。在iOS10上你可以使用定义在Schema.org上的地理位置相关的词汇，如PostalAddress来进一步提高用户体验。例如，当用户查看你的网站上显示的一个位置时，如果用户切换到地图应用，系统会自动显示这个位置的提示。对于Schema.org上的词汇，Safari同时支持JSON-LD和Micordata编码。</p><p>UIKit在UITextInputTraits协议中引入了textContentType属性。你可以告诉系统希望用户在文本框所输入内容的含义。当你提供了这些信息以后，系统能在某些场合自动切换到适当类型的键盘以及增进智能推荐的效果。例如，如果你指定UITextContentTypeFullStreetAddress属性来告诉系统你希望用户输入的是一个地址，系统就会自动提示用户最近所浏览的地址信息。</p><p>如果你是媒体播放器类型的App，并且使用了<code>MPPlayableContentManager</code>APIs，在iOS10以后，能让用户在锁屏界面就直接通过你的App播放媒体。</p><p>如果你是ride-sharing类型的App，并且使用了<code>MKDirectionsRequest</code>API，iOS10以后，当用户想开始行程时能在应用切换界面显示这个App。想要注册ride-share provider，只需要在Info.plist文件中增加<code>MKDirectionsApplicationSupportedModes</code>字段并把值设为<code>MKDirectionsModeRideShare</code>就可以了。如果你的App仅仅支持ride sharing，系统显示的建议的文字会以“Get a ride to…”开头；如果你的App同时支持ride sharing和其他种类的交通路线(比如骑行或者驾车)系统显示的建议的文字会以“Get directions to…”开头。注意你接收到的MKMapItem对象可能不包含经纬度信息，需要手动获取。</p><h3 id="Messages-App扩展"><a href="#Messages-App扩展" class="headerlink" title="Messages App扩展"></a>Messages App扩展</h3><p>在iOS10后，你可以创建和Messages App进行交互的App扩展。它能让用户发送文本、表情、媒体文件以及已读反馈。如果把扩展标记为<code>#images</code>类型，那扩展内的表情(图片)资源就会成为公开的，苹果可以对这些公开的表情进行索引和热度排行。</p><p>Messages App的扩展有下面两种：</p><ul><li>表情包</li><li>在Messages App内能展现自定义UI的<code>iMessage app</code>，能让用户浏览表情、文本和媒体文件，并创建、发送以及更新消息</li></ul><p><code>iMessage app</code>可以让用户直接在Messages App内部直接搜索应用内容的镜像站点上的图片。</p><p>创建表情包很简单根本不用敲代码，只要在Xcode里把表情包图片文件夹拖到asset catalog中就行了。</p><p>开发一个<code>iMessage app</code>需要使用<code>Messages.framework</code>，Messages framework的详细信息参见<a href="https://developer.apple.com/reference/messages" target="_blank" rel="external">Messages Framework Reference</a>。至于如何创建一个扩展可以看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="external">App Extension Programming Guide</a>。</p><p><code>#images app</code>展示了当前最火的表情。你在扩展中公开的表情资源经过苹果的爬虫(如Applebot)收录后会被展示到<code>#images app</code>里。经过下面这几个步骤就能把扩展注册为<code>#images app</code>类型：</p><ul><li>创建一个<code>iMessage app</code></li><li>在app的entitlements里添加<code>com.apple.developer.associated-domains</code>字段。包含了你想要被收录的表情(图片)所在的站点的域名列表。每个域名都需要以<code>spotlight-image-search</code>开头，例如<code>spotlight-image-search:yourdomain.com</code></li><li>表情(图片)所在的站点上添加一个以<code>apple-app-site-association</code>命名的字典文件(key-val结构，比如json，译者注)。里面需要包含你的app ID(以team ID或者app ID为前缀)和bundle ID。一个<code>#images</code>索引最多能包含500个paths和patterns(website paths的例子可以看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW4" target="_blank" rel="external">Creating and Uploading the Association File</a>)</li><li>允许Applebot进行收录(参见<a href="https://support.apple.com/en-us/HT204683" target="_blank" rel="external">About Applebot</a>)</li></ul><h3 id="推送通知"><a href="#推送通知" class="headerlink" title="推送通知"></a>推送通知</h3><p>iOS10引入了全新的推送通知框架(UserNotifications.framework)，它统一了本地通知和远程推送通知。你可以用新框架根据时间和地点等条件触发的本地通知。现在这个框架还能在设备收到通知后让你拦截和修改通知的内容。</p><p>除了上面说的外在iOS10还引入了推送通知UI框架(UserNotificationsUI.framework) ，当通知到达设备上时可以显示自定义的UI了。而且可以开发对应的扩展来响应用户对通知的操作。</p><h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><p>iOS10引入了新的连续语音识别框架<code>Speech.framework</code>，除了语音识别外还能把语音转换成文字。另外语音识别和录音可以同时进行。下面是示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let recognizer = SFSpeechRecognizer()</div><div class="line">let request = SFSpeechURLRecognitionRequest(url: audioFileURL)</div><div class="line">recognizer?.recognitionTask(with: request, resultHandler: &#123; (result, error) in</div><div class="line">     print (result?.bestTranscription.formattedString)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>语音识别中为了提高识别率，苹果会把用户的语音数据临时保存在服务器上，所以算是获取到了用户的隐私数据(关于访问用户的隐私数据的细节可以看<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW3" target="_blank" rel="external">Security and Privacy Enhancements</a>)，所以这里需要用户的授权。获取语音识别的授权需要在Info.plist文件里增加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW52" target="_blank" rel="external">NSSpeechRecognitionUsageDescription</a>字段，内容就是你对数据用途的描述。</p><p>另外当你在进行语音识别时记得加上明确的UI引导，这样用户体验会更好。</p><h3 id="广色域"><a href="#广色域" class="headerlink" title="广色域"></a>广色域</h3><p>系统中大量的图形组件，如Core Graphics、Core Image、Metal和AVFoundation等现在支持更大的色彩空间。UIKit现在已经集成了这个新特性。<br>下面是使用广色域特性的最佳实践：</p><ul><li>在iOS10上，<code>[UIColor](https://developer.apple.com/reference/uikit/uicolor)</code>使用了扩展的sRGB色彩空间，initializers no longer clamp raw component values to between 0.0 and 1.0. If your app relies on UIKit to clamp component values (whether you’re creating a color or asking a color for its component values), you need to change your app’s behavior when you link against iOS 10.</li><li>iPad Pro(9.7寸)上在UIView自定义draw方法时，色彩空间默认就是扩展的sRGB</li><li>如果需要渲染自定义图片对象，使用<a href="https://developer.apple.com/reference/uikit/uigraphicsimagerenderer" target="_blank" rel="external">UIGraphicsImageRenderer</a>来控制生成的位图的色彩空间是extended-range还是standard-range</li><li>如果在支持宽色域的设备上用Core Graphics、Metal等底层API处理图片，应该用扩展的色彩空间并且要用16位的floating-point component values. When clamping of color values is necessary, you should do so explicitly</li><li>Core Graphics、Core Image和Metal执行Shaders时提供了转换颜色和图片的色彩空间的功能</li></ul><h3 id="True-Tone-Display适配"><a href="#True-Tone-Display适配" class="headerlink" title="True Tone Display适配"></a>True Tone Display适配</h3><p>True Tone display利用环境光传感器根据用户周边的光照自动调整色彩和显示强度。为了True Tone在标准色上产生的色彩偏移不会给应用带来负面影响，可以在Info.plist添加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW31" target="_blank" rel="external">UIWhitePointAdaptivityStyle</a>字段，并指定适当的类型，例如：</p><ul><li>如果你的应用是照片编辑类的，对色彩精准地还原才是重中之重。可以指定类型为UIWhitePointAdaptivityStylePhoto来减少True Tone产生的色彩偏移</li><li>如果你的应用是阅读类的，舒适的阅读环境对用户最重要。可以指定指定类型为UIWhitePointAdaptivityStyleReading来增加True Tone产生的色彩偏移</li></ul><h3 id="App-Search增强"><a href="#App-Search增强" class="headerlink" title="App Search增强"></a>App Search增强</h3><p>iOS10上Core Spotlight框架得到了一些增强：</p><ul><li>应用内搜索</li><li>Search continuation</li><li>Crowdsourcing deep link popularity with differential privacy</li><li>Visualization of validation results</li></ul><p>新的<a href="https://developer.apple.com/reference/corespotlight/cssearchquery" target="_blank" rel="external">CSSearchQuery</a>类支持应用内搜索。使用这个API可以避免自己维护内容索引，并能马上能利用Spotlight技术带来的便利，类似于，邮件、短信和备忘录的搜索，这个完全是在应用内进行。</p><p>在iOS9，通过搜索APIs(比如Core Spotlight、NSUserActivity还有web markup)来索引应用内的内容后，用户就能通过Spotlight和Safari搜索来使用它。在iOS10上，Core Spotlight功能进一步增强。当用户通过搜索特定内容启动App时，可以得知用户搜索的内容，并显示出相应的数据。在Info.plist中增加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW43" target="_blank" rel="external">CoreSpotlightContinuation</a>字段并设置为YES就可以启用这个特性。另外需注意如果开启这个特性需要实现对<a href="https://developer.apple.com/reference/corespotlight/csquerycontinuationactiontype" target="_blank" rel="external">CSQueryContinuationActionType</a>类型的activity continuation的处理逻辑。<a href="https://developer.apple.com/reference/uikit/uiapplicationdelegate/1623072-application" target="_blank" rel="external">application:continueUserActivity:restorationHandler:</a>方法回传的<a href="https://developer.apple.com/reference/foundation/nsuseractivity" target="_blank" rel="external">NSUserActivity</a>对象包含了用户信息，通过<a href="https://developer.apple.com/reference/corespotlight/cssearchquerystring" target="_blank" rel="external">CSSearchQueryString</a>可以取到用户的搜索关键字。</p><p>iOS10引入了更具隐私的技术来提高你的App内容在用户搜索中的曝光率。新引入的<a href="https://developer.apple.com/reference/foundation/nsuseractivity/1414701-iseligibleforpublicindexing" target="_blank" rel="external">eligibleForPublicIndexing</a>属性可以告诉系统是否把指定内容设为公共的(所有iOS用户都可以查看,译者注)，当用户使用App或者<a href="https://developer.apple.com/reference/foundation/nsuseractivity" target="_blank" rel="external">NSUserActivity</a>包含一个<code>deep link</code>时，如果它们的<code>eligibleForPublicIndexing</code>被设置成了YES，系统就会把对应的数据经过信息哈希算法生成内容摘要(内容摘要是不包含用户数据的字符串，不能反向还原出原内容，译者注)，然后发送到苹果的服务器。苹果的服务器只用统计这些内容摘要的使用频率就能算出热度排行，从而对搜索进行排名，这个过程完全不涉及到具体的用户数据。</p><p>当你用App搜索有效性验证工具测试你的website markup和deep links时，它现在有更人性化的视觉展示了。包括支持的markup(具体定义在<a href="http://schema.org/" target="_blank" rel="external">Schema.org</a>上)。这个工具能查看Applebot对你的应用内容的具体收录信息，类似于title、description、URL以及其他的元素。App搜索有效性验证工具在这里：<a href="https://search.developer.apple.com/appsearch-validation-tool。如果想了解如何支持`deep" target="_blank" rel="external">https://search.developer.apple.com/appsearch-validation-tool。如果想了解如何支持`deep</a> links<code>和</code>markup`可以看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8" target="_blank" rel="external">Mark Up Web Content</a>。</p><p>想要了解如何让Messages app内的表情(图片)可以被外部搜索到，可以看<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW4" target="_blank" rel="external">Integrating with the Messages App</a>。</p><h3 id="Widget增强"><a href="#Widget增强" class="headerlink" title="Widget增强"></a>Widget增强</h3><p>iOS10重新设计了锁屏界面，现在从锁屏界面右滑就能看见widgets。为了保证widget在各种背景下都好看，需要根据情况调用<a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1771278-widgetprimaryvibrancyeffect" target="_blank" rel="external">widgetPrimaryVibrancyEffect</a>或<a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1771277-widgetsecondaryvibrancyeffect" target="_blank" rel="external">widgetSecondaryVibrancyEffect</a>(这两个方法会替代即将废弃的<a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1613917-notificationcentervibrancyeffect" target="_blank" rel="external">notificationCenterVibrancyEffect</a>)。另外widgets现在新增加了显示模式的概念(通过<a href="https://developer.apple.com/reference/notificationcenter/ncwidgetdisplaymode" target="_blank" rel="external">NCWidgetDisplayMode</a>属性获取显示模式)，需要你根据用户选择的模式显示合适的内容。(现在就是”展开”、”收起”两种模式，需要根据用户的选择，来显示较少或更多的内容，译者注)。</p><h3 id="Apple-Pay增强"><a href="#Apple-Pay增强" class="headerlink" title="Apple Pay增强"></a>Apple Pay增强</h3><p>iOS10以后用户可以在网站上使用Apple Pay，还能直接用Siri和地图下达支付命令。对于开发者而言，iOS10引入了同时支持iOS和watchOS的新API，并且支持随时更换银行卡和新沙盒测试环境。</p><p>iOS10引入的新API可以直接集成到网站上，当网站集成好Apple Pay后，用户通过Safari(iOS和macOS都行)浏览时就能用Apple Pay付款。想要了解更多关于网站集成Apple Pay的知识可以看<a href="https://developer.apple.com/reference/applepayjs" target="_blank" rel="external">ApplePay JS Framework Reference</a>。</p><p>PassKit框架(PassKit.framework)引入的新API不依赖UIkit。比如PKPaymentAuthorizationController和PKPaymentAuthorizationControllerDelegate的特性是由PKPaymentAuthorizationViewController和它的委托来实现的。但它也不需要导入UIKit。 尽管是为了让watchOS和其他情况使用Apple Pay而设计的这些API，但建议实现一套统一的代码框架来适配Apple Pay的所有使用场景(Siri、网站、地图，译者注)。想要了解更多关于Siri集成的知识可以看<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW5" target="_blank" rel="external">SiriKit</a>。</p><p>PassKit还有一项新特性。就是让发卡商家从他们的应用中显示卡片。<code>PKPaymentButtonTypeInStore</code>类型的button可以给卡片显示Apple Pay的标志。实现<code>presentPaymentPass:</code>方法就能显示卡片。(<code>presentPaymentPass:</code>方法在<a href="https://developer.apple.com/reference/passkit/pkpasslibrary" target="_blank" rel="external">PKPassLibrary</a>中定义)。</p><p>当有新的行银片绑定时，应用能自动适应而不需要重新发版。<a href="https://developer.apple.com/reference/passkit/pkpaymentrequest/1833288-availablenetworks" target="_blank" rel="external">availableNetworks</a>方法可以查询当前可用的银行卡。另外<a href="https://developer.apple.com/reference/passkit/pkpaymentrequest/1619329-supportednetworks" target="_blank" rel="external">supportedNetworks</a>属性可以限定所支持的银行卡。想了解更多关于Apple Pay的知识可以去：<a href="https://developer.apple.com/apple-pay/。" target="_blank" rel="external">https://developer.apple.com/apple-pay/。</a></p><p>iOS10引入了新的测试技术，可以直接在设备上添加测试卡片。测试环境返回加密的支付数据。需要下面几步来开启测试环境：<br>1<em> 在iTunes Connect上新建一个iCloud测试账号<br>2</em> 在设备上登录测试账号<br>3<em> 设置这个账号所在的地区<br>4</em> 使用<a href="https://developer.apple.com/apple-pay/上列出的银行卡测试" target="_blank" rel="external">https://developer.apple.com/apple-pay/上列出的银行卡测试</a></p><p>注意：如果切换iCloud账号，测试环境也会自动切换。所以最好用真实的卡片在生产环境上测试。</p><h3 id="安全和隐私的增强"><a href="#安全和隐私的增强" class="headerlink" title="安全和隐私的增强"></a>安全和隐私的增强</h3><p>iOS10增强了代码的安全性以及用户数据的安全性。想了解更多可以看：<a href="https://developer.apple.com/security/。" target="_blank" rel="external">https://developer.apple.com/security/。</a></p><ul><li>如果应用启用了ATS，但又想在加载web内容的时候使用非安全连接。只需要在Info.plist中添加<code>NSAllowsArbitraryLoadsInWebContent</code>字段就行</li><li><code>SecKey</code>API增强了非对称加密key的生成。请使用<code>SecKey</code>API来替代废弃的Common Data Security Architecture (CDSA) APIs</li><li>SSL/TLS中已经默认禁用RC4对称加密算法了，而且Secure Transportations API未来也不会再支持SSLv3。建议尽可能地使用SHA-1和3DES加密算法</li><li>在iOS10上出现了可以在多台登录iCloud的设备上互相复制粘贴的功能(<a href="https://developer.apple.com/reference/uikit/uipasteboard" target="_blank" rel="external">UIPasteboard</a>)。你可以针对指定的设备把剪贴板功能做限制以及给剪贴板加上超时时间(超过时间不使用里面的内容，剪贴板就会被清空)。另外具名剪贴板不再被持久化了，作为替代你现在可以用共享式的容器。还有就是”Find”剪贴板(通过<a href="https://developer.apple.com/reference/uikit/uipasteboardnamefind" target="_blank" rel="external">UIPasteboardNameFind</a>获取)从iOS10开始被禁用了。</li><li>现在访问用户受保护的数据都需要在Info.plist里添加对应的字段，并附上对数据的用途的描述。例如如果要访问日历数据的话就需要在Info.plist中添加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW15" target="_blank" rel="external">NSCalendarsUsageDescription</a>并写上你用日历数据的目的。如果未经允许就读取数据会造成应用闪退。</li></ul><h3 id="CallKit"><a href="#CallKit" class="headerlink" title="CallKit"></a>CallKit</h3><p>CallKit框架(CallKit.framework)现在允许VoIP应用的呼入直接通过系统来电UI展现出来。这样用户就能直接在锁屏界面接听或拒绝VoIP呼叫，并且这个呼叫会被记录在最近通话之中。</p><p>CallKit还引入了来电拦截和骚扰电话识别扩展。利用这些扩展可以根据系统给定的电话号码给出具体的提示或者告诉系统这个电话是否该被拦截。</p><h3 id="News-Publisher增强"><a href="#News-Publisher增强" class="headerlink" title="News Publisher增强"></a>News Publisher增强</h3><p>News Publisher现在可以很容易地通过Apple News向用户提供新闻、杂志以及web内容。无论是主流杂志和新闻机构还是独立的记者和博客，任何人都可以注册为News Publisher。想要了解更多关于这方面的信息可以看：<a href="https://newsresources.apple.com。" target="_blank" rel="external">https://newsresources.apple.com。</a></p><h3 id="视频订阅账户"><a href="#视频订阅账户" class="headerlink" title="视频订阅账户"></a>视频订阅账户</h3><p>iOS10引入了视频订阅账户框架(VideoSubscriberAccount.framework)来帮助支持授权流媒体/视频的应用从有线电视/卫星电视供应商获取授权。使用这个框架可以达到多个视频应用一键登录的效果(必须是支持VideoSubscriberAccount的应用)，大大提升了用户体验。</p><h3 id="App扩展"><a href="#App扩展" class="headerlink" title="App扩展"></a>App扩展</h3><p>iOS10引入了多个新类型的App扩展：</p><ul><li>Call Directory</li><li>Intents</li><li>Itents UI</li><li>Messages</li><li>Notification Content</li><li>Notification Service</li><li>Sticker Pack</li></ul><p>另外，iOS10还包含了对第三方键盘的一些增强：</p><ul><li>可以用<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy" target="_blank" rel="external">UITextDocumentProxy </a>来检测用户正在输入的语言，并据此调整键盘。</li><li>新增的handleInputModeListFromView:withEvent:方法能显示系统的键盘切换按钮</li></ul><p>虽然你能自定义输入法切换按钮的外观，但这个按钮一定要放到和系统键盘一样的位置。想要了解关于应用扩展的信息可以看：<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="external">App Extension Programming Guide</a></p><h3 id="其他框架的改动"><a href="#其他框架的改动" class="headerlink" title="其他框架的改动"></a>其他框架的改动</h3><p>除了上述的主要改动外，iOS10还包含了其他的改进。</p><h5 id="AVFoundation-Camera-Capture"><a href="#AVFoundation-Camera-Capture" class="headerlink" title="AVFoundation Camera Capture"></a>AVFoundation Camera Capture</h5><p>AVFoundation框架(AVFoundation.framework)中的媒体采集组件包含了多项重要改进。</p><h6 id="Dual-Camera-and-Device-Discovery"><a href="#Dual-Camera-and-Device-Discovery" class="headerlink" title="Dual Camera and Device Discovery"></a>Dual Camera and Device Discovery</h6><p>iPhone7 plus的相机有2个镜头，一个为广角镜一个为长焦镜，但它们组合在一起成为一个双镜头相机。当使用这个双镜头相机时，iOS根据环境和设置自动地使用两者或者其中某一个。当你通过<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice" target="_blank" rel="external">AVCaptureDevice</a>来拍照或录视频时可以选择双镜头相机(iOS自动调整两个镜头的使用)或者单独指定是广角镜还是长焦镜。</p><p>在iOS10以后可以通过下面的方法使用摄像机：</p><ul><li>调用<code>defaultDeviceWithDeviceType:mediaType:position:</code>方法。  (指定<code>AVCaptureDeviceTypeBuiltInDuoCamera</code>参数启用双镜头相机。如果返回值为nil，说明设备上没有双镜头相机；指定<code>AVCaptureDeviceTypeBuiltInWideAngleCamera</code>参数启用默认的后置相机)</li><li>实例化一个<code>AVCaptureDeviceDiscoverySession</code>对象，指定相关的参数，并从设备列表中选择想要使用的摄像机</li></ul><p>注意：<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice" target="_blank" rel="external">AVCaptureDevice</a>的<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice/1386237-devices" target="_blank" rel="external">devices</a>和<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice/1390520-deviceswithmediatype" target="_blank" rel="external">devicesWithMediaType:</a>方法在iOS10被弃用。并且不提供访问双镜头相机和广角镜相机的方法。</p><p>当使用双镜头相机时，RAW格式和大部分手动控制特性都暂时不可用。这两个特性必须在单镜头相机上才能开启。关于每个镜头的性能参数可以看<a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="external">iOS Device Compatibility Reference</a>。</p><h6 id="New-Photo-Capture-API"><a href="#New-Photo-Capture-API" class="headerlink" title="New Photo Capture API"></a>New Photo Capture API</h6><p>新的<a href="https://developer.apple.com/reference/avfoundation/avcapturephotooutput" target="_blank" rel="external">AVCapturePhotoOutput</a>类为图片处理提供了统一的方案。这个方案能提供更细粒度的控制，监听整个采样过程以及支持新的Live Photos、RAW格式等新特性。建议用它替换<a href="https://developer.apple.com/reference/avfoundation/avcapturestillimageoutput" target="_blank" rel="external">AVCaptureStillImageOutput</a>(AVCaptureStillImageOutput在iOS10已经废弃)。</p><h6 id="Wide-Color"><a href="#Wide-Color" class="headerlink" title="Wide Color"></a>Wide Color</h6><p>摄像机采样现在已经支持输出宽色域数据(需要在支持宽色域的设备，译者注)。默认情况下<a href="https://developer.apple.com/reference/avfoundation/avcapturesession" target="_blank" rel="external">AVCaptureSession</a>会自动配置是否启用宽色域，具体的细节可以看：<a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="external">iOS Device Compatibility Reference</a></p><h5 id="AVFoundation-Media"><a href="#AVFoundation-Media" class="headerlink" title="AVFoundation Media"></a>AVFoundation Media</h5><p>AVFoundation框架(AVFoundation.framework)中的媒体播放和编辑组件包含了下列改进：</p><ul><li>不用再根据内容是视频文件还是HTTP流媒体来设置不同的<a href="https://developer.apple.com/reference/avfoundation/avplayeritem" target="_blank" rel="external">AVPlayerItem</a>了。在iOS10以后，仅仅需要设置<a href="https://developer.apple.com/reference/avfoundation/avplayer/1388846-rate" target="_blank" rel="external">rate</a>属性，AVFoundation会自动进行后续的配置</li><li>新的<a href="https://developer.apple.com/reference/avfoundation/avplayerlooper" target="_blank" rel="external">AVPlayerLooper</a>类让重复播放媒体的部分内容变更容易(就是复读机功能，译者注)</li><li>用<a href="https://developer.apple.com/reference/avfoundation/avassetdownloadurlsession" target="_blank" rel="external">AVAssetDownloadURLSession</a>类来离线媒体资源，包括HTTP流媒体等(离线到设备上，然后无网的时候也能看，译者注)。它跟FairPlay Streaming结合在一起时还能离线加密的HTTP流媒体</li></ul><h5 id="AVKit"><a href="#AVKit" class="headerlink" title="AVKit"></a>AVKit</h5><p>AVKit框架(AVKit.framework)，包含了<code>updatesNowPlayingInfoCenter</code>属性，可以调用它来刷新<code>Now Playing Info Center</code>。</p><h5 id="Core-Data"><a href="#Core-Data" class="headerlink" title="Core Data"></a>Core Data</h5><p>Core Data框架(CoreData.framework)包含了下列改进：</p><ul><li><a href="https://developer.apple.com/reference/coredata/nspersistentstorecoordinator" target="_blank" rel="external">NSPersistentStoreCoordinator</a>现在维护了一个SQLite连接池。<a href="https://developer.apple.com/reference/coredata/nsmanagedobjectcontext" target="_blank" rel="external">NSManagedObjectContext</a>对象(没有父MOCs)透明地支持并发查询and faulting without serializing against each other.</li><li><a href="https://developer.apple.com/reference/coredata/nsmanagedobjectcontext" target="_blank" rel="external">NSManagedObjectContext</a>对象和SQLite存储在WAL文件里，<code>journal_model</code>支持现在支持query generation特性。These allow a MOC to be pinned to a version of the database at a point in time and perform all future fetching and faulting against that version of the database. Pinned MOCs are moved to the most recent transaction with any save, and query generations do not survive the process’s life time.</li><li>新的<a href="https://developer.apple.com/reference/coredata/nspersistentcontainer" target="_blank" rel="external">NSPersistentContainer</a>类提供了高层API来维护对<code>NSPersistentStoreCoordinator</code>和<a href="https://developer.apple.com/reference/coredata/nsmanagedobjectmodel" target="_blank" rel="external">NSManagedObjectModel</a>以及其他配置源的引用</li><li>Core Data现在进一步地与Xcode集成在一起。并能自动生成和更新<a href="https://developer.apple.com/reference/coredata/nsmanagedobject" target="_blank" rel="external">NSManagedObject</a></li><li><code>NSManagedObject</code>包含了多个获取和创建其子类的快捷方法。<code>NSManagedObject</code> subclasses that have a 1:1 relationship with an entity now support <code>entity</code>.</li><li>Core Data对API进行了一些Swift friendly式的调整，包括像参数化的<a href="https://developer.apple.com/reference/coredata/nsfetchrequest" target="_blank" rel="external">NSFetchRequest</a>对象</li></ul><p>更多信息参见<a href="https://developer.apple.com/reference/coredata" target="_blank" rel="external">Core Data Framework Reference</a></p><h5 id="Core-Image"><a href="#Core-Image" class="headerlink" title="Core Image"></a>Core Image</h5><p>Core Image框架(CoreImage.framework)包含了下面这些改进。</p><p>搭载A8、A9CPU的设备开始支持RAW格式的图片。对于第三方相机产生的RAW格式的图片CoreImage也能很好地支持，使用RAW格式的图片需要调用<a href="https://developer.apple.com/reference/coreimage/cifilter/1437879-init" target="_blank" rel="external">filterWithImageData:options:</a>或<a href="https://developer.apple.com/reference/coreimage/cifilter/1438096-init" target="_blank" rel="external">filterWithImageURL:options:</a>来创建一个<a href="https://developer.apple.com/reference/coreimage/cifilter" target="_blank" rel="external">CIFilter</a>对象，再根据RAW Image Options选项调整RAW数据，最后从<a href="https://developer.apple.com/reference/coreimage/cifilter/1438169-outputimage" target="_blank" rel="external">outputImage</a>属性中得到处理后的图片数据。</p><p>现在可以用<a href="https://developer.apple.com/reference/coreimage/ciimage/1639637-withextent" target="_blank" rel="external">imageWithExtent:processorDescription:argumentDigest:inputFormat:outputFormat:options:roiCallback:processor:</a>方法在Core Image滤镜中插入自定义的处理逻辑。这个方法添加了一个回调Block，这个Block会在处理图片数据和输出图片数据之间的一个时刻被调用。在Block里能获取到像素数据或Metal纹理数据，你在这里可以运行自定义的图形算法。</p><p>在写自定义图形处理逻辑或重写滤镜内核时除了Core Image的contex的色彩空间外还能用其他的色彩空间，可以用 <a href="https://developer.apple.com/reference/coreimage/ciimage/1645898-matchedfromworkingspace" target="_blank" rel="external">imageByColorMatchingWorkingSpaceToColorSpace:</a>和<a href="https://developer.apple.com/reference/coreimage/ciimage/1645896-matchedtoworkingspace" target="_blank" rel="external">imageByColorMatchingColorSpaceToWorkingSpace:</a>方法来互相转换。</p><p>在Core Image框架的优化下渲染<a href="https://developer.apple.com/reference/uikit/uiimage" target="_blank" rel="external">UIImage</a>对象的效率得到大幅提升(比如用<a href="https://developer.apple.com/reference/uikit/uiimage/1624114-init" target="_blank" rel="external">initWithCIImage:</a>方法初始化)。另外UIImageView中的宽色域的支持是由它内部的Core Image对象实现的。</p><p>Core Image核心代码现在可以指定输出像素格式。</p><p>Core Image引入了5个新滤镜：</p><ul><li>CINinePartTiled</li><li>CINinePartStretched</li><li>CIHueSaturationValueGradient</li><li>CIEdgePreserveUpsampleFilter</li><li>CIClamp</li></ul><h5 id="Core-Motion"><a href="#Core-Motion" class="headerlink" title="Core Motion"></a>Core Motion</h5><p>Core Motion框架(CoreMotion.framework)引入了计步器事件，它可以实时监听手机用户的运动状态，包括跑步、暂停等。在支持这个特性的设备上可以用<a href="https://developer.apple.com/reference/coremotion/cmpedometer" target="_blank" rel="external">CMPedometer</a>APIs来注册并接受实时计步事件。</p><h5 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h5><p>Foundation框架(Foundation.framework)包含了下列增强：</p><ul><li>新的<a href="https://developer.apple.com/reference/foundation/nsdateinterval" target="_blank" rel="external">NSDateInterval</a>类提供了判断某个时刻是否处于指定的时间段内。</li><li><a href="https://developer.apple.com/reference/foundation/nslocale" target="_blank" rel="external">NSLocale</a>增加了获取本地化信息的属性</li><li>新的<a href="https://developer.apple.com/reference/foundation/nsmeasurement" target="_blank" rel="external">NSMeasurement</a>类能把尺寸转换成不同的单位，并在两种尺寸之间进行计算。新的<a href="https://developer.apple.com/reference/foundation/measurementformatter" target="_blank" rel="external">NSMeasurementFormatter</a>类可以把尺寸进行本地化(转换成当地惯用单位，译者注)</li><li>新的<a href="https://developer.apple.com/reference/foundation/unit" target="_blank" rel="external">NSUnit</a>类以其子类<a href="https://developer.apple.com/reference/foundation/nsdimension" target="_blank" rel="external">NSDimension</a>能表示特定的计量单位</li></ul><h5 id="GameKit"><a href="#GameKit" class="headerlink" title="GameKit"></a>GameKit</h5><p>GameKit框架(GameKit.framework)包含了下列改进：</p><ul><li>Game Center应用现在已经被移除。如果游戏中实现了GameKit特性，需要自定义相关的UI。例如，你的游戏支持排行榜，你可以直接从Game Center获取相关数据并用自定义的视图展示(当然，直接用<a href="https://developer.apple.com/reference/gamekit/gkgamecenterviewcontroller" target="_blank" rel="external">GKGameCenterViewController</a>对象也行)</li><li>新的账户类型，由<a href="https://developer.apple.com/reference/gamekit/gkcloudplayer" target="_blank" rel="external">GKCloudPlayer</a>实现，支持iCloud-only游戏账号</li><li>Game Center对其内部的数据持久化提供了新的解决方案。一个游戏会话(<a href="https://developer.apple.com/reference/gamekit/gkgamesession" target="_blank" rel="external">GKGameSession</a>)拥有参与这个会话的玩家列表。你需要做的是决定何时以及如何从服务端存储和遍历数据或在玩家之间传输数据。游戏会话技术非常适用于回合制比赛、实时比赛以及其他多人互动游戏上</li></ul><h5 id="GameplayKit"><a href="#GameplayKit" class="headerlink" title="GameplayKit"></a>GameplayKit</h5><p>GameplayKit框架(GameplayKit.framework)包含了下列的改进：</p><ul><li>用于增强游戏场景效果的声音合成器。以及看起来更自然的纹理和更真实的相机移动。</li><li>空间隔离减少了游戏数据处理复杂度，让数据搜索效率更高</li><li>新的Monte Carlo策略(<a href="https://developer.apple.com/reference/gameplaykit/gkmontecarlostrategist" target="_blank" rel="external">GKMonteCarloStrategist</a>)类能帮你免除对可能产生的动作进行详尽地计算</li><li>新的决策树API能让游戏的AI设计起来更方便(前提是你的游戏AI是通过玩家行为数据用决策树来生成的)</li><li><a href="https://developer.apple.com/reference/gameplaykit/gkagent3d" target="_blank" rel="external">GKAgent3D</a>和<a href="https://developer.apple.com/reference/gameplaykit/gkgraphnode3d" target="_blank" rel="external">GKGraphNode3D</a>类引入了对existing agent和path-finding的3D支持</li><li><a href="https://developer.apple.com/reference/gameplaykit/gkobstaclegraph" target="_blank" rel="external">GKObstacleGraph</a>有了性能更好的替代品——<a href="https://developer.apple.com/reference/gameplaykit/gkmeshgraph" target="_blank" rel="external">GKMeshGraph</a>它能生成更自然的路径</li><li>新的<a href="https://developer.apple.com/reference/gameplaykit/gkscene" target="_blank" rel="external">GKScene</a>、<a href="https://developer.apple.com/reference/gameplaykit/gksknodecomponent" target="_blank" rel="external">GKSKNodeComponent</a>和SpriteKit以及Xcode editor的结合让集成GameplayKit、SpriteKit变得前所未有地简单</li></ul><h5 id="HealthKit"><a href="#HealthKit" class="headerlink" title="HealthKit"></a>HealthKit</h5><p>HealthKit框架(HealthKit.framework)包含了下列改进：</p><ul><li>新的<a href="https://developer.apple.com/reference/healthkit/hkcdadocument" target="_blank" rel="external">HKCDADocument</a>类，代表CDA文件(遵循Clinical Document Architecture标准的文件)</li><li>新的<a href="https://developer.apple.com/reference/healthkit/hkworkoutconfiguration" target="_blank" rel="external">HKWorkoutConfiguration</a>类，能让你为一项锻炼指定<a href="https://developer.apple.com/reference/healthkit/hkworkoutconfiguration/1649492-activitytype" target="_blank" rel="external">activityType</a>和<a href="https://developer.apple.com/reference/healthkit/hkworkoutconfiguration/1649491-locationtype" target="_blank" rel="external">locationType</a></li><li>新的<a href="https://developer.apple.com/reference/healthkit/hkwheelchairuseobject" target="_blank" rel="external">HKWheelchairUseObject</a>特征对象类型和<a href="https://developer.apple.com/reference/healthkit/hkhealthstore" target="_blank" rel="external">HKHealthStore</a>相关的方法<a href="https://developer.apple.com/reference/healthkit/hkhealthstore/1648356-wheelchairuse" target="_blank" rel="external">wheelchairUseWithError:</a></li><li>新的代表天气的元数据key，比如<a href="https://developer.apple.com/reference/healthkit/hkweathercondition/hkweatherconditionclear" target="_blank" rel="external">HKWeatherConditionClear</a>和<a href="https://developer.apple.com/reference/healthkit/hkweathercondition/hkweatherconditioncloudy" target="_blank" rel="external">HKWeatherConditionCloudy</a>。还有锻炼类的，比如<a href="https://developer.apple.com/reference/healthkit/hkworkoutactivitytype/1649808-flexibility" target="_blank" rel="external">HKWorkoutActivityTypeFlexibility</a>和<a href="https://developer.apple.com/reference/healthkit/hkworkoutactivitytype/hkworkoutactivitytypewheelchairrunpace" target="_blank" rel="external">HKWorkoutActivityTypeWheelchairRunPace</a></li></ul><h5 id="HomeKit"><a href="#HomeKit" class="headerlink" title="HomeKit"></a>HomeKit</h5><p>iOS10以后，iPad可以变成家庭控制中心，允许进行远程访问，运行自动任务触发器以及共享用户授权。另外HomeKit框架(HomeKit.framework)添加了对摄像机和门铃的支持，并引入了很多新API：</p><ul><li>调用并控制网络摄像机，显示实时视频流和截图以及控制摄像机、扬声器和话筒</li><li>Access new services and characteristics</li><li>For the primary service, link services and valid values to provide more context and configuration about the accessories</li></ul><p>现在可以用Apple家居设备设置流程来添加或者设置家居设备。想要了解更多可以看<a href="https://developer.apple.com/reference/homekit" target="_blank" rel="external">HomeKit Framework Reference</a></p><h5 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a>Metal</h5><p>iOS10以后Metal引入了一些新特性并对某些方面进行了增强，比如：</p><ul><li>支持tessellation。允许3D游戏和应用进行更细致地渲染</li><li>函数专精化。这样就能开发出高度优化的函数来处理材质和光照</li><li>资源堆和更小内存的渲染目标。在未来会对资源分配进行更细粒度的控制来优化性能</li></ul><h5 id="ModelIO"><a href="#ModelIO" class="headerlink" title="ModelIO"></a>ModelIO</h5><p>ModelIO框架(ModelIO.framework)包含了下列改进：</p><ul><li>支持USD格式</li><li>新的<code>MDLMaterialPropertyGraph</code>类让运行时修改models更容易</li><li><a href="https://developer.apple.com/reference/modelio/mdlvoxelarray" target="_blank" rel="external">MDLVoxelArray</a>类现在支持signed distance fields</li><li>可以实现<code>MDLLightProbeIrradianceDataSource</code>协议来添加assisted light probe</li></ul><h5 id="Photos"><a href="#Photos" class="headerlink" title="Photos"></a>Photos</h5><p>Photos框架(Photos.framework)现在支持对Live Photo进行编辑了。特别是新<a href="https://developer.apple.com/reference/photos/phlivephotoeditingcontext" target="_blank" rel="external">PHLivePhotoEditingContext</a>类允许你编辑视频和Live Photo中的静态内容。Core Image的性能增强在这里也得以体现，想要了解更多请看<a href="https://developer.apple.com/reference/coreimage/ciimageprocessorinput" target="_blank" rel="external">CIImageProcessorInput</a>和<a href="https://developer.apple.com/reference/coreimage/ciimageprocessoroutput" target="_blank" rel="external">CIImageProcessorOutput</a>。</p><h5 id="ReplayKit"><a href="#ReplayKit" class="headerlink" title="ReplayKit"></a>ReplayKit</h5><p>ReplayKit框架(ReplayKit.framework)包含了下列增强：</p><ul><li>ReplayKit支持广播服务，用户可以通过第三方广播自己的屏幕内容。使用下面这些API就能够集成这个新特性 <a href="https://developer.apple.com/reference/replaykit/rpscreenrecorder" target="_blank" rel="external">RPScreenRecorder</a>、<a href="https://developer.apple.com/reference/replaykit/rpbroadcastactivityviewcontroller" target="_blank" rel="external">RPBroadcastActivityViewController</a>、<a href="https://developer.apple.com/reference/replaykit/rpbroadcastcontroller" target="_blank" rel="external">RPBroadcastController</a></li><li>若要参与ReplayKit广播，第三方广播服务商需要实现相应的应用扩展。这个扩展应该具有让用户接入并配置广播的功能</li></ul><h5 id="SceneKit"><a href="#SceneKit" class="headerlink" title="SceneKit"></a>SceneKit</h5><p>The SceneKit framework (SceneKit.framework) includes several enhancements.</p><p>A new Physically Based Rendering (PBR) system allows you to leverage the latest in 3D graphics research to create more realistic results with simpler asset authoring. Specifically:</p><ul><li><p>Use the new <a href="https://developer.apple.com/reference/scenekit/scnmaterial.lightingmodel/1640553-physicallybased" target="_blank" rel="external">SCNLightingModelPhysicallyBased</a> shading model to opt into PBR shading for materials. PBR materials require only three fundamental properties—<a href="https://developer.apple.com/reference/scenekit/scnmaterial/1462589-diffuse" target="_blank" rel="external">diffuse</a>, <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1640554-metalness" target="_blank" rel="external">metalness</a>, and <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1640555-roughness" target="_blank" rel="external">roughness</a>—to produce a wide range of realistic shading effects. (The <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1462542-normal" target="_blank" rel="external">normal</a>, <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1462579-ambientocclusion" target="_blank" rel="external">ambientOcclusion</a>, and selfIllumination material properties also remain useful for PBR materials, but you can now ignore the large number of other properties used for traditional materials.)</p></li><li><p>PBR shading works best with environment-based lighting, which causes even diffuse surfaces to pick up the colors of the scene around them. Use the <a href="https://developer.apple.com/reference/scenekit/scnscene/1639532-lightingenvironment" target="_blank" rel="external">lightingEnvironment</a> property to assign global image-based lighting to an entire scene, and place light probes in the Xcode scene editor to pick up the local lighting contributions from objects within your scene.<br>Authors of PBR scene content often prefer working in physically based terms, so you can now define lighting using intensity (in lumens) and color temperature (in degrees Kelvin), and import specifications for real-world light fixtures using the IESProfileURL property.</p></li></ul><p>Add even more realism with the new HDR features and effects in the <a href="https://developer.apple.com/reference/scenekit/scncamera" target="_blank" rel="external">SCNCamera</a> class. With HDR rendering, SceneKit captures a much wider range of brightness and contrast in a scene, then allows you to customize the tone mapping that adapts that scene for the narrower range of a device’s display. Enable exposure adaptation to create automatic effects when, for example, the player in your game moves from a darkened area into sunlight. Or use vignetting, color fringing, and color grading to add a filmic look to your game.</p><p>Although linear, more color-accurate rendering is the basis for PBR shading and HDR camera features, it produces better results even for traditional rendering. By default, SceneKit now performs all color calculations in a linear (not gamma-adjusted) color space, and uses the P3 color gamut of devices that include wide-color displays. This feature is enabled automatically for all apps linking against the iOS 10 SDK, and has a few ramifications for content design and asset management:</p><ul><li>SceneKit color matches all colors. In previous versions, SceneKit would read only the color values from material colors specified as <a href="https://developer.apple.com/reference/appkit/nscolor" target="_blank" rel="external">NSColor</a> or <a href="https://developer.apple.com/reference/uikit/uicolor" target="_blank" rel="external">UIColor</a> objects, ignoring color profile information and assuming the sRGB color space.</li><li>SceneKit interprets color component values specified within shader modifier or custom Metal or OpenGL shader code in linear RGB space.</li><li>SceneKit reads and adjusts for color profile information in texture images. Design textures for a linear brightness ramp, and use Asset Catalogs in Xcode to make sure your images use the correct color profile.</li><li>If necessary, you can disable linear space rendering with the <code>SCNDisableLinearSpaceRendering</code> key in your app’s Info.plist file, and wide color rendering with the <code>SCNDisableWideGamut</code> key.<br>Geometry can now be loaded from scene files or programmatically defined using arbitrary polygon primitives (<a href="https://developer.apple.com/reference/scenekit/scngeometryprimitivetype/scngeometryprimitivetypepolygon" target="_blank" rel="external">SCNGeometryPrimitiveTypePolygon</a>). SceneKit automatically triangulates polygon meshes for rendering, but makes use of the underlying polygon mesh for more accurate surface subdivision (to learn more, see the <a href="https://developer.apple.com/reference/scenekit/scngeometry/1524177-subdivisionlevel" target="_blank" rel="external">subdivisionLevel</a> property).</li></ul><h5 id="SpriteKit"><a href="#SpriteKit" class="headerlink" title="SpriteKit"></a>SpriteKit</h5><p>The SpriteKit framework (SpriteKit.framework) includes the following enhancements:</p><ul><li>A new tilemap solution supports square, hexagonal, and isometric tilemaps that make it easy to create 2D, 2.5D, and side-scroller games. The Xcode editor provides comprehensive support for organizing your tiles and creating your tilemap. For more information, see the <code>SKTileMapNode</code>, <code>SKTileGroup</code>, <code>SKTileGroupRule</code>, and <code>SKTileSet</code> classes .</li><li>The new <code>SKWarpGeometry</code> class is used to stretch or distort how a <a href="https://developer.apple.com/reference/spritekit/skspritenode" target="_blank" rel="external">SKSpriteNode</a> or <a href="https://developer.apple.com/reference/spritekit/skeffectnode" target="_blank" rel="external">SKEffectNode</a> object is rendered. The warp is specified by a set of control points. New <a href="https://developer.apple.com/reference/spritekit/skaction" target="_blank" rel="external">SKAction</a> types can be used to animate between different warp effects.</li><li>A custom shader can use attributes that can be configured separately by each node that uses the shader. To add an attribute, create an <code>SKAttribute</code> object and attach it to your shader. Then, for each node that uses that shader, attach an <code>SKAttributeValue</code> object.]</li><li>The <a href="https://developer.apple.com/reference/spritekit/skview" target="_blank" rel="external">SKView</a> class defines new methods that give you finer control over when and how your scene is rendered.</li></ul><h5 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h5><p>UIKit框架(UIKit.framework)包含了大量的改进，包括：</p><ul><li>新的基于对象互动式动画系统，可以很方便的持有它，并和用户手势进行交互。想要了解更多请看<a href="https://developer.apple.com/reference/uikit/uiviewanimating" target="_blank" rel="external">UIViewAnimating Protocol Reference</a>、<a href="https://developer.apple.com/reference/uikit/uiviewpropertyanimator" target="_blank" rel="external">UIViewPropertyAnimator Class Reference</a>、<a href="https://developer.apple.com/reference/uikit/uitimingcurveprovider" target="_blank" rel="external">UITimingCurveProvider Protocol Reference</a>、<a href="https://developer.apple.com/reference/uikit/uicubictimingparameters" target="_blank" rel="external">UICubicTimingParameters Class Reference</a>、 <a href="https://developer.apple.com/reference/uikit/uispringtimingparameters" target="_blank" rel="external">UISpringTimingParameters Class Reference</a></li><li>新的<a href="https://developer.apple.com/reference/uikit/uipreviewinteraction" target="_blank" rel="external">UIPreviewInteraction</a>类和 <a href="https://developer.apple.com/reference/uikit/uipreviewinteractiondelegate" target="_blank" rel="external">UIPreviewInteractionDelegate</a>协议可以为peek和pop操作提供自定义界面</li><li><code>UIAccessibilityCustomRotor</code>以及相关的类可以让应用更好地集成辅助性技术，类似于向VoiceOver提供朗读内容。你可以创建自定义的rotor，返回拼写错误的单词的位置来让用户得知文档中的拼写错误</li><li><code>UIAccessibilityIsAssistiveTouchRunning</code>和<code>UIAccessibilityAssistiveTouchStatusDidChangeNotification</code>可以在AssistiveTouch激活的时候通知你。<code>UIAccessibilityHearingDevicePairedEar</code>和<code>UIAccessibilityHearingDevicePairedEarDidChangeNotification</code>能让你得知MFi助听器的配对状态</li><li>新的<a href="https://developer.apple.com/reference/uikit/uipasteboard" target="_blank" rel="external">UIPasteboard</a>提供了对大部分类实例兼容类型的声明，以及提供了对剪贴板内对象的生命周期进行限制的选项</li><li><a href="https://developer.apple.com/reference/uikit/uipasteboard" target="_blank" rel="external">UIPasteboard</a>的新选项</li><li><a href="https://developer.apple.com/reference/uikit/uifont" target="_blank" rel="external">UIFont</a>的<code>preferredFontForTextStyle:compatibleWithTraitCollection:</code>方法提供了对labels、text fields和其他文本控件的动态字体支持</li><li>当设备的<code>UIContentSizeCategory</code>改变时<code>UIContentSizeCategoryAdjusting</code>协议提供了<code>adjustsFontForContentSizeCategory</code>属性来帮你更新相关的字体</li><li>对tab bar item的badge外观的更多控制，诸如背景颜色和text attributes</li><li>所有的scrol view及其子类都支持refresh control了</li><li><a href="https://developer.apple.com/reference/uikit/uiapplication" target="_blank" rel="external">UIApplication</a>的新方法<code>openURL:options:completionHandler:</code>为异步执行，并在主线程执行回调(这个方法将来要取代<a href="https://developer.apple.com/reference/uikit/uiapplication/1622961-openurl" target="_blank" rel="external">openURL:</a>)</li><li>新的<code>UICloudSharingController</code>类和<code>UICloudSharingControllerDelegate</code>协议可以初始化Cloudkit分享操作，并向用户展示一个相关配置选项的界面</li><li>增强了<a href="https://developer.apple.com/reference/uikit/uicollectionview" target="_blank" rel="external">UICollectionView</a>以及新增了<a href="https://developer.apple.com/reference/uikit/uicollectionviewdatasourceprefetching" target="_blank" rel="external">UICollectionViewDataSourcePrefetching</a>协议，通过提前获取cell的方式增强了滑动体验</li></ul><h5 id="WebKit"><a href="#WebKit" class="headerlink" title="WebKit"></a>WebKit</h5><p>WebKit框架(WebKit.framework)的<a href="https://developer.apple.com/reference/webkit/wkwebview" target="_blank" rel="external">WKWebView</a>增强了peek和pop操作。在iOS10上用户可以使用<a href="https://developer.apple.com/reference/webkit/wkuidelegate/1648359-webview" target="_blank" rel="external">webView:shouldPreviewElement:</a>方法来决定是否在指定的链接上显示预览页面。</p><h3 id="Deprecated-APIs"><a href="#Deprecated-APIs" class="headerlink" title="Deprecated APIs"></a>Deprecated APIs</h3><p>iOS10把下列的APIs标记为废弃：</p><ul><li><a href="https://developer.apple.com/reference/cloudkit/ckdiscoverallcontactsoperation" target="_blank" rel="external">CloudKit CKDiscoverAllContactsOperation</a>、<a href="https://developer.apple.com/reference/cloudkit/ckdiscovereduserinfo" target="_blank" rel="external">CKDiscoveredUserInfo</a>、<a href="https://developer.apple.com/reference/cloudkit/ckdiscoveruserinfosoperation" target="_blank" rel="external">CKDiscoverUserInfosOperation</a>, <a href="https://developer.apple.com/reference/cloudkit/ckfetchrecordchangesoperation" target="_blank" rel="external">CKFetchRecordChangesOperation</a>。作为替代可以使用 <a href="https://developer.apple.com/reference/cloudkit/ckdiscoveralluseridentitiesoperation" target="_blank" rel="external">CKDiscoverAllUserIdentitiesOperation</a>、<a href="https://developer.apple.com/reference/cloudkit/ckuseridentity" target="_blank" rel="external">CKUserIdentity</a>、<a href="https://developer.apple.com/reference/cloudkit/ckdiscoveruseridentitiesoperation" target="_blank" rel="external">CKDiscoverUserIdentitiesOperation</a>和 <a href="https://developer.apple.com/reference/cloudkit/ckfetchrecordzonechangesoperation" target="_blank" rel="external">CKFetchRecordZoneChangesOperation</a>。<br>多个<a href="https://developer.apple.com/reference/cloudkit/cksubscription" target="_blank" rel="external">CKSubscription</a>的APIs，比如zone-based subscriptions相关的方法和属性(用<code>CKRecordZoneSubscription</code>替代)</li><li><a href="NSPersistentStoreCoordinator">NSPersistentStoreCoordinator</a>相关的常量</li><li><a href="https://developer.apple.com/reference/uikit/uiviewcontroller" target="_blank" rel="external">UIViewController</a>中的<a href="https://developer.apple.com/reference/iad/adbannerview" target="_blank" rel="external">ADBannerView</a>和<a href="https://developer.apple.com/reference/iad/adinterstitialad" target="_blank" rel="external">ADInterstitialAd</a>类以及相关常量</li><li><a href="https://developer.apple.com/reference/spritekit/skuniform" target="_blank" rel="external">SKUniform</a>相关的浮点常量。可以在适当的情况下用<code>initWithName:vectorFloat2:</code>和<code>uniformWithName:matrixFloat2x2:</code>作为替代</li><li>UIkit相关的通知，诸如<a href="https://developer.apple.com/reference/uikit/uilocalnotification" target="_blank" rel="external">UILocalNotification</a>、<a href="https://developer.apple.com/reference/uikit/uimutableusernotificationaction" target="_blank" rel="external">UIMutableUserNotificationAction</a>、<a href="https://developer.apple.com/reference/uikit/uimutableusernotificationcategory" target="_blank" rel="external">UIMutableUserNotificationCategory</a>、<a href="https://developer.apple.com/reference/uikit/uiusernotificationaction" target="_blank" rel="external">UIUserNotificationAction</a>、<a href="https://developer.apple.com/reference/uikit/uiusernotificationcategory" target="_blank" rel="external">UIUserNotificationCategory</a>和<a href="https://developer.apple.com/reference/uikit/uiusernotificationsettings" target="_blank" rel="external">UIUserNotificationSettings</a>。请使用User Notifications框架作为替代(<a href="https://developer.apple.com/reference/usernotifications" target="_blank" rel="external">Notifications Framework Reference</a>)</li><li><a href="https://developer.apple.com/reference/watchkit/wkinterfacecontroller/1619516-handleactionwithidentifier" target="_blank" rel="external">handleActionWithIdentifier:forLocalNotification:</a>、<a href="https://developer.apple.com/reference/watchkit/wkinterfacecontroller/1619530-handleactionwithidentifier" target="_blank" rel="external">handleActionWithIdentifier:forRemoteNotification:</a>、<a href="https://developer.apple.com/reference/watchkit/wkusernotificationinterfacecontroller/1619534-didreceivelocalnotification" target="_blank" rel="external">didReceiveLocalNotification:withCompletion:</a>和 <a href="https://developer.apple.com/reference/watchkit/wkusernotificationinterfacecontroller/1619568-didreceiveremotenotification" target="_blank" rel="external">didReceiveRemoteNotification:withCompletion:</a>等方法。请使用<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate/1628138-handleactionwithidentifier" target="_blank" rel="external">handleActionWithIdentifier:forNotification:</a>和<a href="https://developer.apple.com/reference/watchkit/wkusernotificationinterfacecontroller/1648287-didreceive" target="_blank" rel="external">didReceiveNotification:withCompletion:</a>作为替代。<br>同样还有<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate" target="_blank" rel="external">WKExtensionDelegate</a>的通知处理方法，诸如<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate/1628170-didreceiveremotenotification" target="_blank" rel="external">didReceiveRemoteNotification:</a>和<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate/1628138-handleactionwithidentifier" target="_blank" rel="external">handleActionWithIdentifier:forRemoteNotification:</a>作为使用上述方法的替代方案，首先实例化一个遵循<a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenterdelegate" target="_blank" rel="external">UNUserNotificationCenterDelegate</a>协议的托对象并实现适当的方法，然后把这个实例对象赋值给<a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenter" target="_blank" rel="external">UNUserNotificationCenter</a>单例的<a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenter/1649522-delegate" target="_blank" rel="external">delegate</a>属性</li></ul><p>完整的API废弃列表请看<a href="https://developer.apple.com/library/content/releasenotes/General/iOS10APIDiffs/index.html" target="_blank" rel="external">iOS 10.0 API Diffs</a>。</p>]]></content>
    
    <summary type="html">
    
      iOS10新特性列表
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>项目中Cell自动计算行高的实践</title>
    <link href="http://petpwiuta.github.io/2016/09/13/cell-height-calc-with-autolayout/"/>
    <id>http://petpwiuta.github.io/2016/09/13/cell-height-calc-with-autolayout/</id>
    <published>2016-09-13T08:29:57.000Z</published>
    <updated>2016-10-08T07:09:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目中Cell自动计算行高的实践"><a href="#项目中Cell自动计算行高的实践" class="headerlink" title="项目中Cell自动计算行高的实践"></a>项目中Cell自动计算行高的实践</h1><h3 id="在前面总该说些什么"><a href="#在前面总该说些什么" class="headerlink" title="在前面总该说些什么"></a>在前面总该说些什么</h3><p>这篇文章是对团队最近关于使用Autolayout对Cell进行高度计算的总结。</p><hr><p>接下来你将会看到以下内容：</p><blockquote><ul><li>数据和UI分离式的Cell高度计算的弊端</li><li>Self-Sizing Cell的解决方案</li><li>UITableView+FDTemplateLayoutCell简介</li><li>UITableView+FDTemplateLayoutCell代码分析</li><li>UITableView+FDTemplateLayoutCell集成</li></ul></blockquote><h3 id="数据和UI分离式的Cell高度计算的弊端"><a href="#数据和UI分离式的Cell高度计算的弊端" class="headerlink" title="数据和UI分离式的Cell高度计算的弊端"></a>数据和UI分离式的Cell高度计算的弊端</h3><p>通过数据模型的方式计算行高，这样的方式已经从ios4延伸到ios9了，这种方式的核心是在cell或者model里面提供一个方法，传入数据，然后根据内容+各种Margin计算出cell的高度。但是这种方法有个巨大的缺陷就是数据和界面是割裂的，你不得不在调完了UI后还要去计算高度的方法里再改一通。阅读和维护这部分逻辑时也会比较麻烦</p><p>或许已经有人想到了把计算高度的方法放到cel里面，然后把那些Margin做成常量，然后把数据传入cell来计算高度，这样当你修改内部的Margin时，高度计算的方法会不用做任何修改。不错，这个办法已经部分解决了上面的部分问题。不过当你调整UI以后对应的高度计算方法肯定会需要根据UI重写一遍，上述的问题还是存在。那有没有什么更简单的方法呢</p><p>答案是肯定的。苹果在iOS8提出了Self-Sizing Cell的概念。只要你用Autolayout对cell进行约束布局，当约束足够清晰时，Cell就能自动计算出自己的高度。如果后续UI有变化，也仅仅只需要调整控件以及相关的约束就行。</p><h3 id="Self-Sizing-Cell的解决方案"><a href="#Self-Sizing-Cell的解决方案" class="headerlink" title="Self-Sizing Cell的解决方案"></a>Self-Sizing Cell的解决方案</h3><p>理想很丰满，现实很骨感。Self-Sizing Cell可以解决问题，但是它自身也有它自己的问题。</p><p>首先Self-Sizing Cell必须使用Autolayout布局，用Frame方式布局从iOS诞生就开始了，只要稍稍有点历史的项目，在维护中肯定会遇到用Frame布局的Cell。所以不能使用纯Autolayout布局的方案。</p><p>其次是Self-Sizing Cell本身的设计策略，导致它有一定的性能嫌疑。在iOS8之前，TableView会缓存下Cell的高度，反复滑动Cell不会重复计算；但是在iOS8以后，苹果认为Cell可能会随时改变大小（用户在设置里面调整字体什么的）所以不会做缓存了，这就导致了同一个Cell在反复滑动的时候会反复计算高度。</p><p>最后是iOS6、7、8三个版本中关于高度计算API不一致的问题：<br>在iOS6上，我们是在<code>tableView:heightForRowAtIndexPath:</code>方法里返回通过数据计算的高度；而在在iOS7中，出现了<code>estimatedRowHeight</code>相关的属性，苹果通过这个属性把计算的工作从TableView加载时延迟到了Cell出现时，提高了TableView的加载速度；在iOS8中只需要写<code>self.tableView.estimatedRowHeight = RowHeight</code>这样的一行代码就能自动计算出Cell的高度(前提是Cell使用Autolayout写的布局)。可以看到随着苹果对Cell高度计算的不断优化让代码越来越简单，但是越简单的API需要的iOS版本越高，如果App要兼容低版本，就不得不在工程里写很多冗余的兼容性代码。</p><p>那如何能解决上面的这些问题呢，答案就是<code>UITableView+FDTemplateLayoutCell</code>。</p><h3 id="UITableView-FDTemplateLayoutCell简介"><a href="#UITableView-FDTemplateLayoutCell简介" class="headerlink" title="UITableView+FDTemplateLayoutCell简介"></a><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">UITableView+FDTemplateLayoutCell</a>简介</h3><p>关于UITableView+FDTemplateLayoutCell我就直接把<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">作者</a>的原话扒过来。</p><blockquote><p>使用<code>UITableView+FDTemplateLayoutCell</code>无疑是解决算高问题的最佳实践之一，既有 iOS8<br>self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。 使用起来大概是这样： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">&gt;     return [tableView fd_heightForCellWithIdentifier:@&quot;identifer&quot; cacheByIndexPath:indexPath configuration:^(id cell) &#123;</div><div class="line">&gt;         // 配置 cell 的数据源，和 &quot;cellForRow&quot; 干的事一致，比如：</div><div class="line">&gt;         cell.entity = self.feedEntities[indexPath.row];</div><div class="line">&gt;     &#125;]; &#125; </div><div class="line">&gt;</div></pre></td></tr></table></figure><p>写完上面的代码后，你就已经使用到了：</p><ul><li>和每个 UITableViewCell ReuseID 一一对应的 template layout cell<br>这个 cell 只为了参加高度计算，不会真的显示到屏幕上；它通过 UITableView 的 <code>-dequeueCellForReuseIdentifier:</code> 方法 lazy 创建并保存，所以要求这个 ReuseID 必须已经被注册到了 UITableView 中，也就是说，要么是 Storyboard 中的原型 cell，要么就是使用了 UITableView 的 <code>-registerClass:forCellReuseIdentifier:</code> 或 <code>-registerNib:forCellReuseIdentifier:</code>其中之一的注册方法。</li><li>根据 autolayout 约束自动计算高度<br>使用了系统在 iOS6 就提供的 API：<code>-systemLayoutSizeFittingSize:</code></li><li>根据 index path 的一套高度缓存机制<br>计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了非常可观的多余计算。</li><li>自动的缓存失效机制<br>无须担心你数据源的变化引起的缓存失效，当调用如<code>-reloadData</code>，<code>-deleteRowsAtIndexPaths:withRowAnimation:</code>等任何一个触发 UITableView 刷新机制的方法时，已有的高度缓存将以最小的代价执行失效。如删除一个 indexPath 为 [0:5] 的 cell 时，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。</li></ul></blockquote><h3 id="UITableView-FDTemplateLayoutCell代码分析"><a href="#UITableView-FDTemplateLayoutCell代码分析" class="headerlink" title="UITableView+FDTemplateLayoutCell代码分析"></a>UITableView+FDTemplateLayoutCell代码分析</h3><p>好了，上面说了<code>UITableView+FDTemplateLayoutCell</code>具有这么多功能，那这部分就来分析一下这些功能的实现方式。先说一下实现的方式路再上代码。</p><h4 id="高度计算"><a href="#高度计算" class="headerlink" title="高度计算"></a>高度计算</h4><p><code>UITableView+FDTemplateLayoutCell</code>在TableVie内部维护了一个模板Cell结构，它不会加入TableView中，模板Cell会自动调用Cell默认的方法实例化，然后根据传入的数据对这个模板进行填充，再计算高度。Cell的高度计算使用了两种方式，一种针对于Autolayout写的Cell调用<code>[cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize]</code>自动计算行高；另一种是对于Frame调用<code>[cell sizeThatFits:CGSizeMake(contentViewWidth, 0)]</code>手动计算行高。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>基于NSDictionary的缓存。如果调用的是带缓存的API，那在计算出高度后会缓存结果，下次再计算时会先查询缓存。这个框架已经把会引起TableView重新加载的方法都做了替换，在这些方法被调用时会先清空缓存再调用以前的方法。</p><p><code>- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration;</code></p><p>这个方法是高度计算的核心，API很简单，<code>identifier</code>是复用的标识，<code>configuration</code>主要用于你来用数据填充Cell<br>下面来看一下内部的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration &#123;</div><div class="line">    </div><div class="line">    UITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier];</div><div class="line">    </div><div class="line">    [templateLayoutCell prepareForReuse];</div><div class="line">    </div><div class="line">    if (configuration) &#123;</div><div class="line">        configuration(templateLayoutCell);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里为了突出主干逻辑，删掉了断言还有注释以及一部分非必要逻辑。从代码上看流程非常清晰，第一行获取到模板Cell，然后调用Cell的<code>prepareForReuse</code>方法来确保对Cell的调用行为和真实的一样(其实如果你所有的cell都没有在<code>prepareForReuse</code>方法里面写初始化代码的话，那这一行可有可无)。接着调用<code>configuration</code>来配置模板Cell，然后调用<code>[self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell]</code>来计算高度。</p><p>下面来深入<code>fd_systemFittingHeightForConfiguratedCell:</code>这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)fd_systemFittingHeightForConfiguratedCell:(UITableViewCell *)cell &#123;</div><div class="line">    CGFloat contentViewWidth = CGRectGetWidth(self.frame);</div><div class="line">    </div><div class="line"></div><div class="line">    if (cell.accessoryView) &#123;</div><div class="line">        contentViewWidth -= 16 + CGRectGetWidth(cell.accessoryView.frame);</div><div class="line">    &#125; else &#123;</div><div class="line">        static const CGFloat systemAccessoryWidths[] = &#123;</div><div class="line">            [UITableViewCellAccessoryNone] = 0,</div><div class="line">            [UITableViewCellAccessoryDisclosureIndicator] = 34,</div><div class="line">            [UITableViewCellAccessoryDetailDisclosureButton] = 68,</div><div class="line">            [UITableViewCellAccessoryCheckmark] = 40,</div><div class="line">            [UITableViewCellAccessoryDetailButton] = 48</div><div class="line">        &#125;;</div><div class="line">        contentViewWidth -= systemAccessoryWidths[cell.accessoryType];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    CGFloat fittingHeight = 0;</div><div class="line">    </div><div class="line">    if (!cell.fd_enforceFrameLayout &amp;&amp; contentViewWidth &gt; 0) &#123;</div><div class="line"></div><div class="line">        NSLayoutConstraint *widthFenceConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:contentViewWidth];</div><div class="line">        [cell.contentView addConstraint:widthFenceConstraint];</div><div class="line">        </div><div class="line">        fittingHeight = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;</div><div class="line">        [cell.contentView removeConstraint:widthFenceConstraint];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (fittingHeight == 0) &#123;</div><div class="line">        fittingHeight = [cell sizeThatFits:CGSizeMake(contentViewWidth, 0)].height;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    return fittingHeight;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个方法首先获取到Cell的宽度，得到宽度后根据是否有自定义的accessoryView来调整Cell的宽度。（这里关于关于静态数组systemAccessoryWidths的使用可能不太常见，这个是C的写法，就是静态不定长度的数组的初始化，这里面数组的长度等于花括号里面给出的最大索引值+1，其他没有给定明确初始值的都是0）然后调用 <code>[cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize]</code>来自动计算出Cell的高度，这里在计算之前临时添给Cell.contentView添加了一个和Cell等宽的约束是为了让内部View知道自己的父View的大小，减少因无法得知contentView的宽度而导致约束计算失败的情况。最后一步是判断Autolayout计算的结果是否正确，因为需要兼容使用Frame布局的Cell的情况，当Autolayout计算失败后再尝试着调用<code>[cell sizeThatFits:CGSizeMake(contentViewWidth, 0)]</code>来计算高度。</p><p>下面来看带缓存的方法:</p><p><code>- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration</code></p><p><code>- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id&lt;NSCopying&gt;)key configuration:(void (^)(id cell))configuration</code></p><p>这两个方法一个是按IndexPath做缓存一个是按Key做缓存。两者都是基于NSDictionary实现的，按Key缓存比较简单，内部实现基本上可以理解为cache[Key]=rowHeight这样的形式，具体的代码就不赘述。IndexPath缓存因为涉及IndexPath数组的增删改的操作而稍稍复杂一点，不过虽然比前者复杂但是本质也是在维护一个NSDictionary，这里就不再详细介绍，而是讲一下IndexPath缓存中实现的比较有意思的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)buildSectionsIfNeeded:(NSInteger)targetSection &#123;</div><div class="line">    [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123;</div><div class="line">        for (NSInteger section = 0; section &lt;= targetSection; ++section) &#123;</div><div class="line">            if (section &gt;= heightsBySection.count) &#123;</div><div class="line">                heightsBySection[section] = [NSMutableArray array];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个方法里面有意思的地方在于当你传入的Section如果大于当前的最大Section时，会自动创建后续的所有Section，比如现在Section数组有3个元素，然后你的入参为20，那这个循环会创建剩下的17个Section数组。这里作者用到了一个NSMutableArray的一个不太常用的语法，就是<code>NSMutableArray[最大索引值]=NewItem</code>，这个等价于<code>[NSMutableArray addObject:NewItem]</code>，使用不太常见的语法让代码更精炼的例子在这个框架里面还有几个，可见作者OC的基本功非常扎实。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)fd_deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation &#123;</div><div class="line">        [sections enumerateIndexesUsingBlock:^(NSUInteger section, BOOL *stop) &#123;</div><div class="line">            [self.fd_indexPathHeightCache buildSectionsIfNeeded:section];</div><div class="line">            [self.fd_indexPathHeightCache enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123;</div><div class="line">                [heightsBySection removeObjectAtIndex:section];</div><div class="line">            &#125;];</div><div class="line">        &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)fd_moveSection:(NSInteger)section toSection:(NSInteger)newSection &#123;</div><div class="line">        [self.fd_indexPathHeightCache buildSectionsIfNeeded:section];</div><div class="line">        [self.fd_indexPathHeightCache buildSectionsIfNeeded:newSection];</div><div class="line">        [self.fd_indexPathHeightCache enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123;</div><div class="line">            [heightsBySection exchangeObjectAtIndex:section withObjectAtIndex:newSection];</div><div class="line">        &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这部分代码有意思的地方是作者的编程的思路。删除或者移动索引的时候可能相应的索引可能并不存在，有的人会在这里先判断，然后根据不同情况做不同的处理，这样做肯定是没问题的。不过作者在这里的做法是统统调一遍<code>[self.fd_indexPathHeightCache buildSectionsIfNeeded:section]</code>保证索引肯定存在，避免了加一些冗长的判断语句，代码比显得较干净。这里把未知问题转换成已知问题的思路体现得淋漓尽致，而且特别能体现出程序设计的模块化设计与复用的美感。</p><p>好了，到这里<code>UITableView+FDTemplateLayoutCell</code>的分析就写完了，可能有的人会感觉怎么才这点东西。东西确实不多，因为这个框架本身很简单，全部代码加上注释才600多行代码。不过见微知著，寥寥几百行代码体现了作者良好的编程思维以及扎实的语言基本功。这也是我们需要学习的地方。</p><h3 id="UITableView-FDTemplateLayoutCell集成"><a href="#UITableView-FDTemplateLayoutCell集成" class="headerlink" title="UITableView+FDTemplateLayoutCell集成"></a>UITableView+FDTemplateLayoutCell集成</h3><p>其实最后一部分内容很少。主要是针对于老的使用Frame布局的Cell使用这个框架的实践。前面也说过如果用Autolayout的Cell是自动计算的，Frame布局的Cell是通过<code>[cell sizeThatFits:CGSizeMake(contentViewWidth, 0)]</code>来做，所以需要把Frame布局的Cell的<code>sizeThatFits</code>方法重载，因为<code>sizeThatFits</code>方法没有入参，所以需要让Cell持有数据Model，然后在<code>sizeThatFits</code>里调用以前计算高度的方法就行了。这里Cell持有数据Model可以用weak的属性来修饰，避免可能的引用循环问题。</p><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>他山之石，可以攻玉。这篇文章的核心就是基于<code>UITableView+FDTemplateLayoutCell</code>的工程实践，感谢作者sunnyxx的无私奉献。sunnyxx的博客中还有不少有深度的iOS技术分析。这里贴一下他的</p><p><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">博客地址：</a><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/</a></p><p><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">GitHub地址：</a><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a></p>]]></content>
    
    <summary type="html">
    
      这篇文章是对团队最近关于使用Autolayout对Cell进行高度计算的总结。
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS worst practice</title>
    <link href="http://petpwiuta.github.io/2015/11/28/iOS-worst-practice/"/>
    <id>http://petpwiuta.github.io/2015/11/28/iOS-worst-practice/</id>
    <published>2015-11-28T12:50:04.000Z</published>
    <updated>2016-10-08T07:17:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-worst-practice"><a href="#iOS-worst-practice" class="headerlink" title="iOS worst practice"></a>iOS worst practice</h1><p>最近在重构公司的项目，随着对项目的逐渐深入（被坑的次数越来越多），被各路大牛的神迹所折服，以至于感觉这些人是不是我们竞争对手派来的卧底。这些坑可以算是iOS worst practice了，在这里总结一下。</p><h2 id="命名的问题"><a href="#命名的问题" class="headerlink" title="命名的问题"></a>命名的问题</h2><p>给变量或者类以及方法起名能从一个侧面反映出一个程序员的水平以及项目的管理情况。在这个项目中，方法名、变量名和类名都没有统一，而且相关业务命名也没有规定。比如用于引导页面就有<code>TechView</code>、<code>IntroduceView</code>、<code>guideView</code>等，而下面的这些命名真是让人看了直接让人凌乱：</p><p>方法：</p><p><code>-(void)preTeachView2KnowActionWithNoShow:(UIButton *)sender</code></p><p><code>-(void)setTableView_Up_Down_NoHidden</code></p><p>变量：</p><p><code>#define fuckvalue   -34</code></p><p><code>_info_tmp</code></p><p><code>NSString *fuck1;</code></p><p><code>NSString *fuck2;</code></p><p>类:</p><p><code>@interface New_AdPersonViewController : New_PersonDetailViewController</code></p><h2 id="代码复用性"><a href="#代码复用性" class="headerlink" title="代码复用性"></a>代码复用性</h2><p>不会Ctrl-C/Ctrl-V的程序员不是好程序员，不过有些人玩得太high了，看你的工程中到处都是下面这些代码的时候你是什么感觉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    UITableViewCell *cell;</div><div class="line">    if(indexPath.section == 0)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:0];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 1)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:1];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 2)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:2];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 3)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:3];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 4)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:4];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 5)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:5];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 6)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:6];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 7)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:7];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 8)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:8];</div><div class="line">    &#125;</div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> NSString *sectionTitle = @&quot;&quot;;</div><div class="line">        if(indexPath.section == 0)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:0];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 1)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:1];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 2)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:2];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 3)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:3];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 4)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:4];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 5)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:5];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 6)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:6];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 7)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:7];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 8)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:8];</div><div class="line">         &#125;</div></pre></td></tr></table></figure><p>反正我看了第一感觉是，我x、原来以前公司发工资是按代码行数算钱的······</p><h2 id="没有面向对象思想"><a href="#没有面向对象思想" class="headerlink" title="没有面向对象思想"></a>没有面向对象思想</h2><ul><li>在ViewController基类中放一些特定的业务逻辑，然后所有的子类中都有一堆阴魂不散的代码</li><li>该封装的不封装，完成同样功能的函数在每个用到的地方都一个copy，一旦逻辑变动，改起来真心好爽</li><li>不该封装的乱封装，封装的暴露的方法完全不知道是干什么的，想要类运行还必须先设定某些它所依赖的全局变量</li></ul><h2 id="滥用单例、通知"><a href="#滥用单例、通知" class="headerlink" title="滥用单例、通知"></a>滥用单例、通知</h2><p>实际上工程里面单例就一个，不过单例对象把所有的活都干，所以可以理解为整个工程的架构，都是面向过程的，全部模块水乳交融、浑然一体。用户数据保存靠这个单例、具体页面数据设置靠靠这个单例、应用行为配置靠靠这个单例······然后大部分的ViewController想要正常工作都得提前把所需的数据在这个单例中配置好，想想都佩服那些大神的记忆力；对于滥用通知的后果和单例一样，当你见到一个控制器中有一二十条通知齐刷刷地写在初始化方法里的时候有什么感觉。想想都有点小激动，你确定不是在逗我？</p><h2 id="各种脑洞大开的实现"><a href="#各种脑洞大开的实现" class="headerlink" title="各种脑洞大开的实现"></a>各种脑洞大开的实现</h2><p>看见一个函数名叫做addRequestQueue的时候你会有什么反应，大部分人肯定想着肯定会是生成请求实例、有请求队列对它们进行管理······对此我只能说大神的想象力是无穷的，这个addRequestQueue是用<strong>递归的方式</strong>发送的请求，在网络请求成功或失败的闭包中会再次调用自己发送请求，这时候我终于明白这个队列是在哪儿了。</p><p>类似的例子还有很多，一次次的被大神的想象力所折服！</p>]]></content>
    
    <summary type="html">
    
      iOS被坑血泪史
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Autolayout笔记:自定义View</title>
    <link href="http://petpwiuta.github.io/2015/07/25/Autolayout-%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    <id>http://petpwiuta.github.io/2015/07/25/Autolayout-自定义View/</id>
    <published>2015-07-25T10:23:38.000Z</published>
    <updated>2017-07-13T03:51:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Autolayout笔记-自定义View"><a href="#Autolayout笔记-自定义View" class="headerlink" title="Autolayout笔记:自定义View"></a>Autolayout笔记:自定义View</h1><p>如果你想在自定义View里用Autolayout进行布局的话，有下面几个点需要注意：</p><ul><li>指定Intrinsic Content Size</li><li>区分frame和alignment rect</li><li>是否支持baseline-aligned布局</li><li>对子视图进行精确的布局控制</li></ul><p>下面将从这些方面逐步讲解。</p><h2 id="指定Intrinsic-Content-Size"><a href="#指定Intrinsic-Content-Size" class="headerlink" title="指定Intrinsic Content Size"></a>指定Intrinsic Content Size</h2><p>这部分的基本概念在上一篇文章已经讲过，这里不再赘述，主要注意三点：</p><ol><li>重写<code>intrinsicContentSize</code>方法。如果这个视图只有一个方向的尺寸设置了Intrinsic Size，那么为另一个方向的尺寸返回 <code>UIViewNoIntrinsicMetric</code>/<code>NSViewNoIntrinsicMetric</code>。</li><li>当view的某些属性的改变会影响到Intrinsic Content Size时，需要调用<code>invalidateIntrinsicContentSize</code>，例如当UILabel的text变化时，就需要重新计算Intrinsic Content Size。</li><li>当实现了<code>intrinsicContentSize</code>方法后，如果想进一步控制当View的实际大小和intrinsicContentSize`冲突时的行为，需要实现Compression Resistance和Content Hugging这方面的方法，具体做法请看<a href="http://blog.csdn.net/yongyinmg/article/details/39526207" title="yongyinmg的专栏" target="_blank" rel="external">这里</a></li></ol><h2 id="区分frame和alignment-rect"><a href="#区分frame和alignment-rect" class="headerlink" title="区分frame和alignment rect"></a>区分frame和alignment rect</h2><p>Autolayout系统的布局操作是基于alignment rect而非frame。绝大部分情况下它们是一样的，但是当你设置了<code>alignmentRectInsets</code>或者重写了<code>alignmentRectForFrame:</code>和<code>frameForAlignmentRect:</code>时就需要注意两者的差异。</p><p><img src="/images/Autolayout-2/pic_1-1.png" alt="img"></p><p>如图所示，Autolayout所有的约束（包括指定宽和高）都施加在alignment rect上，当你指定了<code>alignmentRectInsets</code>后View的frame是根据alignment rect和<code>alignmentRectInsets</code>计算出来的。上图里给view添加了left=80、top=100、width=100和height=100约束，使alignment rect上left为80、top为100、width为100、height为100，然后Autolayout系统根据alignmentRectInsets计算出view的frame，这里frame就是</p><p>{<br><code>alignmentRect.left-alignmentRectInsets.left</code>,<br><code>alignmentRect.top-alignmentRectInsets.top</code>,<br><code>alignmentRect.width+alignmentRectInsets.left+alignmentRectInsets.right</code>,<br><code>alignmentRect.height+alignmentRectInsets.top+alignmentRectInsets.bottom</code><br>}</p><p>即{<code>60</code>,<code>80</code>,<code>140</code>,<code>140</code>}</p><h2 id="是否支持baseline-aligned布局"><a href="#是否支持baseline-aligned布局" class="headerlink" title="是否支持baseline-aligned布局"></a>是否支持baseline-aligned布局</h2><p>如果需要支持baseline布局，就需要实现<code>viewForBaselineLayout</code>(iOS平台) ，系统默认实现只是简单地返回<code>self</code>。如果重写这个方法它返回的View的底边会作为baseline，而且这个View必须是你自定义View的子视图。在OS X中实现baseline布局需要重写<code>baselineOffsetFromBottom</code>返回一个从视图底部边缘开始的offset，默认返回0。</p><p>如果自定义View的frame和alignment rect不一样（设置了<code>alignmentRectInsets</code>或者重写了<code>alignmentRectForFrame:</code>和<code>frameForAlignmentRect:</code>）需要注意Autolayout布局是施加在alignment rect上的，自定义的view的最终位置是由<code>viewForBaselineLayout</code>和<code>alignmentRectInsets</code>共同决定的。</p><h2 id="如何对子视图进行精确的布局控制"><a href="#如何对子视图进行精确的布局控制" class="headerlink" title="如何对子视图进行精确的布局控制"></a>如何对子视图进行精确的布局控制</h2><p><strong>给子视图添加Constraints</strong> 官方建议的方法是在 <code>updateConstraints</code>里添加子视图的Constraints，而且要保证 <code>[super updateConstraints]</code>一定要在你自己的Constraints添加完之后再调用。而且在这个方法里不能<em>“invalidate any constraints”</em>如果Constraints失效时，需要移除对应的Constraints，并调用<code>setNeedsUpdateConstraints</code>来刷新。</p><p>如果是用添加Constraints的方式给子视图布局的话，这个自定义视图就仅仅在Autolayout环境下才能正常工作，因此可以重写<code>requiresConstraintBasedLayout</code>方法返回YES来告知系统必须使用Autolayout布局。</p><p><strong>子视图布局</strong> 回顾一下之前说起过的Autolayout布局的3个步骤，当Update constraints阶段结束后，就进入Layout view阶段，此时就会调用<code>layoutSubviews</code>方法来根据Constraints计算出来的结果来调整view的<code>bounds</code>和<code>center</code>。因此在<code>layoutSubviews</code>方法里可以对布局进行任意的调整。</p><p>最极端的情况是重写<code>layoutSubviews</code>/<code>layout</code>时不调用父类的实现。这就意味着系统虽然根据Constraints计算出视图树的位置，但你并没有应用计算的结果，换言之就是你在这个视图中完全放弃Autolayout布局，完全根据自己的意愿对子视图进行布局。</p><p>如果你仍然想使用Autolayout布局子视图，你可以先调用<code>[super layoutSubviews]</code>/<code>[super layout]</code>，然后对布局进行微调。这样可以创建一些通过Constraints无法实现的布局，比如，由到视图大小之间的关系或是视图之间间距的关系来定义的布局。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a style="text-decoration:none;color:#1D39DD" href="http://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/" target="_blank" rel="external"><br>《Advanced Auto Layout Toolbox》 - objc.io</a></li><li><a style="text-decoration:none;color:#1D39DD" href="http://blog.csdn.net/yongyinmg/article/details/39526207" target="_blank" rel="external">《AutoLayout中的Content Hugging 和 Content Compression Resistance》 - yongyinmg的专栏</a></li></ul>]]></content>
    
    <summary type="html">
    
      Autolayout笔记:自定义View
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Autolayout笔记:基本概念</title>
    <link href="http://petpwiuta.github.io/2015/07/18/AutoLayout-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://petpwiuta.github.io/2015/07/18/AutoLayout-基础概念/</id>
    <published>2015-07-18T15:42:00.000Z</published>
    <updated>2017-07-13T03:52:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Autolayout笔记-基本概念"><a href="#Autolayout笔记-基本概念" class="headerlink" title="Autolayout笔记:基本概念"></a>Autolayout笔记:基本概念</h1><p>AutoLayout使用非常简单，Xcode的支持也非常直观。但是因为和之前的方式有很大的不同，学习曲线比较陡峭，所以给新手造成一些心理负担，下面我将通过一些列的文章来给大家简单的讲解一下Autolayout的基本用法。</p><p>AutoLayout是一个基于约束的布局系统。描述各种约束的行为，比如一个View 距离父View上边距多少，相邻之间的间隔多少，各个View之间的宽高关系等等。这一系列的条件就是为了最终确定之前提到的传统布局中需要的东西，这个View的大小、位置。所以，当我们设置的条件不足，或是条件冲突时，就会产生异常。</p><h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>上面说了Autolayout是基于约束的，约束在iOS/OS X里面就是Constraint，让我们看看新建一个Constraint的API是怎样的：</p><pre><code>NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:item1                                                                   attribute:NSLayoutAttributeLeft                                                                   relatedBy:NSLayoutRelationEqual                                                                      toItem:item2                                                                   attribute:NSLayoutAttributeLeft                                                                  multiplier:1                                                                    constant:10];</code></pre><p>这里的参数比较多，但仔细看可以发现它表述了这样一种关系：<br><strong>Item. Attribute relatedBy toItem. Attribute * multiplier + constant</strong>。用人话解释一遍就是一个view的某个属性在位置上和另外一个view的某个属性有一定关系。举个例子比如说我想表达view1的右边和view2的左边相互紧挨着，那应该这么写<br><strong>View1.右边 = view2.左边 * 1 + 0</strong><br>这里的<code>=</code>表示的是位置相同的意思，另外除了等于以外还有<code>≤</code>和<code>≥</code>同样它们都是表示位置上关系。完成一个constraint后需要把它添加到constraint所关联的iteam的共同superView上。</p><p><strong>需要注意的是constraints是累积的，它们之间是不能互相覆盖。</strong>如果你有一个constraints，你再添加一个同类型的constraints并不覆盖前一个。</p><h2 id="Intrinsic-Content-Size"><a href="#Intrinsic-Content-Size" class="headerlink" title="Intrinsic Content Size"></a>Intrinsic Content Size</h2><p>苹果在使用Autolayout的原则里有一条是<strong>“视图是趋于自治的”</strong>，因此苹果鼓励用户在自定义view时自己实现Intrinsic Content Size，让view自己决定自己的大小。</p><p>Intrinsic Content Size指的是view能显示内容的最佳尺寸。例如，UILabel的最佳高度取决于它的字体大小，它的最佳宽度取决于它的字体还有所显示的内容。一个UIProgressView的最佳高度取决于它的样式，而宽度则没有要求。一个空白的UIView则在宽度和高度上都没有要求。</p><p>如果一个自定义的view的大小和其所显示的内容有关的话，就需要实现Intrinsic Content Size相关的方法。在实现Intrinsic Content Size的相关方法时你需要做两件事情：</p><ol><li>重写intrinsicContentSize方法，根据view显示的内容返回合适的intrinsic content size；</li><li>在有些影响到Intrinsic Content Size的情况发生的时候调用<code>invalidateIntrinsicContentSize</code>例如当UILabel的文本内容变化的时候就需要调用上述的方法。如果view只有在某一个维度上有Intrinsic Content Size，那在另一个维度上返回<code>UIViewNoIntrinsicMetric</code>或者<code>NSViewNoIntrinsicMetric</code>就可以了。</li></ol><p><strong>需要注意的是intrinsic content size不能依赖view的frame。</strong>例如根据frame按比例返回intrinsic content size就是不可行的。</p><h2 id="Sprint-amp-struts-VS-Autolayout"><a href="#Sprint-amp-struts-VS-Autolayout" class="headerlink" title="Sprint&amp;struts VS. Autolayout"></a>Sprint&amp;struts VS. Autolayout</h2><p>在Autolayout出现之前，我们使用<code>autoresizingMask</code>来描述当父视图的尺寸变化时子视图的动作。现在autolayout里使用Compression Resistance 和 Content Hugging来替代它们。不过为了兼容<code>autoresizingMask</code>，UIView在iOS6之后添加了一个新属性<code>translatesAutoResizingMaskIntoConstraints</code>(默认为YES)来自动把<code>autoresizingMask</code>转换成Constraints。</p><p>在这里可能会有人问那在Autolayout环境下还能继续使用设置frame的方式进行布局吗。答案肯定是<strong>能</strong>，因为Autolayout系统仅仅是在frame布局的过程前面添加了一个计算约束的过程，最后计算好的结果还是通过frame来应用的。</p><p><strong>这里可能会有人有过在Autolayout环境下设置frame不生效的经历</strong>，这里简单说下为什么。如果<code>requiresConstraintBasedLayout</code>被设置为<code>YES</code>则只能使用Autolayout进行布局，<br>否则就看<code>translatesAutoresizingMaskIntoConstraints</code>的设置，如果是YES则Autolayout和frame都可以进行布局，如果为NO则需要继续看是否存在<code>intrinsicContentSize</code>，如果存在则只能用Autolayout布局、不存在则Autolayout和frame都可以进行布局。</p><p>你可以给view的每个维度(就是x方向和y方向)设置Compression Resistance、Content Hugging优先级。不过这个优先级仅仅对定义了intrinsic content size的view才会生效。</p><p>在iOS上可以用<code>setContentHuggingPriority:forAxis:</code> 和 <code>setContentCompressionResistancePriority:forAxis:</code> 分别设置优先级(如果是NSVIew则是<code>setContentHuggingPriority:forOrientation:</code> 和 <code>setContentCompressionResistancePriority:forAxis:</code>)优先级的默认值是<code>NSLayoutPriorityDefaultHigh</code>或 <code>NSLayoutPriorityDefaultLow</code>.</p><p>最后有一点需要注意，如果设定intrinsic content size和上述的优先级的话，系统把这些解释成一系列的constraint。例如一个label的intrinsic content size为{100,30}，x/y方向的compression resistance 优先级是750，Content Hugging优先级是250，这些条件会生成4个constraint：</p><pre><code>H:[label(&lt;=100@250)]H:[label(&gt;=100@750)]V:[label(&lt;=30@250)]V:[label(&gt;=30@750)]</code></pre><h2 id="Frame-VS-Alignment-Rect"><a href="#Frame-VS-Alignment-Rect" class="headerlink" title="Frame VS. Alignment Rect"></a>Frame VS. Alignment Rect</h2><p>Autolayout在布局的时候不是操作view的frame而是alignment rect。这两者有一些非常容易让人忽略的细小差异，在大部分情况下他们功能都一样，但在某些场合alignment rect的功能可能更强大。</p><p>大家可能都遇到过这样一种情况，一个button设置一个比较小的图片（或者图片周围有大面积的透明区）就会照成按钮看来很小，而且在布局的时候若以frame来做的话就会形成代码上是“对齐了”，但看起来就是“不整齐” 的情况，这是如果用alignment rect就会完美地解决这个问题。</p><p>用alignment rect可以很灵活地自定义用于layout的区域，大部分情况下仅仅需要重写alignmentRectInsets方法就行了，它会让你返回一个相对于frame的Inset。如果上面的方法还不能满足需求则可以重写<code>alignmentRectForFrame:</code>和<code>frameForAlignmentRect:</code>这两个方法，这两个方法可以让你更加灵活的根据frame来返回对应的alignment rect，需要注意的是这两个方法有互逆关系，你必须要保证frame和alignment rect能通过这两个方法互相转换。</p><p><img src="/images/Autolayout-1/pic_1-1.png" alt=""></p><h2 id="Baseline-alignment"><a href="#Baseline-alignment" class="headerlink" title="Baseline alignment"></a>Baseline alignment</h2><p>如果对自定义的view用<code>NSLayoutAttributeBaseline</code>的方式布局的话需要自己实现相关的方法。在iOS平台需要实现<code>viewForBaselineLayout</code>方法，方法返回的view的bottom edge将被用作baseline，系统默认实现是直接返回view本身。注意返回的view只能是此方法调用者本身或者子view。在OS X上你需要实现baselineOffsetFromBottom来返回基于view的bottom edge的一个offset，默认返回0。</p><h2 id="Phases-of-Display"><a href="#Phases-of-Display" class="headerlink" title="Phases of Display"></a>Phases of Display</h2><p>使用AutoLayout之后，把view显示到屏幕上面大体分成3步。</p><p><img src="/images/Autolayout-1/pic_1-2.png" alt=""></p><ol><li>Update constraints，就是更新约束，把所有的约束更新到最新状态；</li><li>Layout views，根据约束布局调整View之间的距离，大小；</li><li>Display，调用drawRect绘制view。</li></ol><p>下面来讲一下具体的工作流程。</p><p> <strong>Update constraints</strong> 这个过程是从底向上的(从<code>subview</code>到<code>supperview</code>)，你可以通过调用<code>setNeedsUpdateConstraints</code>来主动触发这个过程，你对constraint的任何更改都会导致系统自动调用这个方法。还可以重写<code>updateConstraints</code>方法来添加应用于自定义view内部的constraint。</p><p><strong>Layout view</strong> 这个过程是自顶向下的(从<code>super</code> view到<code>subview</code>)，这一步实际上是应用上一步的约束的结果的过程，根据约束调整view的<code>frame</code>(在OS X)，或者view的<code>center</code>和<code>bounds</code>(在iOS)。你可以调用<code>setNeedsLayout</code>方法来主动触发这个过程。</p><p><strong>Display</strong> 这个过程是也是自顶向下的，也可以调用<code>setNeedsDisplay</code>来主动触发这个过程，重写<code>drawRect:</code>来添加一些自定义的绘制代码这个相信大家都已经非常熟悉了。</p><p><strong>需要注意的是这3个步骤并不是严格按照顺序依次发生的。</strong>基于约束的布局是一个迭代的过程。layout的改变可以影响到生成上一次layout的constraint，当其他的layout改变后它能再次触发更新约束的过程。不过这个也存在死循环的风险，就是在其他的layout改变时调用你自己实现的<code>layoutSubviews</code>方法。</p><p><img src="/images/Autolayout-1/pic_1-3.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a style="text-decoration:none;color:#1D39DD" href="http://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/" target="_blank" rel="external"><br>《Advanced Auto Layout Toolbox》 - objc.io</a></li><li><a style="text-decoration:none;color:#1D39DD" href="http://studentdeng.github.io/blog/2014/06/13/auto-layout/" target="_blank" rel="external">《AutoLayout 相关概念介绍和动画demo》 - 不会开机的男孩</a></li><li><a style="text-decoration:none;color:#1D39DD" href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/Introduction/Introduction.html" target="_blank" rel="external">《Auto Layout Guide》 - Apple</a></li></ul>]]></content>
    
    <summary type="html">
    
      Autolayout笔记:基本概念
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
</feed>
