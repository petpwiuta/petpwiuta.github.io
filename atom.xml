<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ney的技术博客</title>
  
  <subtitle>Learning，sharing，improving</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://petpwiuta.github.io/"/>
  <updated>2020-05-09T06:28:15.958Z</updated>
  <id>http://petpwiuta.github.io/</id>
  
  <author>
    <name>Ney</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bochs调试常用命令</title>
    <link href="http://petpwiuta.github.io/2020/05/09/Bochs%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://petpwiuta.github.io/2020/05/09/Bochs调试常用命令/</id>
    <published>2020-05-09T06:20:39.153Z</published>
    <updated>2020-05-09T06:28:15.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>Bochs是做系统开发常用的虚拟机，调试系统内核很方便。</p><p>安装Bochs一般是从源码编译再安装，而调试器属于可选功能，所以在编译Bochs时需要使用<code>--enable-debugger</code>和<code>--enable-disasm</code>标志开启调试模块。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-debugger --enable-disasm #后面还有其他选项，此处省略</span><br></pre></td></tr></table></figure><p>需要注意调试功能在 <strong>2.5.4</strong> 版本以上才有，确保下载的代码是高于这个版本的。</p><h3 id="2-常见的几个使用场景"><a href="#2-常见的几个使用场景" class="headerlink" title="2 常见的几个使用场景"></a>2 常见的几个使用场景</h3><h4 id="2-1-查看寄存器"><a href="#2-1-查看寄存器" class="headerlink" title="2.1 查看寄存器"></a>2.1 查看寄存器</h4><p>汇编代码中，调试最常用的功能就是查看寄存器的内容。</p><ul><li><code>r</code>  查看通用寄存器</li><li><code>sreg</code>  查看段寄存器</li><li><code>creg</code>  查看控制寄存器</li><li><code>dreg</code>  查看调试寄存器</li><li><code>info cpu</code>  查看所有寄存器</li></ul><h4 id="2-2-查找和定位代码"><a href="#2-2-查找和定位代码" class="headerlink" title="2.2 查找和定位代码"></a>2.2 查找和定位代码</h4><p>次常用的肯定是控制代码执行流程，代码执行到想要仔细跟踪的那个部分。</p><ul><li><p><code>b 内存地址</code>  设置断点</p><p>如<code>b 0x7c00</code>，在线性地址0x7c00处设置断点。</p></li><li><p><code>info break</code>  查看设置过的断点</p></li><li><p><code>c</code>  继续执行代码</p><p>一般设置断点后，想让代码恢复执行，就使用这个命令。</p></li><li><p><code>s</code>  单步执行</p><p>单步执行一行代码，和高级语言调试器的step into按钮类似，遇到函数调用会跳转到函数内部执行。单步执行命令也可以带参数，指定执行的次数，如 <code>s 100</code> 就是单步执行100次。</p></li><li><p><code>n</code>  执行下一行</p><p>它和单步执行类似，单步执行遇到循环和函数时会跳转到内部，而n命令会执行完循环和函数，类似于step over，这样在遇到大量的循环或者较长的函数时，可以用n命令来执行到下一行。</p><p>n命令能跳转到下一行是因为loop或者call执行有明显的结束标记（前者通过cx寄存器，后者通ret指令），如果遇到用jmp语句写的循环这种情况，没有明显结束标记的，可以用下面的u命令反汇编代码的地址，找到循环的下一行指令的地址，然后给该地址加一个断点就能达到同样的效果。</p></li><li><p><code>u</code>  反汇编代码</p><p>直接使用u命令会反汇编当前执行的指令，它可以加参数， <code>u /反汇编数量 起始地址</code> ，如 <code>u /20 0x7c00</code> 就是从0x7c00处开始，反汇编20条指令，如果没有起始地址就是从当前地址开始。</p><p>它还可以反汇编一个范围的代码，<code>u 起始地址 结束地址</code> ，如<code>u 0x7c00 0x7cff</code> 就是反汇编0x7c00到0x7cff的代码。</p></li></ul><h4 id="2-3-查看内存"><a href="#2-3-查看内存" class="headerlink" title="2.3 查看内存"></a>2.3 查看内存</h4><ul><li><code>x /nuf 地址</code>  查看线性地址处的内存内容。</li><li><code>xp /nuf 地址</code>  查看物理地址处的内存内容。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n 指定要显示的内存单元的数量</span><br><span class="line">u 显示的内存单元的大小，如下参数之一</span><br><span class="line">b 单个字节</span><br><span class="line">h 半个字(2 字节)</span><br><span class="line">w 一个字(4 字节)</span><br><span class="line">f 打印的格式。如下类型之一：</span><br><span class="line">x 按照十六进制形式打印</span><br><span class="line">d 按照十进制形式打印</span><br><span class="line">u 以无符号的10进制打印</span><br><span class="line">o 按照八进制形式打印</span><br><span class="line">t 按照二进制行是打印</span><br></pre></td></tr></table></figure><h4 id="2-4-Tips"><a href="#2-4-Tips" class="headerlink" title="2.4 Tips"></a>2.4 Tips</h4><p>Bochs还有一个比较有用的设计就是，当你输入指令后，直接按回车键（Enter Key）会重复上一次的命令。比如上一个命令是单步执行<code>s</code>，此时直接按回车键就相当于<code>s</code>的功能。</p><h3 id="3-调试指令手册"><a href="#3-调试指令手册" class="headerlink" title="3 调试指令手册"></a>3 调试指令手册</h3><h4 id="3-1-执行控制"><a href="#3-1-执行控制" class="headerlink" title="3.1 执行控制"></a>3.1 执行控制</h4><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>c</code> / <code>cont</code> / <code>continue</code></td><td style="text-align:left">继续执行</td></tr><tr><td style="text-align:left"><code>s</code> / <code>step</code> [count]</td><td style="text-align:left">执行count条指令，如果不指定参数，默认值为1</td></tr><tr><td style="text-align:left"><code>s</code> / <code>step</code> [cpu] [count]</td><td style="text-align:left">对于对称多处理器结构模拟，在cpu上执行count条指令，count的默认值为1</td></tr><tr><td style="text-align:left"><code>s</code> / <code>step</code> all [count]</td><td style="text-align:left">对于对称多处理器结构模拟，所有cpu上都执行count条指令，count的默认值为1</td></tr><tr><td style="text-align:left">Ctrl-C</td><td style="text-align:left">停止执行，返回到命令行提示符</td></tr><tr><td style="text-align:left">Ctrl-D</td><td style="text-align:left">如果在空行上执行，则退出调试器</td></tr><tr><td style="text-align:left"><code>q</code> / <code>quit</code> / <code>exit</code></td><td style="text-align:left">退出调试器，继续执行</td></tr></tbody></table></div><h4 id="3-2-断点操作"><a href="#3-2-断点操作" class="headerlink" title="3.2 断点操作"></a>3.2 断点操作</h4><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">① <code>vbreak</code> / <code>vb</code> segment:offset</td><td style="text-align:left">设置虚拟地址指令断点，segment和offset指段地址和段内偏移量</td></tr><tr><td style="text-align:left">② <code>lbreak</code> / <code>lb</code> addr</td><td style="text-align:left">在线性地址指令上设置断点</td></tr><tr><td style="text-align:left">③ <code>pbreak</code> / <code>bp</code> [*] addr</td><td style="text-align:left">在物理地址上设置断点</td></tr><tr><td style="text-align:left">④ <code>break</code> / <code>b</code> [*] addr</td><td style="text-align:left">同上。  * 符号是兼容GDB命令，为可选参数</td></tr><tr><td style="text-align:left"><code>info break</code></td><td style="text-align:left">显示当前所有断点状态</td></tr><tr><td style="text-align:left"><code>bpe</code> n</td><td style="text-align:left">开启断点</td></tr><tr><td style="text-align:left"><code>bpd</code> n</td><td style="text-align:left">关闭断点</td></tr><tr><td style="text-align:left"><code>delete</code> / <code>del</code> / <code>d</code>  n</td><td style="text-align:left">删除断点</td></tr></tbody></table></div><p><strong>注意</strong>：① ② ③ ④ 的命令都可以设置条件，即都可以变成条件断点。具体做法是在命令之后添加<code>if condition</code> ，如<code>vbreak 0x008:0x001 if &quot;条件表达式&quot;</code></p><h4 id="3-3-内存观察点"><a href="#3-3-内存观察点" class="headerlink" title="3.3 内存观察点"></a>3.3 内存观察点</h4><p>内存观察点类似于内存的监听器，当指定地址的内存产生读取或者写入事件时，会产生中断。</p><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>watch read/r</code> addr</td><td style="text-align:left">在物理地址addr上插入读观察点</td></tr><tr><td style="text-align:left"><code>watch write/w</code> addr</td><td style="text-align:left">在物理地址addr上插入一个写观察点</td></tr><tr><td style="text-align:left"><code>watch</code></td><td style="text-align:left">显示当前内存观察点的状态</td></tr><tr><td style="text-align:left"><code>watch stop</code></td><td style="text-align:left">当遇到观察点时，停止模拟执行（默认）</td></tr><tr><td style="text-align:left"><code>watch continue</code></td><td style="text-align:left">在遇到观察点时，不要停止模拟执行</td></tr><tr><td style="text-align:left"><code>unwatch</code> addr</td><td style="text-align:left">移除指定物理地址上的观察点</td></tr><tr><td style="text-align:left"><code>unwatch</code></td><td style="text-align:left">移除所有的观察点</td></tr><tr><td style="text-align:left"><code>trace-mem on/off</code></td><td style="text-align:left">开启/关闭 内存访问追踪</td></tr></tbody></table></div><h4 id="3-4-内存操作"><a href="#3-4-内存操作" class="headerlink" title="3.4 内存操作"></a>3.4 内存操作</h4><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>x</code> /nuf addr</td><td style="text-align:left">在线性地址addr处检查内存内容，nuf的解释在前面列出</td></tr><tr><td style="text-align:left"><code>xp</code> /nuf addr</td><td style="text-align:left">在物理地址 addr处查看内存内容，nuf的解释在前面列出</td></tr><tr><td style="text-align:left"><code>setpmem</code> addr datasize value</td><td style="text-align:left">在内存位置addr处设置datasize大小内存，值为 value</td></tr><tr><td style="text-align:left"><code>writemem</code> filepath addr datasize</td><td style="text-align:left">从线性地addr处dump出datasize个字节到文件filepath中</td></tr><tr><td style="text-align:left"><code>crc</code> addr1 addr2</td><td style="text-align:left">显示物理地址范围 addr1到addr2之间内容的 CRC值</td></tr></tbody></table></div><h4 id="3-5-查看信息"><a href="#3-5-查看信息" class="headerlink" title="3.5 查看信息"></a>3.5 查看信息</h4><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>r</code> / <code>reg</code> / <code>regs</code> / <code>registers</code></td><td style="text-align:left">查看通用寄存器内容</td></tr><tr><td style="text-align:left"><code>fp</code> / <code>fpu</code></td><td style="text-align:left">查看FPU寄存器内容</td></tr><tr><td style="text-align:left"><code>mmx</code></td><td style="text-align:left">查看MMX寄存器内容</td></tr><tr><td style="text-align:left"><code>sse</code> / <code>xmm</code></td><td style="text-align:left">查看SSE寄存器内容</td></tr><tr><td style="text-align:left"><code>ymm</code></td><td style="text-align:left">查看AVX寄存器内容</td></tr><tr><td style="text-align:left"><code>sreg</code> / <code>dreg</code> / <code>creg</code></td><td style="text-align:left">查看 段 / 调试 / 控制 寄存器内容</td></tr><tr><td style="text-align:left"><code>info</code> cpu</td><td style="text-align:left">查看所有寄存器内容</td></tr><tr><td style="text-align:left"><code>info</code> eflags</td><td style="text-align:left">查看标志寄存器内容</td></tr><tr><td style="text-align:left"><code>info</code> break</td><td style="text-align:left">显示当前所有断点状态</td></tr><tr><td style="text-align:left"><code>info</code> tab</td><td style="text-align:left">显示分页地址转换</td></tr><tr><td style="text-align:left"><code>info</code> device</td><td style="text-align:left">显示指定设备的状态</td></tr></tbody></table></div><h4 id="3-6-寄存器操作"><a href="#3-6-寄存器操作" class="headerlink" title="3.6 寄存器操作"></a>3.6 寄存器操作</h4><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>set</code> reg = expr</td><td style="text-align:left">修改reg寄存器值为expr</td></tr></tbody></table></div><p><strong>注意</strong>：只能修改通用寄存器和指令寄存器。不能够修改标志寄存器，段寄存器，浮点寄存器和SIMD寄存器。</p><h4 id="3-7-反汇编"><a href="#3-7-反汇编" class="headerlink" title="3.7 反汇编"></a>3.7 反汇编</h4><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>u</code> addr1 addr2</td><td style="text-align:left">在给定的线性地址范围内反汇编指令，包含start处指令，不包含end处指令</td></tr><tr><td style="text-align:left"><code>u</code> switch-mode</td><td style="text-align:left">在Intel和 AT&amp;T两种汇编风格之间切换</td></tr><tr><td style="text-align:left"><code>u</code> size = n</td><td style="text-align:left">设定反汇编命令的位数，使用0，16，32。值0意思是使用当前的CS段寄存器，默认值是0</td></tr><tr><td style="text-align:left"><code>set u on</code></td><td style="text-align:left">每次停止执行时就自动反汇编当前的指令</td></tr><tr><td style="text-align:left"><code>set u off</code></td><td style="text-align:left">和上一条相反，不自动反汇编</td></tr></tbody></table></div><h4 id="3-8-指令跟踪"><a href="#3-8-指令跟踪" class="headerlink" title="3.8 指令跟踪"></a>3.8 指令跟踪</h4><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>trace on</code></td><td style="text-align:left">反汇编每一条执行的指令。引起异常的指令都没有真正执行，因此也不会被跟踪</td></tr><tr><td style="text-align:left"><code>trace off</code></td><td style="text-align:left">关闭指令跟踪功能</td></tr></tbody></table></div><h4 id="3-9-指令编程环境"><a href="#3-9-指令编程环境" class="headerlink" title="3.9 指令编程环境"></a>3.9 指令编程环境</h4><p>Bochs的instrument功能，提供了运行时的各种钩子函数。它也是可选功能，在编译安装时需要开启<code>--enable-instrumentation</code>选项指定。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure [...] --enable-instrumentation</span><br><span class="line">./configure [...] --enable-instrumentation="instrument/stubs"</span><br></pre></td></tr></table></figure><p>自定义的代码要创建一个独立的目录，例如”instrument/myinstrument”，将”instrument/stubs”目录拷贝进去，然后使用如下的指令设定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure [...] --enable-instrumentation="instrument/myinstrument"</span><br></pre></td></tr></table></figure><p>指令命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instrument [command]    用[command]调用BX_INSTR_DEBUG_CMD指令回调</span><br></pre></td></tr></table></figure><h4 id="3-10-show指令"><a href="#3-10-show指令" class="headerlink" title="3.10 show指令"></a>3.10 show指令</h4><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>show</code></td><td style="text-align:left">打印当前的符号信息显示模式</td></tr><tr><td style="text-align:left"><code>show</code> mode</td><td style="text-align:left">当处理器切换模式时打印</td></tr><tr><td style="text-align:left"><code>show</code> int</td><td style="text-align:left">当产生中断时打印</td></tr><tr><td style="text-align:left"><code>show</code> call</td><td style="text-align:left">当产生调用时打印</td></tr><tr><td style="text-align:left"><code>show</code> ret</td><td style="text-align:left">当函数返回时打印</td></tr><tr><td style="text-align:left"><code>show</code> off</td><td style="text-align:left">关闭打印</td></tr><tr><td style="text-align:left"><code>show</code> dbg-all</td><td style="text-align:left">开启所有显示标志</td></tr><tr><td style="text-align:left"><code>show</code> dbg-none</td><td style="text-align:left">关闭所有显示标志</td></tr></tbody></table></div><h4 id="3-11-其他命令"><a href="#3-11-其他命令" class="headerlink" title="3.11 其他命令"></a>3.11 其他命令</h4><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>ptime</code></td><td style="text-align:left">打印当前的时间（从开始模拟到现在的ticks）</td></tr><tr><td style="text-align:left"><code>sb</code> delta</td><td style="text-align:left">在未来执行中插入一个时间断点delta。delta是一个64位的整数，跟着字母”L”，例如1000L</td></tr><tr><td style="text-align:left"><code>sba</code> time</td><td style="text-align:left">在时间time处插入一个时间断点 。time 同上面的delta</td></tr><tr><td style="text-align:left"><code>print-stack</code> [num]</td><td style="text-align:left">打印栈顶端的num个字</td></tr><tr><td style="text-align:left"><code>modebp</code></td><td style="text-align:left">触发CPU模式转换断点</td></tr><tr><td style="text-align:left"><code>ldsym</code> [global] filename [offset]</td><td style="text-align:left">从文件filename加载符号。</td></tr></tbody></table></div><h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h3><ul><li><a href="http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html#AEN4220" target="_blank" rel="noopener">8.14. Using Bochs internal debugger</a></li><li><a href="http://bochs.sourceforge.net/cgi-bin/lxr/source/instrument/instrumentation.txt" target="_blank" rel="noopener">bochs/instrument</a></li></ul>]]></content>
    
    <summary type="html">
    
      Bochs调试常用命令
    
    </summary>
    
      <category term="CS基础" scheme="http://petpwiuta.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>进入32位保护模式（四）：中断和进程</title>
    <link href="http://petpwiuta.github.io/2020/05/09/%E8%BF%9B%E5%85%A532%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E4%B8%AD%E6%96%AD%E5%92%8C%E8%BF%9B%E7%A8%8B/"/>
    <id>http://petpwiuta.github.io/2020/05/09/进入32位保护模式（四）：中断和进程/</id>
    <published>2020-05-09T06:15:41.986Z</published>
    <updated>2020-05-09T06:15:41.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断就是打断处理器当前的执行流程，去执行另外一些和当前工作不相干的指令，执行完之后，还可以返回到原来的程序流程继续执行。中断是处理器必备的机制，下面就来简单说一下中断的发生以及处理过程。</p><h4 id="外部硬件中断"><a href="#外部硬件中断" class="headerlink" title="外部硬件中断"></a>外部硬件中断</h4><p>从处理器外部产生的中断叫外部中断。事有轻重缓急，中断也分为两种，一种是必须要马上处理的，叫做非屏蔽中断（Non Maskable Interrupt，NMI）。另外一种可以允许延迟处理，叫可屏蔽中断（Interrupt，INTER）。这两种中断是各通过一条信号线引入处理器内部，所以总共有两条中断信号线接入处理器。</p><p>当中断发生时，处理器通过中断引脚NMI和INTR得到通知。此外它还应当知道发生了什么事，以便采取适当的处理措施。每种类型的中断都被统一编号，这称为中断类型号、中断向量或者中断号。</p><p><img src="/images/进入32位保护模式（四）：中断和进程/32Model_4_1.png" alt="32Model_4_1" style="zoom:50%;" /></p><h5 id="非屏蔽中断"><a href="#非屏蔽中断" class="headerlink" title="非屏蔽中断"></a>非屏蔽中断</h5><p>由于不可屏蔽中断的特殊性——几乎所有触发NMI的事件对处理器来说都是致命的，也不可恢复。所以这种情况下，就没有抢救的必要了。所以在实时模式下NMI中断的中断号统一都是2，不再区分更详细的情况。</p><h5 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h5><p>可屏蔽中断通过INTR引脚进入处理器，处理器每次只能处理一个中断。而且多个设备同时发出中断请求的几率也是很高的，所以需要一个中断代理来处理多设备以及并发仲裁的问题。在个人计算机中，用得最多的中断代理就是8259芯片，即中断控制器，从8086处理器开始，它就一直提供着这种服务。即使是现在，在绝大多数单处理器的计算机中，也依然有它的存在。</p><p>Intel处理器允许256个中断，中断号的范围是0~255，8259负责提供其中的15个，但中断号并不固定，允许软件根据自己的需要灵活设置中断号，以防止发生冲突。该中断控制器芯片有自己的端口号，可以像访问其他外部设备一样用in和out指令来改变它的状态，包括各引脚的中断号。所以它又叫可编程中断控制器。</p><p>每片8259只有8个中断输入引脚，而在个人计算机上使用它，需要两块。如图所示，第一块8259芯片的代理输出INT直接送到处理器的INTR引脚，这是主片（Master）；第二块8259芯片的INT输出送到第一块的引脚2上，是从片（Slave），两块芯片之间形成级联（Cascade）关系。</p><p><img src="/images/进入32位保护模式（四）：中断和进程/32Model_4_2.png" alt="32Model_4_2" style="zoom:50%;" /></p><p>如此一来，两块8259芯片可以向处理器提供15个中断信号。当时，接在8259上的15个设备都是相当重要的，如PS2键盘和鼠标、串行口、并行口、软磁盘驱动器、IDE硬盘等。现在，这些设备很多都已淘汰或者正在淘汰中，根据需要，这些中断引脚可以被其他设备使用。</p><p>如图所示，8259的主片引脚 0（IR0）接的是系统定时器/计数器芯片；从片的引脚 0（IR0）接的是实时时钟芯片RTC。在8259芯片内部，有中断屏蔽寄存器（Interrupt Mask Register，IMR），这是个8位寄存器，对应着该芯片的8个中断输入引脚，对应的位是0还是1，决定了从该引脚来的中断信号是否能够通过8259送往处理器（0表示允许，1表示阻断，和一般的逻辑是反过来的）。当外部设备通过某个引脚送来一个中断请求信号时，如果它没有被IMR阻断，那就可以被送往处理器。8259的主片的端口号是0x20和0x21，从片的端口号是0xa0和0xa1，可以通过这些端口访问8259芯片，设置它的工作方式，包括IMR的内容。</p><p>中断能否被处理，除了看8259芯片外，还取决于处理器。在处理器内部，标志寄存器有一个标志位IF，这就是中断标志（Interrupt Flag）。当为0时，所有从处理器INTR引脚来的中断信号都被忽略掉；当其为1时，处理器可以接受和响应中断。IF标志位可以通过两条指令 cli / sti 来关闭 / 开启中断。</p><h5 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h5><p>中断处理程序本质就是处理器要执行一段与该中断有关的程序。处理器可以识别256个中断，那么理论上就需要256段程序。这些程序的入口点组成一个数组，放在一个指定的位置。这个由入口点组成的数组就叫中断向量表。在实模式下，中断向量表从物理地址0x00000开始，到0x003结束，共IKB的空间。在保护模式下，IDT寄存器保存了中断向量表的起始地址。</p><h4 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h4><p>内部中断发生在处理器内部，是由执行的指令引起的。比如，当处理器检测到div或者idiv指令的除数为零时，或者除法的结果溢出时，将产生中断 0（0号中断），这就是除法错中断。</p><p>再比如，当处理器遇到非法指令时，将产生中断6。非法指令是指指令的操作码没有定义，或者指令超过了规定的长度。操作码没有定义通常意味着那不是一条指令，而是普通的数。</p><p>内部中断不受标志寄存器IF位的影响，也不需要中断识别总线周期，它们的中断类型是固定的，可以立即转入相应的处理过程。</p><h4 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h4><p>软中断是由int指令引起的中断处理。这类中断也不需要中断识别总线周期，中断号在指令中给出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int3</span><br><span class="line">int imm8</span><br><span class="line">into</span><br></pre></td></tr></table></figure><p><code>int3</code>是断点中断指令，机器指令码为CC。这条指令在调试程序的时候很有用。指令都是连续存放的，所谓的断点，就是某条指令的起始地址。int3是单字节指令，这是有意设计的。当需要设置断点时，可以将断点处那条指令的第1字节改成0xc，原字节予以保存。当处理器执行到int3时，即发生3号中断，转去执行相应的中断处理程序。</p><p>注意，<code>int3</code>和<code>int</code> 3不是一回事。前者的机器码为CC，后者则是CD03，这就是通常所说的int n，其操作码为0xCD，第2字节的操作数给出了中断号。</p><p>into是溢出中断指令，机器码为0xCE。处理器执行这条指令时，如果标志寄存器OF位是1，将会产生4号中断。反之这条指令什么也不做。</p><h5 id="BIOS中断"><a href="#BIOS中断" class="headerlink" title="BIOS中断"></a>BIOS中断</h5><p>调用中断处理程序比较方便，知道中断号以及参数传递规则就行了。事实上操作系统加载完自己之后，以中断处理程序的形式提供了很多基础功能，如硬盘读写功能，并把该例程的地址填写到中断向量表中。这样，无论在什么时候，用户程序需要该功能时，直接发出一个软中断即可。</p><p>在以软中断形式提供的功能中，最有名的是BOS中断，之所以称为BOS中断，是因为这些中断功能是在计算机加电之后，BIOS程序执行期间建立起来的。换句话说，这些中断功能在加载和执行主引导扇区之前，就已经可以使用了。</p><p>BIOS可能会为一些简单的外围设备提供初始化代码和功能调用代码，并填写中断向量表，但也有一些BIOS中断是由外部设备接口自己建立的。</p><p>首先，每个外部设备接口，包括各种板卡，如网卡、显卡、键盘接口电路、硬件控制器等，都有自己的只读存储器（Read Only Memory，ROM），类似于BIOS芯片，这些ROM中提供了它自己的功能调用例程，以及本设备的初始化代码。按照规范，前两个单元的内容是0x55和0xAA，第三个单元是本ROM中以512字节为单位的代码长度；从第四个单元开始，就是实际的ROM代码。</p><p>其次，我们知道，从内存物理地址A0000开始，到FFFF结束，有相当一部分空间是留给外围设备的。如果设备存在，那么，它自带的ROM会映射到分配给它的地址范围内。</p><p>在计算机启动期间，BIOS程序会以2KB为单位搜索内存地址C0000~E0000之间的区域。当它发现某个区域的头两个字节是0x55和0xAA时，那意味着该区域有ROM代码存在，是有效的。接着，它对该区域做累加和检査，看结果是否和第三个单元相符。如果相符，就从第四个单元进入。这时，处理器执行的是硬件自带的程序指令，这些指令初始化外部设备的相关寄存器和工作状态，最后，填写相关的中断向量表，使它们指向自带的中断处理过程。</p><h4 id="保护模式下中断向量的处理"><a href="#保护模式下中断向量的处理" class="headerlink" title="保护模式下中断向量的处理"></a>保护模式下中断向量的处理</h4><p>中断是随机产生的，不可预测。但是它发生时，当前处理器当前总会有个任务在执行。这个任务可能是在内核空间执行也可能在用户空间执行。如果中断处理代码的特权等级比当前任务的级别高，比如中断是ring0级别的，当前任务是ring3，则会切换栈。否则会直接使用当前任务的栈。</p><p>中断的处理过程如下：</p><ul><li>栈切换<ul><li>如果中断处理代码的特权等级比当前任务的级别高，则需要从TSS中选择合适的新栈，然后把SS和SP的值压入新栈。如图1.4（b）</li><li>如果级别相同，就没有栈的切换，直接使用当前栈。如图1.4（a）所示</li></ul></li><li>处理器把EFLAGS、CS和EIP的当前状态压入新栈</li><li>对于有错误代码的异常，处理器还要把错误代码压入新栈，紧挨着EIP之后，</li></ul><p><img src="/images/进入32位保护模式（四）：中断和进程/32Model_4_3.png" alt="1.4-a" style="zoom:50%;" /></p><p><img src="/images/进入32位保护模式（四）：中断和进程/32Model_4_4.png" alt="1.4-b" style="zoom:50%;" /></p><p>从中断中返回的过程如下：</p><ul><li>在执行完中断处理程序以后，如果有错误代码，需要先把错误代码出栈</li><li>从栈中依次弹出EIP和CS以及EFLAGS寄存器的值</li><li>栈恢复<ul><li>判断当前的特权级别和弹出的CS选择子的特权级别，如果不同，说明之前有过栈切换。从栈中再弹出ESP和SS寄存器的值</li><li>如果相同，则继续使用当前栈</li></ul></li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h4><p>英特尔提供了保护模式下切换任务的方法，就是任务门。任务门类似于中断，需要先注册再使用。不过英特尔的设计不够灵活，工业界并没有按照英特尔的思路来使用任务门。所以在现代操作系统中已经很少使用任务门来进行进程切换了。</p><p>现代的系统普遍采用的是分时多任务处理，普遍都是用定时器中断来进行任务切换。</p><h4 id="用中断实现任务切换"><a href="#用中断实现任务切换" class="headerlink" title="用中断实现任务切换"></a>用中断实现任务切换</h4><p>现代的操作系统绝大部分都是使用分时多任务，所以往往使用时钟中断来进行进程调度。时钟中断也是中断的一种，所以上面说的中断的一系列步骤在任务切换时都会发生。不过既然是任务切换，那肯定有现场保存以及恢复现场的逻辑。任务切换就是在中断的基础上增加了现场的保存和恢复。</p><h4 id="sysenter和sysexit指令"><a href="#sysenter和sysexit指令" class="headerlink" title="sysenter和sysexit指令"></a>sysenter和sysexit指令</h4><p>使用中断进行任务切换时，会有一系列的特权级别校验、上下文寄存器压栈等操作。本来这个作为普通的中断来说是可以忍受的，因为系统中的外部中断没有那么频繁。但是当中断用来进行内核态和用户态切换，大量使用后，带来的性能问题逐渐明显。</p><p>所以英特尔专门设计量<code>sysenter</code>和<code>sysexit</code> 这两个指令来实现内核态和用户态的切换。这两个指令没有中断的校验和压栈动作，性能要好得多。（校验和压栈的操作已经用其他设计来替代了）。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/kernel/l-k26ncpu/index.html" target="_blank" rel="noopener">Linux 2.6 对新型 CPU 快速系统调用的支持</a></li></ul>]]></content>
    
    <summary type="html">
    
      操作系统启动模块之 中断和进程
    
    </summary>
    
      <category term="CS基础" scheme="http://petpwiuta.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>进入32位保护模式（三）：分页式内存管理</title>
    <link href="http://petpwiuta.github.io/2020/05/09/%E8%BF%9B%E5%85%A532%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%86%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://petpwiuta.github.io/2020/05/09/进入32位保护模式（三）：分页式内存管理/</id>
    <published>2020-05-09T06:15:11.151Z</published>
    <updated>2020-05-09T06:15:11.152Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分页式内存管理"><a href="#分页式内存管理" class="headerlink" title="分页式内存管理"></a>分页式内存管理</h3><p>以前的段式内存管理在分配内存时，随着系统长时间运行，内存会变得碎片化，空闲的区域可能会小于需要的大小，或者空闲区域又远大于需要的大小。为了解决这个问题，英特尔从80386开始，引入了分页式内存管理。</p><p>分页式内存管理的主要思路就是把内存分解成固定大小的页，以前需要多少字节的需求现在转化成请求 “字节数/页面大小(当然，有小数时会向上取整)” 个页面。页面的最小单位是4KB，也就是4096字节，用十六进制表示就是0x1000，因此第1个页面的物理地址是0x00000000，第2个是0x00001000，第3个是0x00002000，以此类推。最终可以把4GB的内存划分成1048576个页，很显然，所有物理页面的地址最低12位始终是0。</p><p>在分页模式下，操作系统可以创建一个为所有任务共用的4GB虚拟内存空间，也可以为每一个任务创建独立的4GB虚拟内存空间。当一个程序加载时，操作系统既在要左边的虚拟内存中分配段空间，又要在右边的物理内存中分配相应的页面。因此，第一个步骤是寻找空闲的段空间，该段空间既没有被其他程序使用，也没有被同一程序内的其他段使用。</p><p><img src="/images/进入32位保护模式（三）：分页式内存管理/32Model_3_1.png" alt="32Model_3_1" style="zoom:50%;" /></p><p>如图所示，假设己经成功找到并分配了一个段空间，基地址为0x00200000，长度为8200字节。 页的最小尺寸是4KB，也就是4096字节。因此，8200字节的段，需要占用3个页面，其中最后一个页面只用了8个字节，其余都浪费着，但这无关紧要，如果允许页共享，多个段或多个程序可以用同一个页来存放各自的数据。 </p><p>在分段之后，操作系统的任务是把段拆开，并分别映射到物理页。注意，段必须是连续的，但不要求所分配的页都是连续的。在实际中，内存页会频繁分配和回收，空闲页会零零散散地分布在物理内存中，一般不会是连续的。分配页面时，操作系统会搜索那些空闲的页，并分配给程序使用，所分配页面的总长度要大于等于段长度。 </p><p>作为一个具体的例子，操作系统为程序分配了一个段，段是在虚拟内存中分配的，起始地址为0x00200000。该段有8200字节，需要分配3个页面。为此，操作系统在物理内存中搜索可用的空闲页，这二个页面的物理地址分别是0x00002000、0x00004000 和 0x00007000。接下来，要建立线性地址和页之间的对应关系，在图中，0x00200000～0x00200FFF 对应着物理地址为 0x00002000 的页，0x00201000～0x00201FFF 对应着物理地址为 0x00004000 的页， 0x00202000～0x00202007 对应着物理地址为 0x00007000 的页。当然，这里只是示例，线性地址区间和页的对应关系可以随意。 </p><p>4GB虚拟内存空间不可能用来保存任何数据，因为它是虚拟的，它只是用来指示内存的使用情况。当操作系统加载一个程序并创建为任务时，操作系统在虚拟内存空间寻找空闲的段，并映射到空闲的页。然后，到真正开始加载程序时，再把原本属于段的数据按页的尺寸拆开，分开写入对应的页中。 从段部件输出的是线性地址，或者叫虚拟地址。为了根据线性地址找到页的物理地址，操作系统必须维护一张表，把线性地址转换成物理地址，这是一个反过程。 如图16-4所示，因为有 1048576 个页，所以转换表也有 1048576 项。这是个一维表格，每个表项占4字节，内容为页的物理地址。这个表格的用法是这样的：因为页的尺寸是4KB，故线性地址的低12位可用于访问页内偏移，高20位可用于指定一个物理页。因此，把线性地址的高 20位当成索引，乘以4，作为表内偏移量，从表中取出一个双字，那就是该线性地址所对应的页的物理地址。</p><p> <img src="/images/进入32位保护模式（三）：分页式内存管理/32Model_3_2.png" alt="32Model_3_2" style="zoom:50%;" /></p><p>如图所示，如果执行指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx,[0x2002]</span><br></pre></td></tr></table></figure><p>那么，段部件用段地址 0x00200000 加上指令中给出的偏移量 0x2002，得到线性地址 0x00202002。线性地址的高20位是表格索引，即0x00202。将索引乘以4，得到0x00808，这就是表内偏移。看图，从该单元可以取出一个双字0x00007000，这就是页物理地址。 </p><p>线性地址的低12位是页内偏移量，用页物理地址加上页内偏移量，就是最终的物理内存地址。0x00007000加上0x002，得到0x00007002，这就是实际要访问的物理内存地址。</p><p>当程序加载时，操作系统会首先在虚拟内存中分配段。然后，根据段需要分成多少页，来搜索空闲页面。当段较大时，要按页的尺寸分成好几个地址区段，操作系统用每个区段的首地址，取高20位，乘以4，作为偏移量访问表格，并将分配给该区段的页的物理地址写入该表项。最后，把原本需要写入每个区段的程序数据，写到对应的页中。 </p><p>在页式内存管理中很重要的一点是，页面的管理和分配是独立的，和分段以及段地址没有关系。操作系统所要做的，就是寻找空闲页面，把它分配给需要的段，并将页的物理地址填写到映射表内。很显然，线性地址，包括线性地址空间，和页面分配机制也没有关系。 </p><p>基于以上特点，一般来说，每个任务都可以拥有 4GB的虚拟内存空间；同时，每个任务都有自己的页映射表，如图所示。</p><p><img src="/images/进入32位保护模式（三）：分页式内存管理/32Model_3_3.png" alt="32Model_3_3" style="zoom:50%;" /></p><p>尽管有很多任务，而且每个任务都有自己的4GB虚拟内存空间，但在整个系统中，物理页面是统一调配的。考虑这样一种情景：任务A有一个段，段基地址为 0x00050000，段长度为3000字节，操作系统为它分配了一个物理地址为0x08001000的页。过了 一会儿，另一个任务B加载了，它也有个段，段基地址也是0x00050000，段长度为4096字节。此时，操作系统则分配另个不同的、物理地址为0x00700000的页。在这种情况下，在任务 A内访问线性地址0x00050006，访问的其实是物理地址0x08001006；在任务B内访问同样的线性 地址时，访问的其实是物理地址0x00700006。</p><h3 id="页目录和页表"><a href="#页目录和页表" class="headerlink" title="页目录和页表"></a>页目录和页表</h3><p>为了完成从虚拟地址（线性地址）到物理地址的转换，操作系统应当为每个任务准备一张页映射表。因为任务的虚拟地址空间为4GB，可以分出1048576个页，所以，映射表需 要1048576个表项，用于存放页的物理地址。又因为每个表项占4字节，所以，映射表的总大小为4MB。 不过如果每个任务都要有一个4MB的映射表，那很浪费空间，而且也不是所有的任务都需要访问所有的内存。所以这个设计在实际中有变通，就是层次化的分页结构。 </p><p>分页结构层次化的主要手段是不采用单一的映射表，取而代之的是页目录表和页表。如图16-6 所示，首先，因为4GB的虚拟内存空间对应着1048576个4KB的页，可以随机地抽取这些页，将 它们组织在1024个页表内，每个页表可以容纳1024个页。页表内的每个项目叫做页表项，占4字节，存放的是页的物理地址，故每个页表的大小是4KB，正好是一个标准页的长度。 </p><p>注意，页在页表内的分布是随机的，哪个页位于哪个页表中，这是没有规律的。在一个真实的系统中，老任务不断被关闭，新任务不断被创建并投入运行，页面的回收和再分配没有什么规律可言。 </p><p>由于页表中存放的是页的物理地址，故每个页表项占4字节，这样，每个页表占4096字节， 正好是个物理页的大小，可以很方便地用个物理页来定义每个页表。 </p><p>如图所示，在将1048576个页归拢到1024个页表之后，接着，再用一个表来指向1024 个页表，这就是页目录表（Page Directory Table, PDT)，和页表一样，页目录项的长度为4字节，填写的是页表的物理地址，共指向1024个表页，所以页目录表的大小是4KB，正好是一个标准页的长度。 </p><p><img src="/images/进入32位保护模式（三）：分页式内存管理/32Model_3_4.png" alt="32Model_3_4" style="zoom:50%;" /></p><p>这样的层次化分页结构是每个任务都拥有的，或者说，每个任务都有自己的页目录和页表。 如图16-7所示，在处理器内部，有一个控制寄存器CR3，存放着当前任务页目录的物理地址，故又叫做页目录基址寄存器（Page Directory Base Register, PDBR)。</p><p> 每个任务都有自己的任务状态段（TSS)，它是任务的标志性结构，存放了和任务相关的各种数据，其中就包括了CR3寄存器域，存放了任务自己的页目录物理地址。当任务切换时，处理器切换到新任务开始执行，而CR3寄存器的内容也被更新，以指向新任务的页目录位置。相应地， 页目录又指向一个个的页表，这就使得每个任务都只在自己的地址空间内运行。 从图16-7中还可以看出，页目录和页表也是普通的页，混迹于全部的物理页中。它们和普通 页的不同之处仅仅在于功能不一样。当任务撤销之后，它们和任务所占用的普通页一样会被回收，并分配给其他任务。</p><h3 id="逻辑地址到物理地址"><a href="#逻辑地址到物理地址" class="headerlink" title="逻辑地址到物理地址"></a>逻辑地址到物理地址</h3><p>对于英特尔处理器来说，有关分页，最简单和最基本的机制就是这些：CR3寄存器给出了页目录的物理基地址；页目录给出了所有页表的物理地址而每个页表给出了它所包含的页的物理地址。那如何用这种层次性的分页结构把线性地址转换成物理地址？  这里举个例子。</p><p>假如某个任务加载后，操作系统根据它的实际情况，在其4GB虚拟地址空间里创建了一个 段，段的起始地址为0x00800000，段界限值为0x5000，字节粒度。当该任务执行时，段寄存器 DS指向该段。又假设执行了下面一条指令： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx [0x1050]</span><br></pre></td></tr></table></figure><p>此时，段部件会输出线性地址0x00801050。在没有开启分页机制时，这就是要访问的物理内存地址，但现在开启了分页机制，所以，这是一个虚拟地址，要经过页部件的转换，才能得到物理地址。 </p><p><img src="/images/进入32位保护模式（三）：分页式内存管理/32Model_3_5.png" alt="32Model_3_5" style="zoom:50%;" /></p><p>如图所示，处理器的页部件专门负责线性地址到物理地址的转换工作。它首先将段部件送来的32位线性地址截成3段，分别是高10位、中间的10位和低12位。高10位是页目录的索引，中间10位是页表的索引，低12位则作为页内偏移来用。 </p><p>当前任务页目录的物理地址在处理器的CR3寄存器中，假设它的内容为0x00005000。段管理部件输出的线性地址是0x00801050，其二进制的形式为0000 0000 1000 0000 0001 0000 0101 0000。高10位为 0000000010，也就是十六进制的0x002，它是页目录表内的索引，处理器将它乘以4（因为每个目录项为4字节），作为偏移量访问页目录。最终，处理器从物理地址00005008 处取得页表的物理地址 0x08001000。</p><p>线性地址的中间10位为二进制的0000000001，即0x001，处理器要用它作为页表内的索引来取得页的物理地址。处理器将该索引值乘以4，作为偏移量访问页表。最终，处理器又从物理地址 08001004处取得页的物理地址，这就是我们一直努力寻找的那个页。 </p><p>页的物理地址是0x0000C000，而线性地址的低12位是数据所在的页内偏移量。故处理器将它们相加，得到物理地址0x0000C050，这就是线性地址0x00801050所对应的物理地址，要访问的数据就在这里。 </p><p>当任务加载时，操作系统先创建虚拟的段，并根据段地址的高20位决定它要用到哪些页目录项和页表项。然后，寻找空闲的页，将原本应该写入段中的数据写到一个或者多个页中，并将页的物理地址填写到相应的页表项中。只有这样做了，当程序运行的时候，才能以相反的顺序进行地址变换，并找到正确的数据。</p>]]></content>
    
    <summary type="html">
    
      操作系统启动模块之 内存分页
    
    </summary>
    
      <category term="CS基础" scheme="http://petpwiuta.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>进入32位保护模式（二）：任务和特权级别</title>
    <link href="http://petpwiuta.github.io/2020/05/09/%E8%BF%9B%E5%85%A532%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BB%BB%E5%8A%A1%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E5%88%AB/"/>
    <id>http://petpwiuta.github.io/2020/05/09/进入32位保护模式（二）：任务和特权级别/</id>
    <published>2020-05-09T06:14:52.391Z</published>
    <updated>2020-05-09T06:14:52.391Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务以及任务的LDT和TSS"><a href="#任务以及任务的LDT和TSS" class="headerlink" title="任务以及任务的LDT和TSS"></a>任务以及任务的LDT和TSS</h3><p>现代CPU支持多任务执行，这个支持在硬件上也有对应的表现。最重要的就是LDTR和TR这两个寄存器。LDTR和GDTR类似，不过LDTR所指向的是表示的是每个任务自己私有的内存段（Local Descriptor Table）。而TR指向的是保存任务执行状态的内存段（Task State Segment）。</p><p>每个任务都会有自己的LDT和TSS来保存任务的内存以及执行状态，当操作系统运行多个任务时，会有多个LDT&amp;TSS对。当要切换到哪个任务时，CPU会把将要切换的任务的LDT和TSS加载到LDTR和TR寄存器，并开始执行。</p><p>因为LDT的出现使得任务能访问的内存区域分成了两部分，即全局空间和局部空间。全局空间包含了操作系统的段，以及常用的代码库。而局部空间则包含了程序自己的数据和代码。当任务调用了操作系统提供的服务时，处理器会转入全局空间执行，结束后会回落到任务自己的局部空间。</p><p><img src="/images/进入32位保护模式（二）：任务和特权级别/32Model_2_1.png" alt="32Model_2_1" style="zoom:50%;" /></p><h3 id="特权级别"><a href="#特权级别" class="headerlink" title="特权级别"></a>特权级别</h3><p>特权级别是在段描述符以及段选择子中的一个数值，用于表示控制访问权限，称之为DPL（Descriptor Privilege Level）。Intel的CPU规定了DPL有4个级别，从大到小分别是0/1/2/3，最高级别是0，最低级别是3。一般给操作系统的代码和数据的级别是0，操作系统提供的服务是1或者2，而应用程序级别一般是最低的3。</p><p>在保护模式下所有的内存访问都需要通过GDT来进行，GDT表项中有DPL字段，它规定了每个内存段的特权级别。对于数据段来说，它规定了访问自己所应当具备的最低特权级别，如果一个数据段的DPL是2，那就只有0/1/2这3个级别能访问。</p><p>当处理器正在一个代码段中取指令和执行指令时，那个代码段的特权级别就叫CPL（Current Privil Level），正在执行的这个代码段，其选择子位于段寄存器CS中，其最低两位就是当前特权等级的数值。</p><h3 id="依从段和调用门"><a href="#依从段和调用门" class="headerlink" title="依从段和调用门"></a>依从段和调用门</h3><p>代码的DPL级别检查很严格，一般来说控制转移只允许发生在两个特权级别相同的代码段之间。如当前特权级别为2，则不允许转移到DPL为0、1、2的代码上执行。不过，为了让特权级别低的程序可以调用高特权级别的操作系统函数，处理器也提供了对应的办法：它们是依从段和调用门。</p><p>第一种办法是把一个段定义成可以依从的。就是在GDT中注册内存段时，把TYPE中的C位设置为1，这样的代码段成为依从代码，可以从特权级别比它低的程序调用。反之如果C位是0，则只能被同级别的调用。</p><p>调用依从段的代码也有一定条件，就是当前CPL不能高于依从段，即在数值上CPL ⩾ 目标代码的段DPL。如果一个依从段DPL是1，则只能1，2，3级别的程序才能调用，0级别的是不能调用的。这里可能会有点疑问，为什么高级别的代码反而不能调用低级别的代码了？这是因为操作系统等高可靠的代码不允许使用可靠性不如它的代码，所以不允许将控制流程从较高的特权级别转移到较低级别。</p><p>而且依从段的代码不是在它的DPL特权级别上运行，而是在发起调用者的特权级别上运行，即当控制流转移到依从段时，CS寄存器的CPL不发生变化，被调用过程的特权等级依从于调用者，这也就是它为什么叫做“依从”段的原因。</p><p>第二种办法是使用调用门。调用门是一种描述符，叫做门描述符。和段描述符不同，段描述符用于描述内存段，门描述符则用于描述可执行代码。不过虽然和段描述符类型不同，但它本质上也是描述符，所以它也是要在GDT或者LDT中定义后才能使用。</p><p><img src="/images/进入32位保护模式（二）：任务和特权级别/32Model_2_2.png" alt="32Model_2_2" style="zoom:50%;" /></p><p>调用门描述符定义了目标代码所在的代码段的选择子，以及段内偏移，上图的TYPE为1100表示调用门。</p><p>想要使用调用门，可以用<code>jmp far</code>或者<code>call far</code>指令，并把调用门描述符的选择子作为参数。</p><p>使用<code>jmp far</code>指令，CPU会跳转到调用门所定义的代码中执行，但当前特权级别不会改变。但如果是用<code>call far</code>的话，当前特权级别会提升到目标代码段的特权级别。因为call指令用到了栈，栈段的特权级别必须同当前特权级别一致。因此，还要切换栈，即从低特权级的栈切换到高特权级的栈。如一个特权级为3的程序必须使用3级别的栈，而它通过调用门进入0特权级别时，特权级别从3变成0，因此栈也要跟着切换，从3级别的栈切换到0级别的栈。这主要是为了防止栈数据交叉引用以及栈空间不足。</p><p>为了切换栈，每个任务除了自己固有的栈外，还需要额外定义几套栈，数量取决于自己的特权级别，如果是0则不需要定义，如果是1则需要定义一套1级别的栈，如果是3则需要定义0、1、2这三套栈。这些额外创建的栈，其描述符位于自己的LDT中，同时还需要在TSS中登记。因为在切换任务时，这些栈会由处理器自动加载。</p><p>调用门描述符中的DPL和目标代码段描述符的DPL用于决定哪些特权级别的程序可以调用此门。具体的规则时必须同时符合以下两个条件才行：</p><ul><li>当前特权级别CPL和请求特权级别RPL高于或等于调用门描述符的DPL。即在数值上<ul><li>CPL ⩽ 调用门描述符DPL</li><li>RPL ⩽ 调用门描述符DPL</li></ul></li><li>当前特权级别CPL低于或等于目标代码描述符的DPL。即在数值上<ul><li>CPL ⩾ 目标代码段描述符DPL</li></ul></li></ul><p>综合起来就是一个不等式，即在数值上：调用门描述符的DPL ⩽ 调用者的CPL和RPL ⩽ 目标代码段描述符DPL</p><h3 id="TSS段"><a href="#TSS段" class="headerlink" title="TSS段"></a>TSS段</h3><p>TSS段是CPU进行任务切换的具体实体，它和之前讲的普通内存段类似，也是一块内存区域，着块内存区域也需要等级到GDT中，不过它的类型位是二进制的1001，表示它是一个TSS段，当中断或跳转指令遇到TSS段时，就会切换到TSS段所指向的任务。</p><p><img src="/images/进入32位保护模式（二）：任务和特权级别/32Model_2_3.png" alt="32Model_2_3" style="zoom:50%;" /></p><p>TSS段的结构如图所示：</p><p>TSS段的0偏移处是用来跟踪嵌套任务的指针，用来指向上一个任务的地址。</p><p>SS0、SS1和SS2分别是0、1、2特权级别的栈段选择子，ESP0、ESP1、ESP2是对应的栈顶指针。</p><p>CR3寄存器和分页有关。</p><p>剩下的32～92是用来存储CPU寄存器的部分，用来在进行任务切换时保存现场。TSS对应的任务第一次执行时，CPU从这里加载初始化执行环境，并从CS:IP处开始执行任务的第一条指令。此后该区域的内容就由CPU负责更新。</p><p>LDT段选择子用来记录任务对应私有内存段。</p><p>偏移量100处有个T标志位，在多任务切换时，如果发现TSS的T位是1，会引发一次调试异常中断。</p><p>IO映射基地址用来存储一块IO端口权限表的起始地址。有些IO指令（如IN/OUT）由于性能原因需要开放给低权限的程序，但是为了不让低权限的程序不随意读写硬件，在EFLAG寄存器的IOPL位上设置了IO权限级别，当任务的CPL高于或等于IOPL位的权限时（数值上CPL ⩽ IOPL），所有的IO请求都没问题。但如果前面的条件不成立时，并不意味着所有的IO请求都不能通过，事实上处理器的意思时总体上不允许，但是个别端口除外，这个别端口是哪些就需要到IO映射区去查找。</p><p>IO端口权限表是一个比特序列，最多有65536位（8KB），从第1比特开始每一个表示一个端口的权限，第1位表示0号端口，第2位表示1号端口，以此类推。当端口位为1时表示禁止访问，0为允许访问。不过实际中基本不会为每个端口都设置权限，也就是说这个比特序列可以小于65536位，对于未指定权限的端口，默认是禁止访问。</p><p>IO端口权限表的起始地址是从TSS的起始处算起，因此，如果该地址大于等于TSS的段界限（段界限在TSS描述符中），则表示没有IO权限表，此时计算任务的IO权限就仅仅依据EFLAG寄存器的IOPL位来进行。</p><p>IO端口权限表最后还要以固定的一个全部为1的字节结尾。这是因为IO端口被设计成每次操作斤用来读写一个字节的数据，当用字或者双字来访问时，实际上是连续访问2个和4个端口。因此当CPU执行一个字或双字指令时，会检查权限表的2个或4个连续位，而且需要它们都是0。不过这些位可能是跨字节的，有时候刚好检查的位处于最后一个字节里，如果是两个字节的IO操作，就会越界，所以规定权限表最后一定要以一个额外的全是1的字节结尾。</p><h3 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h3><ol><li><p>中断。中断向量指向的是一个任务门，而导致任务切换，需要用到TSS选择子</p></li><li><p>call等跳转指令，参数也是TSS段选择子</p></li></ol>]]></content>
    
    <summary type="html">
    
      操作系统启动模块之 任务和特权级别
    
    </summary>
    
      <category term="CS基础" scheme="http://petpwiuta.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>进入32位保护模式（一）：加载GDTR</title>
    <link href="http://petpwiuta.github.io/2020/05/09/%E8%BF%9B%E5%85%A532%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8A%A0%E8%BD%BDGDTR/"/>
    <id>http://petpwiuta.github.io/2020/05/09/进入32位保护模式（一）：加载GDTR/</id>
    <published>2020-05-09T06:12:22.436Z</published>
    <updated>2020-05-09T06:12:22.436Z</updated>
    
    <content type="html"><![CDATA[<p>实时模式下运行中的程序能访问所有内存，随着计算机上运行的程序越来越多，这个设计的风险也越来越大。保护模式在这个背景下应运而生。保护模式的主要思路就是把内存划分成若干个段，操作系统给这些段表明权限以及相关属性，在访问时就会根据权限和属性给予放行或拦截。</p><h3 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h3><p>上面说了保护模式的思路就是把内存分段，这个分段的列表就是GDT（global descriptor table）全局描述符表。这个表中每个表项长度为8个字节，所以，表长度=表项数*8，这个表的起始地址存放在cpu的一个专用寄存器上，称之为GDTR（global descriptor table register）全局描述符表寄存器。</p><p>GDTR有48位，其中32位用来存放在内存中的起始地址，16位用来存放表的长度（其实严谨的来说是长度偏移量，因为在数值上总是等于表的大小减一，和c语言中的数组下标类似）。</p><p><img src="/images/进入32位保护模式（一）：加载GDTR/32Mode_1_1.png" alt="32Mode_1_1" style="zoom:50%;" /></p><p>上面已经提到了，表项的大小是固定的8个字节，所以要想访问任何一项，只需要用GDTR中保存的基地址+表项*8就得到该项的地址，和通过下标对数组进行随机访问一样。</p><p>下面就来介绍GDT表项结构。</p><p>GDT表项的主要由3部分组成：内存区域的起始地址、内存区域的大小、内存区域的属性。</p><p><img src="/images/进入32位保护模式（一）：加载GDTR/32Mode_1_2.png" alt="32Mode_1_2" style="zoom:50%;" /></p><p>由图可见GDT表项中的段基地址，段界限，还有属性等位置并不是连续分布的，这主要是考虑和前代CPU兼容性而妥协的设计。下面简单介绍以下各个部分的结构：</p><ul><li>段基地址：就是该描述符所定义的段的起始地址，总共由32位组成</li><li>段长度（界限）：段的长度，数值等于长度的大小减一，总共由20位组成</li><li>G（Granularity）：粒度位，用于解释段长度的单位。当为0时，长度单位就是字节，当为1时，长度单位就是4KB，这时，一个段的最大长度能达到4GB</li><li>D / B：用来做16位保护模式兼容的位，现在使用的非常少了。如果不做16位兼容，设置成1就行</li><li>L：64位代码段标志</li><li>AVL（Available）：通常给操作系统使用，处理器很少使用</li><li>P（Presence）：用来保存段是否存在于内存中的标志，有时候没有内存时，操作系统会把部分不常用的段换入磁盘中，此位就会置为0。反过来如果从磁盘换入内存，此位就会置为1。</li><li>DPL（Descriptor Privilege Level）：用来表示段的特权级别，从大到小分别是，0，1，2，3</li><li>S：用来表示段的类型，0为系统段，1为代码/数据段</li><li>TYPE：用来表述段的子权限，有点类似于Linux用RWX位来表文件的读写执行权限。对于数据段4位分别是XEWA，表示执行/扩展/写/访问权限，对于代码段4位分别是XCRA，表示执行/特权依从/可读/访问权限</li></ul><h3 id="GDT的加载"><a href="#GDT的加载" class="headerlink" title="GDT的加载"></a>GDT的加载</h3><p>根据上述的规格设置好GDT的数据后，就需要把GDT表的地址和长度加载到系统的GDTR寄存器中，这个步骤有一个专用的指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt m48  ;该指令的操作数是一个48位的内存区域</span><br></pre></td></tr></table></figure><p>指令的参数的48位对应的是GDT表的位置和长度，前（低）16位是长度，后面（高）32位是GDT的地址。</p><p>设置好GDT以后，需要进入保护模式才会生效，x86 cpu是通过设置CR0寄存器的PE位为1来进入保护模式。PE（Protection Enable）位在CR0的第1位（位0）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax,cr0   ;读取cr0</span><br><span class="line">or eax,1      ;把第0位置为1</span><br><span class="line">mov cr0,eax   ;设置cr0</span><br><span class="line"></span><br><span class="line">jmp dword 0x0008:flush  ;进入32位模式后，要用jmp指令清空流水线(流水线里残留着16位的指令，会有问题)</span><br></pre></td></tr></table></figure><h3 id="保护模式下的段访问"><a href="#保护模式下的段访问" class="headerlink" title="保护模式下的段访问"></a>保护模式下的段访问</h3><h4 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h4><p>保护模式下访问内存地址还是需要通过段寄存器来进行，不过此时段寄存器的内容由以前的段地址变成了段选择子。所谓的段选择子最主要的就是要访问的段在GDT表中的序号。</p><p><img src="/images/进入32位保护模式（一）：加载GDTR/32Model_1_3.png" alt="32Model_1_3" style="zoom:50%;" /></p><p>段选择子的最主要的信息就是描述符索引，也就是段在段表内的序号。还有就是TI（table indicator）位，用来表示段在哪个表中，TI=0时，表示在GDT表中，TI=1时，表示在LDT（Local Descriptor Table）中。以及RPL（Require Privilege Level）位，请求特权级别，用来表示给出当前选择子的程序的特权级别。</p><h4 id="选择子检查"><a href="#选择子检查" class="headerlink" title="选择子检查"></a>选择子检查</h4><p>进入保护模式以后，用段选择子设置段寄存器时，段寄存器会缓存这个选择子，下次再用同样的选择子访问时，就会直接用缓存的数据。而且在访问的过程中也同时对选择子的权限，以及访问范围进行检查，如果权限不够或者超出范围就会产生异常。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="第21条地址线A20"><a href="#第21条地址线A20" class="headerlink" title="第21条地址线A20"></a>第21条地址线A20</h4><p>8086时代都是20条地址线，最大地址为0xFFFFF，再加一就会变成0x100000。但因为只有20位，所以最高位被丢弃，此时又会回到最低位地址0x00000。当年很多特性都依赖于这个特性，后来在80286后地址线扩展到24位，这个特性就不管用了。为了兼容以前的旧代码，IBM在键盘控制器的x60端口放置了一个控制门，后来因为太繁琐在80486以后直接添加了A20M#引脚。</p><p>A20m#引脚通过0x92端口控制，它的第7～2位没有使用，第0位是INIT_NOW，它从0变成1时，会重启CPU。而第1位就是用来控制A20的开关，当它为1时会启动第21条地址线。在INIT_NOW被从0设置成1时，会自动把A20位设置成1，所以现在一般不用手动来设置。这个历史遗留问题还是挺有趣的，理解x86的各种历史包袱的过程也不啻于看一部计算机发展史啊。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><p><a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table" target="_blank" rel="noopener">GDT wiki</a></p></li><li><p>《x86汇编语言-从实时模式到保护模式》，page 189</p></li></ul>]]></content>
    
    <summary type="html">
    
      操作系统启动模块之 GDTR
    
    </summary>
    
      <category term="CS基础" scheme="http://petpwiuta.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编语言笔记</title>
    <link href="http://petpwiuta.github.io/2020/05/09/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    <id>http://petpwiuta.github.io/2020/05/09/汇编语言笔记/</id>
    <published>2020-05-09T06:10:24.574Z</published>
    <updated>2020-05-09T06:10:24.574Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第-1-章-基础知识"><a href="#第-1-章-基础知识" class="headerlink" title="第 1 章 基础知识"></a>第 1 章 基础知识</h4><p>汇编语言发展至今，有3类指令组成：</p><ul><li>汇编指令：机器码的助记符，有对应的机器码</li><li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li><li>其他符号：如<code>+</code> <code>-</code> <code>*</code> <code>/</code>等，由编译器识别，没有对应的机器码</li></ul><p>汇编语言的核心是汇编指令，它决定了汇编语言的特性。</p><p><strong><span style="color:red">记住！所谓的汇编地址，其实就是相对偏移量，要么是相对段的偏移量，要么是相对程序开始的偏移量。</span></strong>只有程序加载到内存中，段地址确定以后，汇编地址才会随之确定下来，这时候就变成了物理地址。</p><h4 id="第-2-章-寄存器"><a href="#第-2-章-寄存器" class="headerlink" title="第 2 章 寄存器"></a>第 2 章 寄存器</h4><h5 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h5><p>通用寄存器 <code>AX</code>, <code>BX</code>, <code>CX</code>, <code>DX</code>。同时为了和上一代保持兼容，这4个寄存器每个又可以分成2个8位寄存器。如<code>AX</code>可以分成<code>AH</code>,<code>AL</code></p><h5 id="2-3-几条汇编指令"><a href="#2-3-几条汇编指令" class="headerlink" title="2.3 几条汇编指令"></a>2.3 几条汇编指令</h5><p><code>mov</code> ax,62627</p><p><code>add</code> ax, ax</p><p><code>sub ax,1</code></p><p><code>mul</code></p><p><code>div 除数</code>       </p><ul><li>16位除以8位，被除数放在AX中，除数可以由8位寄存器或者内存单元提供，结果的商放在AL中，余数放在AH中</li><li>32位除以16位，被除数的高16位放在DX中，低16位放在AX中，结果的商放在AX中，余数放在DX中</li></ul><h5 id="2-5-16位结构的CPU"><a href="#2-5-16位结构的CPU" class="headerlink" title="2.5 16位结构的CPU"></a>2.5 16位结构的CPU</h5><p>16、32位或者64位等x位的CPU具有以下几方面特性：</p><ul><li>运算器一次最多可以处理x位的数据</li><li>寄存器的最大宽度位x位</li><li>寄存器和运算器之间的数据通路位x位</li></ul><h5 id="2-6-8086CPU-给出物理地址的方法"><a href="#2-6-8086CPU-给出物理地址的方法" class="headerlink" title="2.6 8086CPU 给出物理地址的方法"></a>2.6 8086CPU 给出物理地址的方法</h5><p>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理，传输，暂存的地址位16位。如果将地址从内部简单地发出，那么它只能送出16位地址，表现出寻址能力只有64KB。8086CPU采取在内部用两个16位地址合成的方法来形成一个20位的物理地址。</p><h5 id="2-7-“段地址x16-偏移地址-物理地址”的本质含义"><a href="#2-7-“段地址x16-偏移地址-物理地址”的本质含义" class="headerlink" title="2.7 “段地址x16+偏移地址=物理地址”的本质含义"></a>2.7 “段地址x16+偏移地址=物理地址”的本质含义</h5><p>CPU访问内存时，用一个基础地址（段地址x16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</p><h5 id="2-9-段寄存器"><a href="#2-9-段寄存器" class="headerlink" title="2.9 段寄存器"></a>2.9 段寄存器</h5><p>8086CPU有4个段寄存器：</p><p><code>CS</code>  Code Segment，用来和IP配合，实现执行流跳转</p><p><code>DS</code> Data Segment，用来进行数据操作</p><p><code>SS</code> Stack Segment，用来进行栈操作</p><p><code>ES</code></p><p>段寄存器不支持直接赋值（硬件电路设计如此），如<code>mov CS,100h</code>之类的指令是不行的，只能从其他寄存器赋值过来，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,100h</span><br><span class="line">mov cs,ax</span><br></pre></td></tr></table></figure><h5 id="2-10-CS-和-IP"><a href="#2-10-CS-和-IP" class="headerlink" title="2.10 CS 和 IP"></a>2.10 CS 和 IP</h5><p>CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器，从名称上我们可以看出它们和指令的关系。在8086PC机中，任意时刻，设CS中的内容为M，IP中的内容为N，8086CPU将从内存的Mx16+N单元开始，读取一条指令并执行。</p><p>在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置成CS=FFFF，IP=0000，即在8086PC机刚启动时，CPU从内存FFFF0单元中读取指令执行，FFFF0单元中的指令时8086PC机开机后执行的第一条指令。</p><h5 id="2-11-修改CS-和-IP-的指令"><a href="#2-11-修改CS-和-IP-的指令" class="headerlink" title="2.11 修改CS 和 IP 的指令"></a>2.11 修改CS 和 IP 的指令</h5><p>要修改寄存器的内容，可以用mov指令，但是CS/IP的值不能用mov直接设置。8086CPU为CS/IP提供了另外的指令来改变它们的值。能够改变CS/IP的内容的指令被统称为转移指令。</p><p><code>JMP 段地址:偏移地址</code>指令可以用来修改CS/IP。如<code>jmp 2AE3:3</code>执行后，CS=2AE3，IP=0003，CPU将从2AE33处读取指令</p><p><code>JMP 合法寄存器</code> 指令可以用来单独IP的内容。如<code>jmp AX</code> 执行前AX=1000，CS=2000，IP=003。执行后AX=1000，CS=2000，IP=1000</p><h4 id="第-3-章-寄存器内存访问"><a href="#第-3-章-寄存器内存访问" class="headerlink" title="第 3 章 寄存器内存访问"></a>第 3 章 寄存器内存访问</h4><h5 id="3-2-DS-和-address"><a href="#3-2-DS-和-address" class="headerlink" title="3.2 DS 和 [address]"></a>3.2 DS 和 [address]</h5><p>8086CPU中，内存地址由段地址和偏移地址组成。段地址通常用DS寄存器保存，比如要读取10000单元的内容，可以用如下程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000h</span><br><span class="line">mov ds,bx</span><br><span class="line">mov al,[0]   ;把10000(1000:0)中的数据读到al中，对于内存寻址的语法是用&#96;[...]&#96;表示</span><br></pre></td></tr></table></figure><h5 id="3-7-CPU的栈机制"><a href="#3-7-CPU的栈机制" class="headerlink" title="3.7 CPU的栈机制"></a>3.7 CPU的栈机制</h5><p>现在的CPU都有栈机制，8086也不例外。</p><p><code>PUSH</code> ax 表示把ax的内容放到栈中</p><p><code>POP</code> ax 表示把栈顶元素放到ax中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push ax的执行，由以下两步完成：</span><br><span class="line">1 sp &#x3D; sp - 2，ss:sp指向当前栈前面的单元，以当前栈顶前面的单元为新的栈顶</span><br><span class="line">2 将ax中的内容送入ss:sp指向的内存单元处，ss:sp此时指向新栈顶</span><br><span class="line"></span><br><span class="line">pop ax的执行和上面的相反：</span><br><span class="line">1 将ss:sp指向的内存单元处的数据送入ax</span><br><span class="line">2 sp &#x3D; sp + 2，ss:sp指向当前栈顶下面的单元，以当前栈顶下面的单元为心的栈顶</span><br></pre></td></tr></table></figure><p>CPU的<code>SS</code>寄存器保存着栈顶地址，<code>SP</code>保存着偏移地址。入栈时，栈顶从高地址向低地址方向增长。</p><p>8086CPU并不会保证栈越界，这个需要编译器或者业务逻辑来实现。</p><h4 id="第-4-章-第一个程序"><a href="#第-4-章-第一个程序" class="headerlink" title="第 4 章 第一个程序"></a>第 4 章 第一个程序</h4><h5 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">st:mov ax,0123h</span><br><span class="line">mov bx,0456h</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end st</span><br><span class="line"></span><br><span class="line">;   end命令除了通知编译器程序结束外，还可以通知编译器程序入口在什么地方。</span><br><span class="line">;   如上述的 end st，st就是一个入口说明符</span><br></pre></td></tr></table></figure><ol><li><p>伪指令</p><ul><li><code>segment</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx segment</span><br><span class="line">;code ...</span><br><span class="line">xxx ends</span><br></pre></td></tr></table></figure><p><code>segment</code>和<code>ends</code>是一对伪指令关键字，用来定义一个段。</p><p>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据、或者当作栈空间来使用。一个有意义的汇编程序至少要有一个段，用来存放代码。</p><ul><li><p><code>end</code> 汇编语言的结束标记。在编译过程中，如果遇到end指令，就结束编译</p></li><li><p><code>assume</code> 用来将特定用途的段和相关寄存器关联起来</p></li></ul></li><li><p>程序结构</p><p>汇编程序的几个基本要素和简单框架如下：</p><ol><li><p>首先是要定义一个段，如abc。并在段中写入指令和数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">; code ...</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure></li><li><p>用end关键词来指定结束位置</p></li><li><p>将段和指定的段寄存器绑定起来</p></li></ol></li></ol><h4 id="第-5-章-BX-和loop指令"><a href="#第-5-章-BX-和loop指令" class="headerlink" title="第 5 章 [BX]和loop指令"></a>第 5 章 [BX]和loop指令</h4><h5 id="5-2-loop指令"><a href="#5-2-loop指令" class="headerlink" title="5.2 loop指令"></a>5.2 loop指令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx, loop_count</span><br><span class="line">tag_name: </span><br><span class="line">; code ...</span><br><span class="line">loop tag_name</span><br></pre></td></tr></table></figure><p>loop指令的格式是：loop 标号，CPU执行loop指令的时候，要进行两部操作：1. cx = cx - 1 ; 2. 判断cx中的值，不为0则转至标号处执行程序，如果为0则向下执行。</p><p>cx的值影响loop指令的执行状态，通常（一般是这样，也有例外）我们用loop实现循环时，cx就是用来存放循环次数的地方。</p><h5 id="5-6-段前缀"><a href="#5-6-段前缀" class="headerlink" title="5.6 段前缀"></a>5.6 段前缀</h5><p>在进行内存访问时，如指令<code>mov ax,[bx]</code>内存单元的偏移地址由bx给出，而段地址默认在ds中。我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。如：<code>mov ax,ds:[bx]</code> 。这样显式地指明内存单元段地址的叫做段前缀。</p><h4 id="第-6-章-包含多个段的程序"><a href="#第-6-章-包含多个段的程序" class="headerlink" title="第 6 章 包含多个段的程序"></a>第 6 章 包含多个段的程序</h4><h5 id="6-3-将数据、代码、栈放入不同的段"><a href="#6-3-将数据、代码、栈放入不同的段" class="headerlink" title="6.3 将数据、代码、栈放入不同的段"></a>6.3 将数据、代码、栈放入不同的段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line"></span><br><span class="line">data segment vstart &#x3D; 0</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20h   ;设置栈顶ss:sp指向stack:20</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax    ;ds指向data段</span><br><span class="line"></span><br><span class="line">mov bx,0     ;ds:bx 指向data段中地第一个单元</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line"></span><br><span class="line">s:push [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s       ;以上将data段中的0～15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0       ;以上依次出栈8个字型数据到data段地0～15单元中</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意：</p><p>所有的segment的地址都是从程序开始（也就是从0开始）处计算的，在nasm编译器里面可以用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">section.段名称.start  ;来表示段的地址</span><br></pre></td></tr></table></figure><p>不过segment内的地址会有点不一样。如果segment声明处有vstart=xx，则段内地址是从xx开始计算，如vstart=0x7c00，则第一条指令地址就是0x7c00，如果vstart=0，则第一条指令地址就是0。如果没有则是从整个程序头部开始计算。</p><h4 id="第-7-章-更灵活的定位内存地址的方法"><a href="#第-7-章-更灵活的定位内存地址的方法" class="headerlink" title="第 7 章 更灵活的定位内存地址的方法"></a>第 7 章 更灵活的定位内存地址的方法</h4><p>常用的寄存器除了前面提到的以外，还有<code>si</code>和<code>di</code>，这两个寄存器不能被分成两个独立8位寄存器的。从名字上来看应该是source index和destination index，主要用来做数据转移时记录index偏移</p><h5 id="7-10-不同的寻址方式的灵活应用"><a href="#7-10-不同的寻址方式的灵活应用" class="headerlink" title="7.10 不同的寻址方式的灵活应用"></a>7.10 不同的寻址方式的灵活应用</h5><ul><li>[常量] 用一个常量来表示地址，可用于直接定位一个内存单元</li><li>[bx] 用一个变量表示内存地址，可用于间接定位一个内存单元</li><li>[bx+常量] 用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元</li><li>[bx+si] 用两个变量表示地址</li><li>[bx+si+常量] 用两个变量和一个常量表示地址</li></ul><h4 id="第-8-章-数据处理的两个基本问题"><a href="#第-8-章-数据处理的两个基本问题" class="headerlink" title="第 8 章 数据处理的两个基本问题"></a>第 8 章 数据处理的两个基本问题</h4><h5 id="8-5-指令要处理的数据有多长"><a href="#8-5-指令要处理的数据有多长" class="headerlink" title="8.5 指令要处理的数据有多长"></a>8.5 指令要处理的数据有多长</h5><p>8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明时子操作还是字节操作。</p><ol><li><p>通过寄存器名字指明要处理的数据尺寸。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;下面的指令中，寄存器指明了指令进行的是字操作</span><br><span class="line">mov ax,1</span><br><span class="line">mov bx,ds:[0]</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">inc ax</span><br><span class="line">add ax,1000</span><br><span class="line">;下面的指令中，寄存器指明了指令进行的是字节操作</span><br><span class="line">mov al,1</span><br><span class="line">mov al,bl</span><br><span class="line">mov al,ds:[0]</span><br><span class="line">mov ds:[0],al</span><br><span class="line">inc al</span><br><span class="line">add dl,100</span><br></pre></td></tr></table></figure><p>来源和目的地的寄存器长度需要一样，不然会报错。如果有数据源是内存地址或者常量，会根据寄存器的宽度来扩展。如果常量的长度超过寄存器宽度，也会报错。</p></li><li><p>在没有寄存器名字的情况下，可以用操作符x ptr指明内存单元的长度，x可以是word或byte。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1  ;字操作</span><br><span class="line">mov byte ptr ds:[0],1  ;字节操作</span><br></pre></td></tr></table></figure></li><li><p>如push/pop等操作默认就是按字来进行的。</p></li></ol><h4 id="第-9-章-转移指令的原理"><a href="#第-9-章-转移指令的原理" class="headerlink" title="第 9 章 转移指令的原理"></a>第 9 章 转移指令的原理</h4><p>可以修改IP，或者同时修改CS和IP的指令统称为转移指令。换句话说转移指令就是可以控制CPU执行内存某处代码的指令。</p><h5 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h5><p>offset操作符在汇编语言中时由编译器处理的符号，它的功能是取得标号地偏移地址。如下面的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,offset start      ;想当于mov ax,0</span><br><span class="line">s:mov ax,offset s          ;相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h5 id="9-2-依据位移进行转移的jmp指令"><a href="#9-2-依据位移进行转移的jmp指令" class="headerlink" title="9.2 依据位移进行转移的jmp指令"></a>9.2 依据位移进行转移的jmp指令</h5><p><code>jmp short 标号</code> 转移到标号处执行指令。这种格式的jmp是段内短转移。j不会带上目的地址，仅仅指示记录了相对于当前IP的偏移量。</p><p><code>jmp far ptr 标号</code> 实现的是段间转移，又称为远转移。会带上CS:IP的地址</p><h5 id="9-7-jcxz指令"><a href="#9-7-jcxz指令" class="headerlink" title="9.7 jcxz指令"></a>9.7 jcxz指令</h5><p><code>jcxz 标号(如果cx寄存器的值位0，就转移到标号所在处执行)</code> 指令是有条件转移指令，所有的有条件转移指令都是短转移，机器码中包含的是ip的位移而不是目的地址。</p><h4 id="第-10-章-CALL-和-RET-指令"><a href="#第-10-章-CALL-和-RET-指令" class="headerlink" title="第 10 章 CALL 和 RET 指令"></a>第 10 章 CALL 和 RET 指令</h4><p>call 和 ret指令都是转移指令，它们都修改IP或者同时修改CS和IP。它们经常被一起用来实现子程序的设计。</p><h5 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h5><p>ret指令执行时，cpu进行2步操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. ip &#x3D; ss * 16 + sp</span><br><span class="line">2. sp &#x3D; sp + 2</span><br></pre></td></tr></table></figure><p>retf指令执行时，cpu进行4步操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. ip &#x3D; ss * 16 + sp</span><br><span class="line">2. sp &#x3D; sp + 2</span><br><span class="line">3. cs &#x3D; ss * 16 + sp</span><br><span class="line">4. sp &#x3D; sp + 2</span><br></pre></td></tr></table></figure><p>可以看出，ret相当于汇编指令的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br></pre></td></tr></table></figure><p>retf相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br></pre></td></tr></table></figure><h5 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h5><p><code>call 标号</code> 进行两部操作：</p><ol><li>将当前IP或CS和IP压入栈中</li><li>转移</li></ol><p>call指令不能实现短转移，除此之外，call和jmp基本上差不多。</p><h5 id="10-4-转移地目的地地址在指令中的call指令"><a href="#10-4-转移地目的地地址在指令中的call指令" class="headerlink" title="10.4 转移地目的地地址在指令中的call指令"></a>10.4 转移地目的地地址在指令中的call指令</h5><p><code>call far ptr 标号</code> 实现段间转移</p><h4 id="第-11-章-标志寄存器"><a href="#第-11-章-标志寄存器" class="headerlink" title="第 11 章 标志寄存器"></a>第 11 章 标志寄存器</h4><p>8086CUP中的flag寄存器用来当作标志寄存器，大部分算数或者逻辑运算指令(<code>add</code>/<code>sub</code>/<code>mul</code>/<code>div</code>/<code>inc</code>/<code>dec</code>/<code>or</code>/<code>and</code>)会对标志寄存器有影响。而<code>push</code>/<code>pop</code>等传送指令则没有影响。而且有些指令的执行会影响多个标志位，比如指令<code>sub al,al</code>执行后，ZF、PF、SF等都会受影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00</span><br><span class="line">                OF  DF  IF  TF  SF  ZF      AF      PF      CF</span><br></pre></td></tr></table></figure><h5 id="11-1-ZF位"><a href="#11-1-ZF位" class="headerlink" title="11.1 ZF位"></a>11.1 ZF位</h5><p>flag的第6位是ZF(Zero Flag)零标志位，记录相关指令执行以后，其结果是否位0，如果是0则位1</p><h5 id="11-2-PF位"><a href="#11-2-PF位" class="headerlink" title="11.2 PF位"></a>11.2 PF位</h5><p>flag的第2位是PF(Parity Flag)奇偶标志位，记录相关指令执行以后，其结果的所有bit中1的个数是否位偶数个。如果是偶数就是1，否则就是0</p><h5 id="11-3-SF位"><a href="#11-3-SF位" class="headerlink" title="11.3 SF位"></a>11.3 SF位</h5><p>flag的第7位是SF(Symbol Flag)符号标志位，记录相关指令执行以后，其结果是否位负。如果是负则为1，否则就是0</p><p>计算机中，有有符号数和无符号数，不过计算机都是统一用补码处理。所以同一个数据可以有两种解释，这里SF位就是表示如果数据按照有符号数运算时，结果是否位负数。</p><h5 id="11-4-CF位"><a href="#11-4-CF位" class="headerlink" title="11.4 CF位"></a>11.4 CF位</h5><p>flag的第0位是CF(Carry Flag)进位标志位。一般情况下，无符号数运算时，它记录了运算结果的最高有效位向更高位的进位值，或从更高的借位值。</p><h5 id="11-5-OF位"><a href="#11-5-OF位" class="headerlink" title="11.5 OF位"></a>11.5 OF位</h5><p>flag的第11位是OF(Over Flag)溢出标志位。有符号数运算时，它记录了运算结果是否有溢出。</p><h5 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a>11.6 adc指令</h5><p>adc是带进位加法的指令，它利用了CF位上记录的进位值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc obj1,obj2   ;obj1 &#x3D; obj1+obj2+CF</span><br></pre></td></tr></table></figure><p>主要用于对大于当前CPU字长的数据进行分步求和</p><h5 id="11-7-sbb指令"><a href="#11-7-sbb指令" class="headerlink" title="11.7 sbb指令"></a>11.7 sbb指令</h5><p>和adc类似，在计算时会减去CF位上的值</p><h5 id="11-8-cmp指令"><a href="#11-8-cmp指令" class="headerlink" title="11.8 cmp指令"></a>11.8 cmp指令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp obj1,obj2   ; 实际上是执行的 obj1-obj2，结果放在ZF里</span><br></pre></td></tr></table></figure><p>cmp指令相当于减法指令，只不过没有保存结果。如果两个数一样，则ZF为1，否则为0。如果obj1&lt;obj2则在计算过程中会产生借位，此时CF=1，否则CF=0。cmp指令的结果可能会影响多个标志位</p><h5 id="11-9-检测比较结果的条件转移指令"><a href="#11-9-检测比较结果的条件转移指令" class="headerlink" title="11.9 检测比较结果的条件转移指令"></a>11.9 检测比较结果的条件转移指令</h5><p>和高级语言的条件判断类似，这类指令会根据特定条件来执行跳转，执行不同的代码。如之前用过的jcxz，就是jump cx zero的缩写，如果cx是0的话就执行跳转。</p><p>除了jcxz外，还有很多常用的跳转指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">je     ;jump equal， zf&#x3D;1</span><br><span class="line">jne    ;jump not equal, zf&#x3D;0</span><br><span class="line">jb     ;jump below, cf&#x3D;1</span><br><span class="line">jnb    ;jump not below, cf&#x3D;0</span><br><span class="line">ja     ;jump above, cf&#x3D;0 且 zf&#x3D;0</span><br><span class="line">jna    ;jump not above, cf&#x3D;1 或 zf&#x3D;1</span><br></pre></td></tr></table></figure><h5 id="11-10-DF标志和串传送指令"><a href="#11-10-DF标志和串传送指令" class="headerlink" title="11.10 DF标志和串传送指令"></a>11.10 DF标志和串传送指令</h5><p>flag的第10位是DF(Direction Flag)方向标志位。控制si/di的增加或者减小。DF=0，si/di递增，DF=1，si/di递减。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movsb  ;相当于mov es:[di], byte ptr ds:[si]</span><br><span class="line">movsw  ;相当于mov es:[di], word ptr ds:[si]</span><br></pre></td></tr></table></figure><p>这两个命令常用来进行数据拷贝，通常搭配rep命令一起使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx, 3</span><br><span class="line">cld         ;表示clear director，用于把DF变成0</span><br><span class="line">            ;对应的有std(set director)，用于把DF变成1  </span><br><span class="line">rep movsb   ;rep 命令表示重复movsb，重复的次数放在cx寄存器中</span><br></pre></td></tr></table></figure><h5 id="11-11-pushf和popf"><a href="#11-11-pushf和popf" class="headerlink" title="11.11 pushf和popf"></a>11.11 pushf和popf</h5><p><code>pushf</code>把标志寄存器压栈，<code>popf</code>是把寄存器弹出</p><h4 id="常用指令列表"><a href="#常用指令列表" class="headerlink" title="常用指令列表"></a>常用指令列表</h4><ul><li>shr 右移</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shr al,1</span><br></pre></td></tr></table></figure><p>将一个寄存器或内存单元中的数据向右移位。将最右侧移出的一位写入CF中。最左侧用0补充。如果移动位数大于1，需要把移动位数放入cl中。这个指令不会进行符号位扩展，具有符号位扩展的指令是sar</p><ul><li>shl 左移</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shl al,1</span><br></pre></td></tr></table></figure><p>将一个寄存器或内存单元中的数据向左移位。将最左移出的一位写入CF中。最右侧用0补充。如果移动位数大于1，需要把移动位数放入cl中。</p><ul><li>repe movsw 表示在CX不为0时，且ZF＝1重复执行后面的串处理指令。</li><li>MOVSW 移动一个字，如果DF=0，所以每次搬运完 SI、DI 会增加 2，而 CX 减少一</li><li>add / adc   add是加法，adc是带进位加法，会将CF位的值一起加到目标操作数中</li><li>pusha / pushad 把所有通用寄存器压栈，d表示double word</li><li>bswap 表示byte swap，专用于大小尾变换的指令。如eax=00112233h，则变换后eax=33221100h</li><li>MOVZX 指令（进行全零扩展并传送）将源操作数复制到目的操作数，并把目的操作数 0 扩展到 16 位或 32 位。这条指令只用于无符号整数</li><li><p>MOVSX 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，并把目的操作数符号扩展到 16 位或 32 位。这条指令只用于有符号整数</p></li><li><p>跳转相关</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">JB   ;无符号小于则跳转</span><br><span class="line">JNB  ;无符号不小于则跳转</span><br><span class="line">JBE  ;无符号小于等于则跳转同JNA</span><br><span class="line">JNBE ;无符号不小于等于则跳转同JA</span><br><span class="line"></span><br><span class="line">JG   ;有符号大于则跳转</span><br><span class="line">JNG  ;有符号不大于则跳转</span><br><span class="line">JGE  ;有符号大于等于则跳转同JNL</span><br><span class="line">JNGE ;有符号不大于等于则跳转同JL</span><br><span class="line"></span><br><span class="line">JL   ;有符号小于则跳转</span><br><span class="line">JNL  ;有符号不小于则跳转</span><br><span class="line">JLE  ;有符号小于等于则跳转同JNG</span><br><span class="line">JNLE ;有符号不小于等于则跳转同JG</span><br><span class="line"></span><br><span class="line">JZ   ;为零则跳转</span><br><span class="line">JNZ  ;不为零则跳转</span><br><span class="line"></span><br><span class="line">JS   ;为负则跳转</span><br><span class="line">JNS  ;不为负则跳转</span><br><span class="line"></span><br><span class="line">JC   ;进位则跳转</span><br><span class="line">JNC  ;不进位则跳转</span><br><span class="line"></span><br><span class="line">JO   ;溢出则跳转</span><br><span class="line">JNO  ;不溢出则跳转</span><br><span class="line"></span><br><span class="line">JP;为偶则跳转</span><br><span class="line">JNP  ;不为偶则跳转</span><br><span class="line"></span><br><span class="line">JPE  ;奇偶位置位则跳转同JP</span><br><span class="line">JPO  ;奇偶位复位则跳转同JNP</span><br><span class="line"></span><br><span class="line">;https:&#x2F;&#x2F;blog.csdn.net&#x2F;zmmycsdn&#x2F;article&#x2F;details&#x2F;78511948</span><br></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li><a href="https://www.cnblogs.com/ToBeExpert/p/9768546.html" target="_blank" rel="noopener">Intel的CPU通用寄存器</a></li></ul>]]></content>
    
    <summary type="html">
    
      汇编语言笔记
    
    </summary>
    
      <category term="CS基础" scheme="http://petpwiuta.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养：库与运行库</title>
    <link href="http://petpwiuta.github.io/2020/05/09/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E5%BA%93%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%BA%93/"/>
    <id>http://petpwiuta.github.io/2020/05/09/程序员的自我修养：库与运行库/</id>
    <published>2020-05-09T05:39:02.979Z</published>
    <updated>2020-05-09T05:39:02.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="10-内存"><a href="#10-内存" class="headerlink" title="10 内存"></a>10 内存</h2><h3 id="10-1-程序和内存空间"><a href="#10-1-程序和内存空间" class="headerlink" title="10.1 程序和内存空间"></a>10.1 程序和内存空间</h3><p>现代的程序都使用的是虚拟内存空间，它的大小仅仅和CPU地址线宽度相关。虚拟内存空间和物理内存通过页目录和页表来实现映射。</p><p>在虚拟空间中内存并不是所有的地方都可以随意使用，它被划分为了内核空间和用户空间。内核空间仅供操作系统使用，用户空间才是用户程序所使用的内存区域。在用户空间中，内存被分为了几个默认的区域：</p><ul><li>栈：用户维护函数调用时上下文参数，如参数和返回地址</li><li>堆：用来提供给程序进行动态内存分配，像malloc函数分配的内存空间就在堆上</li><li>可执行文件镜像：存储编译出来的可执行文件</li><li>保留区：一部分不能被访问的空间区域的总称</li><li>动态链接映射：如果程序是动态链接的，所需要的动态链接库会被映射到虚拟内存空间中</li></ul><p><img src="/images/程序员的自我修养：库与运行库/10.1-1.png" alt="10.1-1" style="zoom:50%;" /></p><h3 id="10-2-栈和调用惯例"><a href="#10-2-栈和调用惯例" class="headerlink" title="10.2 栈和调用惯例"></a>10.2 栈和调用惯例</h3><h4 id="10-2-1-栈的结构"><a href="#10-2-1-栈的结构" class="headerlink" title="10.2.1 栈的结构"></a>10.2.1 栈的结构</h4><p>栈是一种后进先出的数据结构，它在编程语言中重要的作用之一就是跟踪函数的调用状态。函数可以层层嵌套调用，然后再一一返回，中间不会回到其他函数，也不会跳过中间的部分直接回到顶部函数，这都依赖于栈的存在。</p><p>函数栈中保存了函数调用和返回所需要的信息，主要有以下几个部分：</p><ul><li>函数的返回地址和参数</li><li>函数中声明的临时变量</li><li>保存的上下文环境</li></ul><p>在i386处理器中，使用ebp和esp这两个寄存器来跟踪一个函数调用，esp始终指向栈顶部，也就是说同时指向了当前调用的函数的最顶部，ebp始终指向当前调用的函数的最底部。</p><p><img src="/images/程序员的自我修养：库与运行库/10.2-1.png" alt="10.2-1" style="zoom:50%;" /></p><p>函数调用后会在函数栈中建立起对应的栈帧，一个完整的函数调用帧是由调用者和被调用者双方建立起来的，具体步骤如下：</p><ol><li><p>调用者把所有或者部分参数压入栈中，如果有其他参数没有入栈，就用特定的寄存器传递参数</p></li><li><p>把当前指令的下一条指令压入栈中，作为返回地址</p></li><li><p>跳转到被调用的函数体执行具体逻辑 （2 和 3 这两个步骤是由汇编指令<code>call</code>来完成的，是一个原子操作）</p><hr></li><li><p>被调用函数执行 <code>push ebp</code>把ebp压入栈中</p></li><li><p>被调用函数再执行<code>mov ebp,esp</code>把esp保存到ebp中</p></li></ol><p>翻译成对应的汇编代码应该类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int func(int arg) &#123;</span><br><span class="line">    push   ebp            ;这两行代码是每个函数体中都有的标准代码</span><br><span class="line">    mov    ebp,esp        ;用来维护栈帧结构，所有的函数默认应该都有前面着两行代码</span><br><span class="line"></span><br><span class="line">    sub    esp,局部变量所占空间  ;可选，用来保存函数的局部变量</span><br><span class="line">    push   xxx                ;可选，保存指定的寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">               ;调用其他函数的一般方法             ;;</span><br><span class="line">                                               ;;</span><br><span class="line">    ;如果函数中要调用其他函数，一般是                ;;</span><br><span class="line">    mov 寄存器,参数  ;如果是用寄存器传递参数         ;;</span><br><span class="line">    push           ;如果参数较多就用栈传递参数      ;;</span><br><span class="line">    call 函数名     ;call指令会保存下一条指令再跳转  ;;</span><br><span class="line">    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">    mov eax,0   ;通过寄存器返回函数结果 即 return 0;   </span><br><span class="line">                ;太大的对象需要通过更复杂的方式来返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-2-调用惯例"><a href="#10-2-2-调用惯例" class="headerlink" title="10.2.2 调用惯例"></a>10.2.2 调用惯例</h4><p>一个完整的栈帧需要调用者和被调用者共同构建，所以两者之间的协议就很重要了。调用者和被调用者之间的协议叫调用惯例，一般会规定下面几个方面的内容：</p><ul><li><p>函数参数的传递顺序和方式</p><p>参数较少时可以通过寄存器来传递（寄存器速度快，效率也更高）; 但是参数较多时就要用栈，用栈传递时就要约定好参数时从左到右还是从右到左入栈，然后另一方再从栈中获取参数</p></li><li><p>栈的维护方式</p><p>参数入栈以后，调用函数，函数完成以后参数已经不再需要，此时需要把参数从栈中弹出释放空间，这个步骤调用者或者被调用者都可以做，所以也需要约定好</p></li><li><p>名字修饰的算法</p><p>从函数名到对应的符号名，这个算法由很多固定的约定，比如c语言的cdecl，就规定了把函数名前面添加一个下划线作为符号名。如foo函数，对应的符号名就是_foo</p></li></ul><p>下面是几个典型的调用惯例：</p><div class="table-container"><table><thead><tr><th style="text-align:left">调用惯例</th><th style="text-align:center">参数出栈方</th><th style="text-align:center">参数传递</th><th style="text-align:center">名字修饰</th></tr></thead><tbody><tr><td style="text-align:left">cdecl</td><td style="text-align:center">函数调用方</td><td style="text-align:center">从右到左压栈</td><td style="text-align:center">下划线+函数名</td></tr><tr><td style="text-align:left">stdcall</td><td style="text-align:center">函数本身</td><td style="text-align:center">从右到左压栈</td><td style="text-align:center">下划线+函数名+@+参数字节数</td></tr><tr><td style="text-align:left">fastcall</td><td style="text-align:center">函数本身</td><td style="text-align:center">头两个dword(4字节)用寄存器，其他用栈</td><td style="text-align:center">@+函数名+@+参数字节数</td></tr></tbody></table></div><h4 id="10-2-3-函数返回值传递"><a href="#10-2-3-函数返回值传递" class="headerlink" title="10.2.3 函数返回值传递"></a>10.2.3 函数返回值传递</h4><p>对于返回5～8字节的对象来说，几乎所有的调用惯例都是采用eax和edx联合返回的方式，在64位平台上可能会用更多的寄存器。但是如果返回对象过于庞大，则会用下面的方法来传递参数（用C语言作为例子，其他语言可能细节不一样）：</p><ul><li>调用方在栈上开辟了一片空间，把这片空间作为返回对象的临时存放区域，这里称为temp</li><li>把temp的地址作为隐藏参数传递给被调用函数</li><li>被调用函数完成功能以后，把结果拷贝到temp空间中，并把temp空间的地址作为返回值返回（一般用eax寄存器来返回结果）</li><li>回到主调函数后，主调函数再把eax寄存器指向的内容拷贝到真正的目的地内存中</li></ul><p>可以看到temp的空间被拷贝了两次，所以在c语言中，一般不会直接返回大字节数的对象，而是事先用malloc申请一块内存，然后再把内存指针传入函数中。这样就避免了多次内存读写。</p><h3 id="10-3-堆与内存管理"><a href="#10-3-堆与内存管理" class="headerlink" title="10.3 堆与内存管理"></a>10.3 堆与内存管理</h3><h4 id="10-3-1-堆的结构"><a href="#10-3-1-堆的结构" class="headerlink" title="10.3.1 堆的结构"></a>10.3.1 堆的结构</h4><p>堆内存是应用程序中比较大的一块内存空间，也是使用起来最自由的内存空间（当然，也最容易出内存泄露的bug）。一般来讲，内存是操作系统管理的，可以用系统调用来直接申请内存，不过这样会频繁进行用户态/内核态的切换。</p><p>所以一般语言的runtime在申请堆内存时，会向操作系统“批发”一大块内存，然后再“零售”给程序。当内存用完时会再向系统“进货”。c语言的runtime对内存管理就是基于上述的机制，而且runtime本身也会严格管理内存的分配，不会把同一块内存空间分配两次。这个强大高效的算法就是堆的分配算法。</p><h4 id="10-3-2-Linux进程堆管理"><a href="#10-3-2-Linux进程堆管理" class="headerlink" title="10.3.2 Linux进程堆管理"></a>10.3.2 Linux进程堆管理</h4><p>Linux提供了两个系统调用来管理堆空间：一个是<code>brk()</code>，一个是<code>mmap()</code>。</p><p>brk调用的实际作用起始是设置进程数据段的结束地址，可以扩大或者缩小。如果向高地址空间扩展，扩展出来的空间就可以用来做堆空间。</p><p>mmap是用来向操作系统申请一段虚拟地址空间，这个空间可以映射到文件，也可以不映射。不映射到文件时，就称为匿名空间。匿名空间就可以拿来当堆空间。</p><h4 id="10-3-4-堆分配算法"><a href="#10-3-4-堆分配算法" class="headerlink" title="10.3.4 堆分配算法"></a>10.3.4 堆分配算法</h4><ul><li><p>空闲链表</p><p>把堆上的空间块按照链表的方式穿起来。使用时，遍历链表查找满足条件的块</p></li><li><p>位图</p><p>把堆空间分割成固定大小的块，然后用一个位图来记录分配情况</p></li><li><p>对像池</p><p>如果分配对象的大小是固定的几个值，可以用对像池的办法来管理</p></li><li><p>多种算法结合</p><p>实际环境中，分配算法一般是根据多种算法复合而成。对于glibc来说，小于64字节的是采用类似于对像池的方法; 而对于大于512字节的空间申请采用的是最佳适配算法; 对于64字节和512字节之间的，会采取上述方法中的最佳折中策略; 对于大于128KB的申请，它会使用mmap机制直接向操作系统申请空间</p></li></ul><h2 id="11-运行库"><a href="#11-运行库" class="headerlink" title="11 运行库"></a>11 运行库</h2><h3 id="11-1-入口函数和程序初始化"><a href="#11-1-入口函数和程序初始化" class="headerlink" title="11.1 入口函数和程序初始化"></a>11.1 入口函数和程序初始化</h3><h4 id="11-1-1-程序从main开始吗"><a href="#11-1-1-程序从main开始吗" class="headerlink" title="11.1.1 程序从main开始吗"></a>11.1.1 程序从main开始吗</h4><p>操作系统装载C语言编写的程序以后，最先运行的并不是main函数，而是要进行一系列准备工作后才会调用main函数。</p><p>执行这些准备工作的函数称为入口函数，它一般是运行库的一部分，一个典型的准备工作大致有下面几个方面：</p><ul><li>操作系统创建进程，把控制权交给程序的入口，这个入口一般是程序语言对应的运行库中的入口函数</li><li>入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量构造等等</li><li>入口函数初始化完成后，调用main函数，正式开始执行程序主体部分</li><li>main函数执行完毕之后，返回到入口函数。入口函数进行收尾的清理工作，包括全局变量析构、堆销毁、关闭I/O等等。然后调用执行系统调用结束进程</li></ul><h4 id="11-1-2-入口函数如何实现"><a href="#11-1-2-入口函数如何实现" class="headerlink" title="11.1.2 入口函数如何实现"></a>11.1.2 入口函数如何实现</h4><h5 id="GLIBC入口函数"><a href="#GLIBC入口函数" class="headerlink" title="GLIBC入口函数"></a>GLIBC入口函数</h5><p>在Linux中glibc是C语言的运行库，它的程序入口为_start。它的大致逻辑用伪代码来表示类似于下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _start()</span><br><span class="line">&#123;</span><br><span class="line">  %ebp = <span class="number">0</span>;   <span class="comment">//ebp寄存器设置为0</span></span><br><span class="line">  <span class="keyword">int</span> argc = pop from <span class="built_in">stack</span></span><br><span class="line">  <span class="keyword">char</span>** argv = top of <span class="built_in">stack</span></span><br><span class="line">  __libc_start_main(main, argc, __libc_csu_init, __libc_csu_fini, edx, top of <span class="built_in">stack</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_start函数主要是准备各种参数，再调用<code>__libc_start_main</code>函数来完成工作，它的函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __libc_start_main (</span><br><span class="line">  <span class="keyword">int</span> (*main) (<span class="keyword">int</span>, <span class="keyword">char</span> **, <span class="keyword">char</span> **),    <span class="comment">//main函数</span></span><br><span class="line">  <span class="keyword">int</span> argc,                               <span class="comment">//参数个数</span></span><br><span class="line">  <span class="keyword">char</span> * __unbounded *__unbounded ubp_av, <span class="comment">//参数列表和环境变量</span></span><br><span class="line">  __typeof (main) init,                   <span class="comment">//在main之前执行的逻辑</span></span><br><span class="line">  <span class="keyword">void</span> (*fini) (<span class="keyword">void</span>),                    <span class="comment">//在main之后执行的逻辑</span></span><br><span class="line">  <span class="keyword">void</span> (rtld_fini) (<span class="keyword">void</span>),                <span class="comment">//runtime loader fini，动态加载相关的收尾逻辑</span></span><br><span class="line">  <span class="keyword">void</span> * __unbounded stack_end            <span class="comment">//栈的最高地址</span></span><br><span class="line">) </span><br><span class="line">  </span><br><span class="line">&#123;<span class="comment">//函数主体</span></span><br><span class="line">  <span class="comment">// .........其他逻辑.........</span></span><br><span class="line">  __environ = ubp_ev;</span><br><span class="line">  __pthread_initialize_minimal();</span><br><span class="line">  __cxa_atexit(rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  __libc_init_first(argc, argv, __environ);</span><br><span class="line">  __cxa_atexit(fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  (*init)(argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .........其他逻辑.........</span></span><br><span class="line">  </span><br><span class="line">  result = main(argc, argv, __environ);</span><br><span class="line">  <span class="built_in">exit</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见在进行系列的初始化后，最终调用了main函数。</p><h4 id="11-1-3-运行库与I-O"><a href="#11-1-3-运行库与I-O" class="headerlink" title="11.1.3 运行库与I/O"></a>11.1.3 运行库与I/O</h4><p>I/O是程序中非常重要的部分，包括文件、管道、网络、命令行、信号等都属于I/O的范围。而文件则是实际使用最多的I/O实体。</p><p>在Linux里，文件操作是通过文件描述符（File Descriptor）进行的。设置文件描述符的原因是防止用户随意读写操作系统内核的文件对象。无论是Linux还是Windows，文件描述符总是和内核的文件对象相关联的，内核可以通过文件描述符来计算出内核的文件对象的地址，但这个能力并不对普通用户开放。</p><p>在Linux中，值为0、1、2的fd分别代表标准输入、标准输出和标准错误输出。在程序中打开文件得到的fd从3开始增长。fd具体是什么呢？在内核中，每一个进程都有一个私有的“打开文件表”，这个表是一个指针数组，每一个元素都指向一个内核的打开文件对象。而fd就是这个表的下标。当用户打开一个文件时，内核会在内部生成一个打开文件对象，并在这个表里找到一个空项，让这一项指向生成的打开文件对象，并返回这一项的下标作为fd。由于这个表处于内核，并且用户无法访问到，因此用户即使拥有fd，也无法得到打开文件对象的地址，只能够通过系统提供的函数来操作。 </p><h3 id="11-2-C-C-运行库"><a href="#11-2-C-C-运行库" class="headerlink" title="11.2 C/C++运行库"></a>11.2 C/C++运行库</h3><h5 id="11-2-1-C语言运行库"><a href="#11-2-1-C语言运行库" class="headerlink" title="11.2.1 C语言运行库"></a>11.2.1 C语言运行库</h5><p>任何一个C语言程序，它背后都有一套庞大的代码来进行支撑，以使得该程序能够正常运行。这套代码至少包括入口函数，以及所依赖的函数所构成的函数集合。以及各种标准库函数的实现。这样的代码集合称为运行时库（Runtime Library）。</p><p>一个C语言运行库大致包含了如下功能：</p><ul><li>启动与退出：包括入口函数及入口函数所依赖的其他函数等</li><li>标准函数：由C语言标准规定的C语言标准库所拥有的函数实现</li><li>堆：堆的封装和实现</li><li>语言实现：语言中一些特殊功能的实现</li><li>调试：实现调试功能</li></ul><h5 id="11-2-2-C语言标准库"><a href="#11-2-2-C语言标准库" class="headerlink" title="11.2.2 C语言标准库"></a>11.2.2 C语言标准库</h5><p>C语言现在有了统一的标准，即ANSI C，它的标准库由24个C头文件组成，例举几个常见的：</p><ul><li>标准输入输出、文件操作：stdio.h </li><li>字符操作：ctype.h</li><li>字符串操作：string.h</li><li>数学函数：math.h</li><li>资源管理、格式转换：stdlib.h</li><li>时间/日期：time.h</li><li>断言：assert.h</li><li>常数定义：limits.h / float.h</li><li>变长参数：stdarg.h</li><li>非局部跳转：setjmp.h</li></ul><h6 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h6><p>变长参数是C语言的特殊参数形式。如下面的函数声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>printf函数除了第一个参数类型为const char*外，后面可以追加任意数量和类型的参数。这主要得益于C语言默认的cdecl调用约定，即由函数调用者负责参数的压栈和出栈。</p><h6 id="非局部跳转"><a href="#非局部跳转" class="headerlink" title="非局部跳转"></a>非局部跳转</h6><p>C语言中有goto语句，不过goto只能在函数内跳转，想要跳转到其他函数内部执行就不行了。不过C语言提供了setjmp.h库，来提供非局部跳转的能力。</p><h5 id="11-2-3-glibc与MSVC-CRT"><a href="#11-2-3-glibc与MSVC-CRT" class="headerlink" title="11.2.3 glibc与MSVC CRT"></a>11.2.3 glibc与MSVC CRT</h5><p>glibc的标准静态库位于<code>/usr/lib/libc.a</code> 除了标准库外，它还有几个辅助程序运行的运行库，它们是<code>/usr/lib/crt1.o</code> 、 <code>/usr/lib/crti.o</code> 、 <code>/usr/lib/crtn.o</code> 这几个文件在程序加载中有着关键的作用。</p><p><code>crt1.o</code> 里面包含的就是程序的入口函数<code>_start</code>，由它负责调用<code>__libc_start_main</code> 初始化libc并且调用main函数进入真正的程序主体。</p><p>由于C++的出现和ELF文件的改进，出现了必须在main函数之前执行的全局/静态对象构造和必须在main之后执行的全局/静态对象析构，为了满足这一要求，运行库在每个目标文件中引入两个与初始化相关的段<code>.init</code>和<code>.finit</code> ，运行库会保证所有位于这两个段中的代码会先于/后于main函数执行。</p><p>为了方便运行库调用，最终输出文件中的<code>.init</code>和 <code>.finit</code>两个段实际上分别包含的是<code>_init()</code>和 <code>_finit()</code>这两个函数。<code>crti.o</code>和 <code>crtn.o</code> 这两个目标文件中包含的代码实际上是<code>_init()</code>和 <code>_finit()</code>这两个函数的开始和结束部分，当这两个文件和其他目标文件按照顺序链接起来后，刚好形成两个完整的函数<code>_init()</code>和 <code>_finit()</code>。</p><p>在最终链接完成之后，输出的目标文件中的<code>.init</code> 段只包含了一个函数<code>_init()</code>，这个函数的开始部分来自于<code>crti.o</code> 的<code>.init</code> 段，结束部分来自于<code>crtn.o</code> 的<code>.init</code> 段。为了保证最终输出文件中<code>.init</code> 和<code>.finit</code> 的正确顺序，我们必须保证在链接时，<code>crti. o</code> 必须在用户目标文件和系统库之前，而<code>crtn.o</code> 必须在用户目标文件和系统库之后。所以链接器的输入文件顺序一般是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ld crt1.o crti.o [user_objects] [system_libraries] crtn.o</span></span><br></pre></td></tr></table></figure><p>由于<code>crt1.o</code> 不包含<code>.init</code> 段和<code>.finit</code> 段，所以不会影响最终生成<code>.init</code> 和<code>.fnit</code> 段时的顺序。输出文件中的<code>.init</code> 段看上去应该如图所示（对于<code>.finit</code> 来说也是一样）：</p><p><img src="/images/程序员的自我修养：库与运行库/11.2.3-1.png" alt="10.1-1" style="zoom:50%;" /></p><blockquote><p>在默认情况下，链接器会将<code>libc</code>、<code>crt1.o</code>等这些CRT和启动文件与程序的模块链接起来。但是有些时候我们可能不需要这些文件，或者希望使用自己的<code>libc</code>和<code>crt1.o</code>等启动文件，以替代系统默认的文件，这种情况在嵌入式系统或操作系统內核编译的时候很常见。GCC提高了两个参数<code>-nostartfile</code>和<code>-nostdlib</code>，分别用来取消默认的启动文件和C语言运行库。</p></blockquote><p>由于<code>.init</code>和 <code>.finit</code>段的特殊性（在main之前/后，执行），所以除了用来进行全局对象构造和析构外。一些监控用户程序性能或者调试工具经常用它来进行一些初始化和反初始化的工作。不过这些代码不能使用普通函数，因为函数的返回指令会使<code>_init()</code>函数提前返回，所以必须使用汇编代码，不能让编译器产生<code>ret</code>指令。</p><h2 id="12-系统调用与API"><a href="#12-系统调用与API" class="headerlink" title="12 系统调用与API"></a>12 系统调用与API</h2><h3 id="12-1-系统调用介绍"><a href="#12-1-系统调用介绍" class="headerlink" title="12.1 系统调用介绍"></a>12.1 系统调用介绍</h3><h4 id="12-1-1-什么是系统调用"><a href="#12-1-1-什么是系统调用" class="headerlink" title="12.1.1 什么是系统调用"></a>12.1.1 什么是系统调用</h4><p>操作系统的主要功能就是把硬件资源抽象化，抽象化以后的硬件资源通过特定的接口给应用程序使用，而最基础的接口就是系统调用。系统调用最主要的特点就是调用以后系统会切换到内核态执行固定的内核代码，这个过程主要是通过中断来实现的。在Linux中使用0x80号中断作为系统调用入口，而在Windows里系统调用中断号是0x2E 。</p><p>系统调用涵盖的功能很广，有程序运行所必需的支持，例如创建/退出进程和线程、进程内存管理，也有对系统资源的访问，例如文件、网络、进程间通信、硬件设备的访问，也可能有对图形界面的操作支持，例如 Windows下的GUI机制。</p><p>不过对于Windows来说，系统调用实际上不是它和程序最低层的接口，它的最底层接口是API。设计API层的目的是为了消除不同硬件和内核版本的差异，这也造就了Windows恐怖的兼容性。</p><h4 id="12-1-2-Linux系统调用"><a href="#12-1-2-Linux系统调用" class="headerlink" title="12.1.2 Linux系统调用"></a>12.1.2 Linux系统调用</h4><p>在x86系列的CPU中，系统调用由0x80中断完成，参数通过寄存器传递。EAX寄存器用于表示系统调用的接口号，比如EAX=1表示退出进程(exit); EAX=2表示创建进程(fork); EAX=3表示读取文件或IO(read); EAX=4表示写文件或lO( write)等，每个系统调用都对应于内核源代码中的一个函数。它们都是以“sys_”开头的，比如exit调用对应内核中的sys_exit函数。当系统调用返回时，EAX又作为调用结果的返回值。</p><div class="table-container"><table><thead><tr><th style="text-align:center">EAX</th><th style="text-align:center">名字</th><th style="text-align:left">C语言定义</th><th style="text-align:center">含义</th><th style="text-align:left">参数</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">exit</td><td style="text-align:left">void _exit(int status);</td><td style="text-align:center">退出进程</td><td style="text-align:left">EBX：退出码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">fork</td><td style="text-align:left">pid_ fork(void);</td><td style="text-align:center">复制进程</td><td style="text-align:left">EBX：复制参数</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">read</td><td style="text-align:left">ssize_t read(int fd, void *buf, size_t count);</td><td style="text-align:center">读文件</td><td style="text-align:left">EBX：文件handler</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">write</td><td style="text-align:left">ssize_t write(int fd, const void *buf, size_t count);</td><td style="text-align:center">写文件</td><td style="text-align:left">EBX：文件handler</td></tr></tbody></table></div><p>这些系统调用可以直接用汇编代码根据中断定义来直接调用，也可以用C语言封装的接口来调用。不过直接虽然可以直接使用系统调用，但系统调用的功能太过原始。如直接用open()、read()、close()，来处理文件的话，需要自己处理缓冲、按行读取等功能，所以不如直接用glibc提供的fopen()、fread()、fclose()等现成的功能。</p><h4 id="12-1-3-系统调用的弊端"><a href="#12-1-3-系统调用的弊端" class="headerlink" title="12.1.3 系统调用的弊端"></a>12.1.3 系统调用的弊端</h4><p>系统调用的弊端是太过于底层，使用不方便。另外一点就是和系统实现相关，移植性不好。</p><p>所以人们在系统调用之上增加了跨平台的语言运行库，如C语言的运行库。使用C语言的fread函数时，在不同的系统中可能调用底层系统调用是不一样的，但向语言层面提供统一的接口，这样就可以只写一份代码然后运行在不同的系统上。</p><h3 id="12-2-系统调用原理"><a href="#12-2-系统调用原理" class="headerlink" title="12.2 系统调用原理"></a>12.2 系统调用原理</h3><h4 id="12-2-1-特权级与中断"><a href="#12-2-1-特权级与中断" class="headerlink" title="12.2.1 特权级与中断"></a>12.2.1 特权级与中断</h4><p>在x86系列的CPU上，系统代码和应用代码具有不同的特权等级。系统代码在最高级别运行，可以操作所有的硬件。应用代码在进行硬件操作时，就会使用中断来调用系统提供的功能来间接使用硬件。</p><p>中断是类似于高级语言中的回调方法，操作系统内核在启动后会注册一系列的中断处理方法，当应用程序调用中断时，会传入对应的终端号，来指明使用哪一个中断方法。</p><h4 id="12-2-2-基于int的Linux的经典系统调用实现"><a href="#12-2-2-基于int的Linux的经典系统调用实现" class="headerlink" title="12.2.2 基于int的Linux的经典系统调用实现"></a>12.2.2 基于int的Linux的经典系统调用实现</h4><h5 id="触发中断"><a href="#触发中断" class="headerlink" title="触发中断"></a>触发中断</h5><p>汇编指令<code>int</code>会触发CPU去查找事先准备好的中断表，用约定好的寄存器参数来调用中断处理函数。</p><h5 id="切换堆栈"><a href="#切换堆栈" class="headerlink" title="切换堆栈"></a>切换堆栈</h5><p>当实际执行中断表中的函数前，CPU必须先保存现场，以便完成任务后继续执行用户程序。这里保存现场主要就是保存栈寄存器（ESP、EBP等），以及当前的执行代码用到的寄存器（CS、EIP、EFLAG 等等）。保存好现场后，就会切换到内核态，所谓的切换起始就是向这些寄存器写入新的值，这些新值指向内核代码和内核内存区域。最后再执行中断处理函数。</p><h5 id="中断处理函数"><a href="#中断处理函数" class="headerlink" title="中断处理函数"></a>中断处理函数</h5><p>中断处理函数是操作系统内核预先设定好的，如任务切换，CPU执行异常处理等，它们在执行固定的逻辑后，把用户程序的执行环境恢复。最后再执行<code>iret</code>指令把执行流返回到之前发生中断的地方。</p><h4 id="12-2-3-Linux的新型系统调用机制"><a href="#12-2-3-Linux的新型系统调用机制" class="headerlink" title="12.2.3 Linux的新型系统调用机制"></a>12.2.3 Linux的新型系统调用机制</h4><p>Linux2.5版本后开始支持新的系统调用指令，即<code>sysenter</code>和<code>sysexit</code>，这两个指令和<code>int</code> 功能类似，但是把<code>int</code>执行的绝大部分逻辑都用硬件电路来实现了，这样性能要比<code>int</code>指令更好（int是一个通用的中断机制，并不是仅仅只能做内核/用户态的切换）。</p>]]></content>
    
    <summary type="html">
    
      《程序员的自我修养》的读书笔记
    
    </summary>
    
      <category term="CS基础" scheme="http://petpwiuta.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养：装载与动态链接</title>
    <link href="http://petpwiuta.github.io/2020/05/09/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://petpwiuta.github.io/2020/05/09/程序员的自我修养：装载与动态链接/</id>
    <published>2020-05-09T05:38:40.974Z</published>
    <updated>2020-05-09T05:38:40.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-可执行文件的装载与进程"><a href="#6-可执行文件的装载与进程" class="headerlink" title="6 可执行文件的装载与进程"></a>6 可执行文件的装载与进程</h2><h3 id="6-1-进程虚拟地址空间"><a href="#6-1-进程虚拟地址空间" class="headerlink" title="6.1 进程虚拟地址空间"></a>6.1 进程虚拟地址空间</h3><p>程序被运行起来以后，它将拥有自己独立的虚拟地址空间（Virtual Address Space），这个虚拟地址空间的大小由CPU的位数决定的。硬件决定了地址空间的最大理论上限，比如32位的硬件平台决定了虚拟地址空间的大小是$ 2^{32}$也就是我们常说的4GB虚拟空间大小；而64位的硬件平台具有64位寻址能力，它的虚拟地址空间达到了$2^{64}$，即16384PB大小。</p><p>在程序实际运行的过程中，虚拟地址空间也不是全部被程序所使用。如Linux下，操作系统会占据一部分高地址空间，剩下的部分才是分配给应用程序的。</p><h3 id="6-2-装载的方式"><a href="#6-2-装载的方式" class="headerlink" title="6.2 装载的方式"></a>6.2 装载的方式</h3><p>现在的操作系统装载可执行文件都是使用分页式加载，即把虚拟内存空间分割成固定大小的页面，当实际有代码或数据使用的内存空间时，才会把虚拟的内存空间映射到物理内存中。</p><h3 id="6-3-从操作系统角度看可执行文件的装载"><a href="#6-3-从操作系统角度看可执行文件的装载" class="headerlink" title="6.3 从操作系统角度看可执行文件的装载"></a>6.3 从操作系统角度看可执行文件的装载</h3><h4 id="6-3-1-进程的建立"><a href="#6-3-1-进程的建立" class="headerlink" title="6.3.1 进程的建立"></a>6.3.1 进程的建立</h4><p>从操作系统的角度来看，一个进程最关键的特征是它拥有独立的虚拟地址空间，这使得它有别于其他进程。很多时候一个程序被执行同时都伴随着一个新的进程的创建 ，那么我们就来看看这种最通常的情形；创建一个进程，然后装载相应的可执行文件并且执行。在有虚拟存储的情况下，上述过程最开始只需要做三件事情：</p><ul><li>创建一个独立的虚拟地址空间</li><li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</li><li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</li></ul><h5 id="创建虚拟地址空间"><a href="#创建虚拟地址空间" class="headerlink" title="创建虚拟地址空间"></a>创建虚拟地址空间</h5><p>一个虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间，那么创建一个虚拟空间实际上并不是创建空间而是创建映射函数所需要的相应的数据结构，在x86的Linux下，创建虚拟地址空间实际上只是分配一个页目录（Page Directory）就可以了，甚至不设置页映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置都行。</p><h5 id="映射可执行文件到虚拟内存空间"><a href="#映射可执行文件到虚拟内存空间" class="headerlink" title="映射可执行文件到虚拟内存空间"></a>映射可执行文件到虚拟内存空间</h5><p>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。上一步的页映射关系函数是虚拟空间到物理内存的映射关系，这一步所做的是虚拟空间与可执行文件的映射关系。我们知道，当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。当操作系统捕获到缺页错误时，它应知道程序当前所需要的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系。从某种角度来看，这一步是整个装载过程中最重要的一步，也是传统意义上“装载”的过程。</p><h5 id="跳转到可执行文件入口，运行可执行文件"><a href="#跳转到可执行文件入口，运行可执行文件" class="headerlink" title="跳转到可执行文件入口，运行可执行文件"></a>跳转到可执行文件入口，运行可执行文件</h5><p>操作系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行。这一步看似简单，实际上在操作系统层面上比较复杂，它涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换。不过从进程的角度看这一步可以简单地认为操作系统执行了一条跳转指令直接跳转到可执行文件的入口地址。ELF文件头中保存有入口地址，CPU也就是从这个地址开始执行代码。</p><h4 id="6-3-2-页错误"><a href="#6-3-2-页错误" class="headerlink" title="6.3.2 页错误"></a>6.3.2 页错误</h4><p>上面的步骤执行完以后，其实可执行文件的真正指令和数据都没有被装入到内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系。当CPU开始打算执行入口地址的指令时，发现内存所属页面是个空页面，于是它就认为这是一个页错误（Page Fault）。CPU将控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况。</p><p>这时候前面提到的虚拟空间与可执行文件的映射关系结构起到了很关键的作用，操作系统将查询这个数据结构，找到空页面所在的段，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还回给进程，进程从刚才页错误的位置重新开始执行。</p><p>随着进程的执行，页错误也会不断地产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求。有时进程所需内存会超过实际可用的内存，这时候系统会把不常用的内存数据转移到磁盘中，来提升内存使用效率。</p><p><img src="/images/程序员的自我修养：装载与动态链接/6.3.2-1.png" alt="6.3.2-1" style="zoom:50%;" /></p><h3 id="6-4-进程虚拟内存空间分布"><a href="#6-4-进程虚拟内存空间分布" class="headerlink" title="6.4 进程虚拟内存空间分布"></a>6.4 进程虚拟内存空间分布</h3><h4 id="6-4-1-ELF文件链接视图和执行视图"><a href="#6-4-1-ELF文件链接视图和执行视图" class="headerlink" title="6.4.1 ELF文件链接视图和执行视图"></a>6.4.1 ELF文件链接视图和执行视图</h4><p>在ELF文件中，一般会有很多段，在把段加载到内存中时，会分配单独的内存页来控制段的内存权限。不过很多段都很小，这样单独分配一个内存页太浪费空间。所以处于节省内存的考虑，就在ELF文件中新增了Segment的概念，即把内存属性相似的段合在一起，形成Segment。</p><p>Segment的概念实际上是从装载的角度重新划分了ELF的各个分段。在将目标文件链接成可执行文件的时候，链接器会尽可能把相同权限属性的段分配在同一空间。</p><p>这样本来以前可能有几十个段，现在合并内存权限相似的同类项，最后只形成几个Segment。这样系统在加载时只用进行有限的几种内存权限控制就行了。</p><p>所以总的来说，“Segment”和“Section”是从不同的角度来划分同一个EF文件。这个在ELF中被称为不同的视图（View），从“Section”的角度来看ELF文件就是链接视图（Linking view），从“Segment”的角度来看就是执行视图（Execution view）。当我们在谈到ELF装载时，“段”专门指“Segment”；而在其他的情况下，“段”指是“Section”</p><p>ELF文件保存“Segment”信息的数据结构叫做程序头表（Program Header Table）。因为ELF目标文件不需要被装载，所以它没有程序头表；而经过静态/动态链接的ELF的可执行文件以及共享库文件都有。</p><p>和段表结构一样，程序头表也是一个数组结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word p_type;</span><br><span class="line">    Elf32_Off  p_offset;</span><br><span class="line">    Elf32_Addr p_vaddr;</span><br><span class="line">    Elf32_Addr p_paddr;</span><br><span class="line">    Elf32_Word p_filesz;</span><br><span class="line">    Elf32_Word p_memsz;</span><br><span class="line">    Elf32_Word p_flags;</span><br><span class="line">    Elf32_Word p_align;</span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure><p>具体的字段解释如下：</p><div class="table-container"><table><thead><tr><th>成员</th><th>含义</th></tr></thead><tbody><tr><td>p_type</td><td>这里主要关注“LOAD”类型。它的常量为1。还有“DYNAMIC”等类型（动态链接用）</td></tr><tr><td>p_offset</td><td>在ELF文件中的偏移量</td></tr><tr><td>p_vaddr</td><td>在进程虚拟内存空间中的起始位置。整个程序头表中，所有“LOAD”类型的元素按照p_addr从小到大排列</td></tr><tr><td>p_paddr</td><td>物理装载地址。一般和p_vaddr一样</td></tr><tr><td>p_filesz</td><td>在ELF文件中所占字节数</td></tr><tr><td>p_memse</td><td>在进程虚拟内存空间中所占字节数。可能大于p_filesz</td></tr><tr><td>p_flags</td><td>权限属性，如可写、可读、可执行</td></tr><tr><td>p_align</td><td>对齐属性。对齐字节数等于$ 2^{align}$。如p_align=10，那对齐字节数就是2的10次方，即1024</td></tr></tbody></table></div><p>对于“LOAD”类型的“Segment”来说，p_memse的值不可以小于p_files。但可以大于p_files。当大于p_files就表示该“Segment”在内存中所分配的空间大小超过文件中实际的大小。这部分“多余”的内存全部填充为“0”。这样做的好处是在构造ELF可执行文件时不需要再额外设立BSS的“Segment”了，可以把数据“Segment”的p_mems扩大，那些额外的部分就是BSS。</p><h4 id="6-4-2-堆和栈"><a href="#6-4-2-堆和栈" class="headerlink" title="6.4.2 堆和栈"></a>6.4.2 堆和栈</h4><p>Linux把进程虚拟空间中的一个段叫做虚拟内存区域（VMA，Virtual Memory Area）。之前说的Segment都会映射的VMA里。操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间。应用程序使用的栈和堆也是通过VMA来进行管理的。一个常见的进程虚拟空间如下图所示：</p><p><img src="/images/程序员的自我修养：装载与动态链接/6.4.2-1.png" alt="6.4.2-1" style="zoom:50%;" /></p><h2 id="7-动态链接"><a href="#7-动态链接" class="headerlink" title="7 动态链接"></a>7 动态链接</h2><h3 id="7-1-为什么要动态链接"><a href="#7-1-为什么要动态链接" class="headerlink" title="7.1 为什么要动态链接"></a>7.1 为什么要动态链接</h3><p>静态链接使得程序可以模块化开发和测试大幅提高开发效率。不过随着程序规模越来越大静态链接的诸多缺点也逐步暴露出来：</p><ul><li><p>内存和磁盘空间浪费</p><p>比如有个流行的库文件LibA，很多软件产品都使用，这些软件产品的最终可执行文件中都会包含LibA。某个用户电脑上安装多个软件产品后，电脑中就会存在多分LibA的副本。而且运行多个程序时，内存中也会存在多个LibA的副本。</p></li><li><p>程序开发和发布比较麻烦</p><p>如果LibA有bug，厂商发布了补丁以后，必须重新链接。用户需要重新下载整个可执行文件， 但是除了LibA意外，其他的都没有必要再下载一次。</p></li></ul><p>解决空间浪费和更新困难的办法就是把程序的模块相互分割开来，形成独立的文件，当程序要运行时再进行链接。这样库LibA是以独立的文件存在，多个程序可以共享，避免内存和磁盘的浪费；也能独立地发布和更新，提高软件产品的生产效率。上面这种按模块分割、到运行的时候再链接就是动态链接（Dynamic Linking）。</p><h3 id="7-3-地址无关代码"><a href="#7-3-地址无关代码" class="headerlink" title="7.3 地址无关代码"></a>7.3 地址无关代码</h3><h4 id="7-3-1-固定装载地址的困扰"><a href="#7-3-1-固定装载地址的困扰" class="headerlink" title="7.3.1 固定装载地址的困扰"></a>7.3.1 固定装载地址的困扰</h4><p>因为动态链接的库可能被多个程序使用，会被不同的程序加载到不同的位置。所以动态链接文件在编译时不能假设自己在进程的虚拟内存空间中的位置。</p><h4 id="7-3-2-装载时重定位"><a href="#7-3-2-装载时重定位" class="headerlink" title="7.3.2 装载时重定位"></a>7.3.2 装载时重定位</h4><p>在静态链接时说起过，符号要在编译时进行解析和重定位。这里也可以用同样的做法，即程序在运行时把动态链接库像静态库一样进行解析和重定位，这时的重定位叫做装载时重定位（Load Time Relocation），之前提到的重定位叫链接时重定位（Link Time Relocation）。</p><p>装载时重定位技术对于动态链接库的指令部分和数据部分有不同的影响。</p><p>对于数据部分来说。每个进程的数据都需要独立存在，所以动态链接库的数据部分在每个进程中都需要一个副本。</p><p>对于指令部分来说，从同一个可执行文件运行的进程，其指令部分必然是一样的。所以同一份动态链接库在内存中有多个副本是没有必要的。但是动态链接模块在装载时要进行重定位，需要修改指令引用的地址，A进程重定位后的动态链接库内指令引用的地址已经被修改，以适应A的进程空间里。这时，动态链接库肯定不能用到B上，所以B只能再把动态链接库重新制作一份副本，再进行一次装载时重定位。所以就造成在内存中存在同一份动态库的多个副本。</p><h4 id="7-3-3-地址无关代码"><a href="#7-3-3-地址无关代码" class="headerlink" title="7.3.3 地址无关代码"></a>7.3.3 地址无关代码</h4><p>要解决动态库指令部分重复的办法关键在于指令的地址。程序模块中共享的指令部分在装载时不要因为装载地址的改变而改变。</p><p>解决方案的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为地址无关代码（PC，Position-independent Code）的技术。</p><p>因为模块内的引用可以用模块内的相对地址偏移来实现，比较简单，所以地址无关的代码重点放在模块间的数据和指令的引用。</p><h5 id="模块间的数据访问"><a href="#模块间的数据访问" class="headerlink" title="模块间的数据访问"></a>模块间的数据访问</h5><p>之前提到，要使得代码地址无关，基本的思想就是把跟地址相关的部分放到数据段里面。很显然，这些其他模块的全局变量的地址是跟模块装载地址有关的。ELF的做法是在数据段里面建立一个指向这些变量的指针数组，也被称为全局偏移表（GOT，Global Offset Table），当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用。</p><p>当指令中需要访问某个模块外的全局变量时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4个字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。</p><h5 id="模块间的函数跳转"><a href="#模块间的函数跳转" class="headerlink" title="模块间的函数跳转"></a>模块间的函数跳转</h5><p>对于模块间的函数跳转也可以用GOT的方法，即在GOT表项中保存目标函数地址，当模块要调用函数时，通过GOT间接跳转。</p><h4 id="7-3-4-共享模块的全部变量问题"><a href="#7-3-4-共享模块的全部变量问题" class="headerlink" title="7.3.4 共享模块的全部变量问题"></a>7.3.4 共享模块的全部变量问题</h4><p>有一种很特殊的情况是，当一个模块引用了一个定义在共享对象的全局变量的时候，比如一个共享对象定义了一个全局变量global，而模块module.c中是这么引用的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> global;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    global = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器编译module.c时，它无法根据这个上下文判断global是定义在同一个模块的的其他目标文件还是定义在另外一个共享对象之中，即无法判断是否为跨模块间的调用。</p><p>假设module.c是程序可执行文件的一部分，那么在这种情况下，由于程序主模块的代码并不是地址无关代码。由于可执行文件在运行时并不进行代码重定位，所以变量的地址必须在链接过程中确定下来。为了能够使得链接过程正常进行，链接器会在创建可执行文件时，在它的“.bss”段创建一个global变量的副本。那么问题就很明显了，现在global变量定义在原先的共享对象中，而在可执行文件的“.bss”段还有一个副本。如果同一个变量同时存在于多个位置中，这在程序实际运行过程中肯定是不可行的。</p><p>解决的办法只有一个，那就是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。ELF共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量，通过GOT来实现变量的访问。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把GOT中的相应地址指向该副本，这样该变量在运行时实际上最终就只有一个实例。如果变量在共享模块中被初始化，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本里；如果该全局变量在程序主模块中没有副本，那么GOT中的相应地址就指向模块内部的该变量副本。</p><h4 id="7-3-5-数据段地址无关性"><a href="#7-3-5-数据段地址无关性" class="headerlink" title="7.3.5 数据段地址无关性"></a>7.3.5 数据段地址无关性</h4><p>通过上面的方法，我们能够保证共享对象中的代码部分地址无关，其实数据部分也有绝对地址引用的问题。不过对于数据段来说，它在每个进程都有一份独立的副本，所以并不担心被进程改变。从这点来看，我们可以选择装载时重定位的方法来解决数据段中绝对地址引用问题。</p><p>对于共享对象来说，如果数据段中有绝对地址引用，那么编译器和链接器就会产生一个重定位表，用于解决上述问题。当动态链接器装载共享对象时，如果发现该共享对象有这样的重定位入口，那么动态链接器就会对该共享对象进行重定位。</p><p>实际上，我们甚至可以让代码段也使用这种装载时重定位的方法，而不使用地址无关代码。不过如果代码不是地址无关的，它就不能被多个进程之间共享，于是也就失去了节省内存的优点。但是装载时重定位的共享对象的运行速度要比使用地址无关代码的共享对象快，因为它省去了地址无关代码中每次访问全局数据和函数时需要做一次计算当前地址以及间接地址寻址的过程。</p><h3 id="7-4-延迟绑定（PLT）"><a href="#7-4-延迟绑定（PLT）" class="headerlink" title="7.4 延迟绑定（PLT）"></a>7.4 延迟绑定（PLT）</h3><p>动态链接比静态链接灵活，但是这是以牺牲一部分性能为代价的。动态链接比静态链接慢的主要原因是动态链接下要进行复杂的GOT定位以及间接寻址。另外一个原因是动态链接的链接工作在程序启动前完成，在启动前动态链接器会寻找并装载所需要的共享对象，进行符号査找地址重定位等工作，这一套流程下来势会必减慢程序的启动速度。下面就来介绍下优化动态链接性能的一些方法。</p><h5 id="延迟绑定实现"><a href="#延迟绑定实现" class="headerlink" title="延迟绑定实现"></a>延迟绑定实现</h5><p>在动态链接下，程序模块之间包含了大量的函数引用（全局变量往往比较少，因为大量的全局变量会导致模块之间耦合度变大），所以在程序开始执行前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号査找以及重定位，这也是我们上面提到的减慢动态链接性能的第二个原因。</p><p>不过在一个程序运行过程中，可能很多冷门模块的函数在程序执行完时都不会被用到。所以没必要一开始就把所有函数都链接好。因此ELF采用了一种叫做延迟绑定（Lazy Binding）的做法，就是当函数第一次被用到时才进行绑定（符号查找、重定位等），如果没有用到则不进行绑定。所以可以大大加快程序的启动速度</p><p>ELF使用PLT（Procedure Linkage Table）的方法来实现。PLT为了实现延迟绑定，在GOT间接跳转这个过程中间又增加了一层间接跳转。所有外部函数在PLT中都有一个对应项，调用函数时，会先调用PLT对应项的处理函数，它会先检查GOT中函数指针是否已经绑定，如果没有绑定会进行绑定，把正确的函数地址填入GOT表中，然后再调用GOT中的函数。</p><h3 id="7-5-动态链接相关结构"><a href="#7-5-动态链接相关结构" class="headerlink" title="7.5 动态链接相关结构"></a>7.5 动态链接相关结构</h3><h4 id="7-5-1-“-interp”段"><a href="#7-5-1-“-interp”段" class="headerlink" title="7.5.1 “.interp”段"></a>7.5.1 “.interp”段</h4><p>在Linux下，动态链接器ld.so实际上也是一个共亨对象，操作系统同样通过映射的方式将它加载到进程的地址空间中。操作系统在加载完动态链接器之后，就将控制权交给动态链接器的入口地址（与可执行文件一样，共享对象也有入口地址）。当动态链接器得到控制权之后，它开始执行一系列自身的初始化操作，然后根据当前的环境参数，开始对可执行文件进行动态链接工作。当所有动态链接工作完成以后，动态链接器会将控制权转交到可执行文件的入口地址，程序开始正式执行。</p><p>在ELF文件中，有个叫“.interp”的段，专门用来保存可执行文件所需要的动态链接器的路径。</p><h4 id="7-5-2-“-dynamic”段"><a href="#7-5-2-“-dynamic”段" class="headerlink" title="7.5.2 “.dynamic”段"></a>7.5.2 “.dynamic”段</h4><p>动态链接ELF中最重要的结构就是“.dynamic”段，这个段里面保存了动态链接器所需要的基本信息，比如依赖哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。它的结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><p>EI32Dyn结构由一个类型值加上一个附加的数值或指针，对于不同的类型，后面附加的数值或者指针有着不同的含义。这里列举几个比较常见的类型值：</p><div class="table-container"><table><thead><tr><th>d_tag类型</th><th>d_un含义</th></tr></thead><tbody><tr><td>DT_SYMTAB</td><td>动态链接符号表地址，d_ptr表示“.dynamic”的地址</td></tr><tr><td>DT_STRTAB</td><td>动态链接字符串表地址，d_ptr表示“.dynstr”的地址</td></tr><tr><td>DT_STRSZ</td><td>动态链接字符串表大小，d_val表示大小</td></tr><tr><td>DT_HASH</td><td>动态链接哈希表地址，d_val表示“.hash”的地址</td></tr><tr><td>DT_SONAME</td><td>本共享对象的“SO-NAME”</td></tr><tr><td>DT_RPATH</td><td>动态链接共享对象搜索路径</td></tr><tr><td>DT_INIT</td><td>初始化代码地址</td></tr><tr><td>DT_FINIT</td><td>反初始化代码地址</td></tr><tr><td>DT_NEED</td><td>依赖的其他共享对象文件，d_ptr表示所依赖的共享对象文件名</td></tr><tr><td>DT_REL / DT_RELA</td><td>动态链接重定位表地址</td></tr><tr><td>DT_RELENT / DT_RELAENT</td><td>动态重定位表入口数量</td></tr></tbody></table></div><h4 id="7-5-3-动态符号表"><a href="#7-5-3-动态符号表" class="headerlink" title="7.5.3 动态符号表"></a>7.5.3 动态符号表</h4><p>在静态链接中，有一个专门的段叫做符号表“symtab”（Symbol Table），里面保存了所有关于该目标文件的符号的定义和引用。动态链接的符号表跟它十分相似，叫做动态符号表（Dynamic Symbol Table），用来保存模块间的符号导入导出关系，这个段的段名通常叫做“.dynsym”（Dynamic Symbol）。</p><p>与“.symtab”不同的是，“.dynsym”只保存了与动态链接相关的符号，对于那些模块内部的符号则不保存。很多时候动态链接的模块同时拥有“.dynsym”和“.symtab”两个表，“.symtab”中往往保存了所有符号，包括“.dynsym”中的符号。</p><p>与“.symtab”类似，动态符号表也需要一些辅助的表，比如用于保存符号名的字符串表。静态链接时叫做符号字符串表“.strtab”（String Table），在这里就是动态符号字符串表”.dynstr”（Dynamic String Table）；由于动态链接下，我们需要在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的符号哈希表（“.hash”）。</p><h4 id="7-5-4-动态链接重定位表"><a href="#7-5-4-动态链接重定位表" class="headerlink" title="7.5.4 动态链接重定位表"></a>7.5.4 动态链接重定位表</h4><p>共享对象的重定位与静态链接”的目标文件的重定位十分类似，唯一有区别的是目标文件的重定位是在静态链接时完成的，而共享对象的重定位是在装载时完成的。</p><p>在静态链接中，日标文件里面包含有专门用于表示重定位信息的重定位表，比如“.rel.text”表示是代码段的重定位表，“.rel.data”是数据段的重定位表。动态链接的文件中，也有类似的重定位表分别叫做“rel.dyn”和“rel.plt’”，它们分别相当于“.rel.text”和“.rel.data”。“rel.dyn”是对数据引用的修正，它所修正的位置位于“got”以及数据段；而“rel.plt”是对函数引用的修正，它所修止的位置位于“.got.plt”。</p><h3 id="7-6-动态链接的步骤和实现"><a href="#7-6-动态链接的步骤和实现" class="headerlink" title="7.6 动态链接的步骤和实现"></a>7.6 动态链接的步骤和实现</h3><h4 id="7-6-1-动态链接器自举"><a href="#7-6-1-动态链接器自举" class="headerlink" title="7.6.1 动态链接器自举"></a>7.6.1 动态链接器自举</h4><p>动态链接器本身也是一个共享对象，但是它有一些特殊性。对于普通共享对象文件来说，它的重定位工作由动态链接器来完成；它也可以依赖于其他共亨对象，其中的被依赖的共亨对象由动态链接器负责链接和装载。可是对于动态链接器本身来说，它是一切动态加载的起源，所以它有一些特殊。</p><p>动态链接器本身不可以依赖于其他任何共享对象；其次是动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成。对于第一个条件我们可以人为地控制，在编写动态链接器时保证不使用任何系统库、运行库；对于第二个条件，动态链接器必须在启动时有段非常精巧的代码可以完成这项艰巨的工作而同时又不能用到全局和静态变量。这种具有一定限制条件的启动代码往往被称为自举（Boot strap）。</p><p>动态链接器入口地址即是自举代码的入口，当操作系统将进程控制权交给动态链接器时，动态链接器的自举代码即开始执行。自举代码首先会找到它自己的GOT。而GOT的第一个入口保存的即是“.dynamic”段的偏移地址，由此找到了动态连接器本身的“.dynamic”段。通过“.dynamic”中的信息，自举代码便可以获得动态链接器本身的重定位表和符号表等，从而得到动态链接器本身的重定位入口，先将它们全部重定位。从这一步开始，动态链接器代码中才可以开始使用自己的全局变量和静态变量。</p><p>实际上在动态链接器的自举代码中，除了不可以使用全局变量和静态变量之外，甚至不能调用函数，即动态链接器本身的函数也不能调用。因为动态链接库模块使用GOT/PLT的方式编译，对于模块内部的函数调用也是采用跟模块外部函数调用一样的方式，所以在GOT/PLT没有被重定位之前，自举代码不可以使用任何全局变量，也不可以调用函数。</p><h4 id="7-6-2-装载共享对象"><a href="#7-6-2-装载共享对象" class="headerlink" title="7.6.2 装载共享对象"></a>7.6.2 装载共享对象</h4><p>完成基本自举以后，动态链接器将可执行文件和链接器本身的符号表都合并到一个全局符号表（Global Symbol Table）。然后链接器开始寻找可执行文件所依赖的共享对象，前面提到过“.dynamic”段中，有一种类型的是DT_NEEDED，它所指出的是该可执行文件（或共享对象）所依赖的共享对象。由此，链接器可以列出可执行文件所需要的所有共享对象，并将这些共享对象的名字放入到一个装载集合中。然后链接器开始从集合里取个所需要的共享对象的名字，找到相应的文件后打开该文件，读取相应的ELF文件头和“.dynamic”段，然后将它相应的代码段和数据段映射到进程空间中。如果这个ELF共享对象还依赖于其他共享对象，那么将所依赖的共享对象的名字放到装载集合中。如此循环直到所有依赖的共享对象都被装载进来为止，当然链接器可以有不同的装载顺序，如果我们把依赖关系看作一个图的话，那么这个装载过程就是一个图的遍历过程，链接器可能会使用深度优先或者广度优先或者其他的顺序来遍历整个图，这取决于链接器，比较常见的算法一般都是广度优先的。</p><p>当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中，所以当所有的共享对象都被装载进来的时候，全局符号表里面将包含进程中所有的动态链接所需要的符号。</p><h5 id="符号优先级"><a href="#符号优先级" class="headerlink" title="符号优先级"></a>符号优先级</h5><p>在加载多个动态链接库时，可能会遇到符号冲突的问题。Linux下的动态链接器规定：当一个符号需要被加入全局符号表时，如果相同符号已经存在，则后加入的符号被忽略。</p><p>由于存在这种重名符号被直接忽略的问题，当程序使用大量共享对象时应该非常小心符号的重名问题，如果两个符号重名又执行不同的功能，那么程序运行时可能会将所有该符号名的引用解析到第一个被加入全局符号表的使用该符号名的符号，从而导致程序莫名其妙的错误。</p><h5 id="全局符号介入与地址无关代码"><a href="#全局符号介入与地址无关代码" class="headerlink" title="全局符号介入与地址无关代码"></a>全局符号介入与地址无关代码</h5><p>前面说到地址无关代码时，对于模块内部调用或跳转处理，只是简单地将其当作是相对地址调用/跳转。但实际上这个问题比想象中要复杂。由于存在全局符号会覆盖的情况，调用或跳转一个模块内的符号时，它可能会被其他的全局符号覆盖，导致那个相对地址部分就需要重定位，这又与共享对象的地址无关性矛盾。所以对于模块内的调用，编译器只能当作模块外部符号处理。</p><p>不过也有一个补救办法。就是把函数变成编译单元私有函数，即使用“static”关键字定义函数，这种情况下，编译器要确定函数不被其他模块覆盖，就可以直接用模块内部调用指令，加快函数的调用速度。</p><h4 id="7-6-3-重定位和初始化"><a href="#7-6-3-重定位和初始化" class="headerlink" title="7.6.3 重定位和初始化"></a>7.6.3 重定位和初始化</h4><p>当上面的步骤完成之后，链接器开始重新遍历可执行文件和每个共享对象的重定位表，将它们的GOT/PLT中的每个需要重定位的位置进行修正。因为此时动态链接器已经拥有了进程的全局符号表，所以修正过程也比较容易，跟前面提到的地址重定位的原理基本相同。</p><p>重定位完成之后，如果某个共享对象有“.init”段，那么动态链接器会执行“.init”段中的代码，用以实现共享对象特有的初始化过程，比如最常见的，共享对象中的C++的全局/静态对象的构造就需要通过“.init”来初始化。相应地，共享对象中还可能有“.finit”段，当进程退出时会执行“.finit”段中的代码，可以用来实现类似C++全局对象析构之类的操作</p><p>如果进程的可执行文件也有“.init”段，那么动态链接器不会执行它，因为可执行文件中的“.init”段和“.finit”段由程序初始化部分代码负责执行。</p><p>当完成了重定位和初始化之后，所有的准备工作就宣告完成了，所需要的共享对象也都已经装载并且链接完成了，这时候动态链接器就将进程的控制权转交给程序的入口并且开始执行。</p><h3 id="7-7-显式运行时链接"><a href="#7-7-显式运行时链接" class="headerlink" title="7.7 显式运行时链接"></a>7.7 显式运行时链接</h3><p>支持动态链接的系统往往都支持一种更加灵活的模块加载方式，叫做显式运行时链接（Explicit Run-time Linking），有时候也叫做运行时加载。也就是让程序自己在运行时控制加载指定的模块，并且可以在不需要该模块时将其卸载。从前面我们了解到的来看，如果动态链接器可以在运行时将共享模块装载进内存并且可以进行重定位等操作，那么这种运行时加载在理论上也是很容易实现的。而且一般的共享对象不需要进行任何修改就可以进行运行时装载，这种共享对象往往被叫做动态装载库（DynamicLoadingLibrary），其实本质上它跟一般的共享对象没什么区别，只是程序开发者使用它的角度不同。</p><p>这种运行时加载使得程序的模块组织变得很灵活，可以用来实现一些诸如插件、驱动等功能。当程序需要用到某个插件或者驱动的时候，才将相应的模块装载进来，而不需要从开始就将他们全部装载进来，从而减少了程序启动时间和内存使用。并且程序可以在运行的时候重新加载某个模块，这样使得程序本身不必重新启动而实现模块的增加、删除、更新等，这对于很多需要长期运行的程序来说是很大的优势。最常见的例子是web服务器程序，对于web服务器程序来说，它需要根据配置来选择不同的脚本解释器、数据库连接驱动等，对于不同的脚本解释器分别做成一个独立的模块，当web服务器需要某种脚本解释器的时候可以将其加载进来；这对于数据库连接的驱动程序也是一样的原理。另外对于一个可靠的web服务器来说，长期的运行是必要的保证，如果我们需要增加某种脚本解释器，或者某个脚本解释器模块需要升级，则可以通知web服务器程序重新装载该共亨模块以实现相应的目的。</p><p>在Linux中，从文件本身的格式上来看，动态库实际上跟一般的共享对象没有区别，正如我们前面讨论过的。主要的区别是共享对象是由动态链接器在程序启动之前负责装载和链接的，这一系列步骤都由动态连接器自动完成，对于程序本身是透明的；而动态库的装载则是通过一系列由动态链接器提供的API，具体地讲共有4个函数：打开动态库（dlopen）、查找符号（dsym）、错误处理（dlerror）以及关闭动态库（dlclose），程序可以通过这几个API对动态库进行操作。这几个API的实现是在/lib/libdl.so2里面，它们的声明和相关常量被定义在系统标准头文件<dlfcn.h>。</p><ul><li><p>dlopen()</p><p>打开一个动态库，并将其加载到进程的地址空间，完成初始化过程。</p><p>如果参数filename为NUL，那返回的就是全局符号表。</p></li><li><p>dlsym()</p><p>通过这个函数来查找符号，包括函数和变量。</p><p>前面在介绍动态链接实现时，已经碰到过许多共享模块中符号名冲突的问题，结论是当多个同名符号冲突时，先装入的符号优先，我们把这种优先级方式称为装载序列。</p><p>当我们的进程中有模块是通过dlopen装入的共享对象时，这些后装入的模块中的符号可能会跟先前已经装入了的模块之间的符号重复。不管是通过动态链接器加载还是程序主动加载，都是采用装载序列。</p><p>dlsym()对符号的查找优先级分两种类型。第一种情况是，如果我们是在全局符号表中进行符号查找，即dlopen()时，参数filename为NUL，那就是和全局符号表生成时的顺序一样，采用装载序列。第二种情况是如果我们是对某个通过dlopen()打开的共享对象进行符号查找的话，那么采用的是一种叫做依赖序列的优先级。它是以被dlopen()打开的那个共享对象为根节点，对它所有依赖的共享对象进行广度优先遍历的顺序。</p></li><li><p>dlerror()</p><p>调用dlopen()、dlsym()、dlclose()后，都可以用dlerror()来检查是否成功</p></li><li><p>dlclose()</p><p>卸载一个已经加载的模块。</p></li></ul>]]></content>
    
    <summary type="html">
    
      《程序员的自我修养》的读书笔记
    
    </summary>
    
      <category term="CS基础" scheme="http://petpwiuta.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养：静态链接</title>
    <link href="http://petpwiuta.github.io/2020/05/09/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://petpwiuta.github.io/2020/05/09/程序员的自我修养：静态链接/</id>
    <published>2020-05-09T05:38:24.809Z</published>
    <updated>2020-05-09T05:38:24.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-目标文件里有什么"><a href="#3-目标文件里有什么" class="headerlink" title="3 目标文件里有什么"></a>3 目标文件里有什么</h2><h3 id="3-1-目标文件格式"><a href="#3-1-目标文件格式" class="headerlink" title="3.1 目标文件格式"></a>3.1 目标文件格式</h3><p>现在PC平台流行的可执行文件格式主要是Windows的PE（Portable Executable）和Linux的ELF（Executable Linkable Format）格式。它们都是COFF（Common file format）格式的变种。</p><p>其实可执行文件与动态库/静态库文件大致结构是类似的，仅仅是因为不同目的而具有不同的段数据而已。目标文件大致可分为以下几种：</p><div class="table-container"><table><thead><tr><th style="text-align:center">ELF文件类型</th><th style="text-align:center">说明</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">可从定位文件（Relocatable File）</td><td style="text-align:center">这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类</td><td style="text-align:center">Linux的<code>.o</code> / Windows的<code>.obj</code></td></tr><tr><td style="text-align:center">可执行文件（Executable File）</td><td style="text-align:center">这类文件包含了代码和数据，可以直接执行，一般都没有扩展名</td><td style="text-align:center">Linux的<code>.out</code> / Windows的<code>.exe</code></td></tr><tr><td style="text-align:center">共享目标文件（Shared Object File）</td><td style="text-align:center">这种文件包含了代码和数据，可以跟其他的可重定位文件和共享目标文件静态链接。也可以通过动态链接器将几个这种共享目标文件与可执行文件结合，作为进程映像的部分来运行</td><td style="text-align:center">Linux的<code>.so</code> / Windows的<code>.dll</code></td></tr><tr><td style="text-align:center">核心转储文件（Core Dump File）</td><td style="text-align:center">当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件</td><td style="text-align:center">Linux的core dump</td></tr></tbody></table></div><h3 id="3-2-目标文件是什么样的"><a href="#3-2-目标文件是什么样的" class="headerlink" title="3.2 目标文件是什么样的"></a>3.2 目标文件是什么样的</h3><p>目标文件里面的内容有数据和机器码。这些内容被按照不同的属性分成了多个Section，也叫做“段”。如专门放代码的<code>.text</code>/<code>.code</code>段，专门放数据的<code>.data</code>段······</p><p>很多段的名字都是以一个 <code>.</code>符号（句点）开始，这表示是系统保留的段，对于用户自己设立的段可以不以点号开始。</p><p>总的来说程序员代码被编译后主要分成了两种段：指令和数据。指令和数据起始是分开存放的，这样做的原因主要是处于以下几点原因：</p><ul><li>系统可能会同时运行程序的多个副本，此时，程序的代码部分都是完全一样的，仅仅只有数据不同。指令部分抽离出来形成单独的段，可以让程序的副本共享同一个指令段，节省内存</li><li>现代的CPU有着强大的指令缓存体系，指令放到独立的段，有助于CPU预加载指令，来提高执行性能</li><li>指令放到单独的段可以精细控制内存访问属性，防止代码指令被修改</li></ul><h3 id="3-3-目标文件详解"><a href="#3-3-目标文件详解" class="headerlink" title="3.3 目标文件详解"></a>3.3 目标文件详解</h3><p>在Linux下，可以用objdump来把目标文件的段信息打印出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -s -d object_file.o  <span class="comment">#-s表示16进制打印，-d表示把所有包含指令的段反汇编</span></span></span><br></pre></td></tr></table></figure><p><code>.data</code> 段保存了初始化了的全局静态变量和局部静态变量</p><p><code>.rodata</code> 段保存了制度数据，如const修饰的变量，和字符串变量</p><p><code>.bss</code> 段存放的是未初始化的全局变量和局部静态变量</p><p>还有一些其他的常见的段：</p><div class="table-container"><table><thead><tr><th style="text-align:left">段名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:left">.rodata1</td><td style="text-align:center">只读数据，和rodata类似</td></tr><tr><td style="text-align:left">.comment</td><td style="text-align:center">存放编译器版本信息</td></tr><tr><td style="text-align:left">.debug</td><td style="text-align:center">调试信息</td></tr><tr><td style="text-align:left">.dynamic</td><td style="text-align:center">动态链接库中才会用到，用来存放动态链接数据</td></tr><tr><td style="text-align:left">.hash</td><td style="text-align:center">加速符号查找的hash算法用到的段</td></tr><tr><td style="text-align:left">.line</td><td style="text-align:center">存储行号，用来调试</td></tr><tr><td style="text-align:left">.note</td><td style="text-align:center">额外的编译器信息，如公司名字等</td></tr><tr><td style="text-align:left">.strtab</td><td style="text-align:center">字符串表，用于存储ELF文件中用到的各种字符串</td></tr><tr><td style="text-align:left">.symtab</td><td style="text-align:center">符号表</td></tr><tr><td style="text-align:left">.shstrtab</td><td style="text-align:center">段名表</td></tr><tr><td style="text-align:left">.plt / .got</td><td style="text-align:center">动态链接的跳转和全局入口表</td></tr><tr><td style="text-align:left">.init / .fini</td><td style="text-align:center">C++全局构造和析构代码段</td></tr></tbody></table></div><h3 id="3-4-ELF文件结构描述"><a href="#3-4-ELF文件结构描述" class="headerlink" title="3.4 ELF文件结构描述"></a>3.4 ELF文件结构描述</h3><p>ELF目标文件格式的最前部是ELF文件头（ELF Header），它包含了描述整个文件的基本属性，如ELF文件版本、目标机器型号、程序入口地址等。</p><p>紧接着是ELF文件各个段。其中最重要结构就是段表（Section Header Table），该表描述了ELF文件包含的所有段的信息，比如每个段的段名、长度、在文件中的偏移、读写权限及段的其他属性。</p><p>还有就是一些ELF中辅助的结构，比如字符串表、符号表等：</p><p><img src="/images/程序员的自我修养：静态链接/3.4-1.png" alt="3.4-1" style="zoom:50%;" /></p><h4 id="3-4-1-文件头"><a href="#3-4-1-文件头" class="headerlink" title="3.4.1 文件头"></a>3.4.1 文件头</h4><p>可以用readelf命令来详细查看elf文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> readelf -h object_file.o <span class="comment">#-h 表示header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  ELF 头：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Magic：  7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  类别:                              ELF32</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  数据:                              2 补码，小端序 (little endian)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Version:                           1 (current)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  ABI 版本:                          0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  类型:                              EXEC (可执行文件)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  系统架构:                          Intel 80386</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  版本:                              0x1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  入口点地址：              0x8049000</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  程序头起点：              52 (bytes into file)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Start of section headers:          8228 (bytes into file)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Size of section headers:           40 (bytes)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Number of section headers:         4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Section header string table index: 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  标志：             0x0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Size of this header:               52 (bytes)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Start of program headers:          0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Size of program headers:           32 (bytes)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Number of program headers:         3</span></span><br></pre></td></tr></table></figure><p>从上而输出的结果可以看到，ELF的文件头中定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、AB版本、ELF重定位类型、硬件平台、硬件平台版本入口地址、程序头入口和长度、段表的位置和长度及段的数量等。</p><p>这里面非常重要的几个字段是：</p><ul><li><p>ELF Magic Number。这个常数用来识别这个文件属于ELF格式。很多二进制文件开头都有Magic Number，ELF格式也例外</p></li><li><p>类型（Type）。表示该ELF是可执行文件还是静态库/动态库或者是其他类型</p></li><li><p>入口点地址（Entry point address）。操作系统加载完该程序后，会从这个地址开始执行代码。只有可执行文件这个字段是有效的</p></li><li><p>段表信息</p><ul><li>段表的偏移地址（Start of section headers）。表示段表在ELF文件的第N个字节处开始</li><li>段表的描述符大小（Size of section headers）。表示一个段表的描述结构的大小</li><li>段表的描述符数量（Number of section headers）。表示有多少个段表</li><li>段名的下标（Section header string table index）。</li></ul><p>一个段从哪儿开始，每个段长度多少，有多少个段。有了这些信息就能找到每个段的数据。</p></li><li><p>Segment表信息</p><ul><li>Segment的偏移地址（Start of program headers）。表示Segment表在ELF文件的第N个字节处开始</li><li>Segment的描述符大小（Size of program headers）。表示一个Segment的描述结构的大小</li><li>Segment的描述符数量（Number of program headers）。表示有多少个Segment表</li></ul><p>在ELF文件中，一般会有很多段，在把段加载到内存中时，会分配单独的内存页来控制段的内存权限。不过很多段都很小，这样单独分配一个内存页太浪费空间。所以处于节省内存的考虑，就在ELF文件中新增了Segment的概念，即把内存属性相似的段合在一起，形成Segment。</p><p>这样本来以前可能有几十个段，现在合并内存权限相似的同类项，最后只形成几个Segment。这样系统在加载时只用进行有限的几种内存权限控制就行了。</p><p>不过Segment和并不是彼此替代关系。所有的Segment和所有的段表示的内容必然是一样的，只是两者侧重点不同，段是为了方便编译和执行而出现的；而Segment则是为了方便系统加载程序而出现。</p></li></ul><h4 id="3-4-2-段表"><a href="#3-4-2-段表" class="headerlink" title="3.4.2 段表"></a>3.4.2 段表</h4><p>之前用的readelf命令也可以用来来查看段表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> readelf -S object_file.o <span class="comment">#-S 表示Section</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  There are 15 section headers, starting at offset 0x308:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash">  节头：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 1] .group            GROUP           00000000 000034 000008 04     12  12  4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 2] .text             PROGBITS        00000000 00003c 000051 00  AX  0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 3] .rel.text         REL             00000000 000244 000030 08   I 12   2  4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 4] .data             PROGBITS        00000000 00008d 000000 00  WA  0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 5] .bss              NOBITS          00000000 00008d 000000 00  WA  0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 6] .rodata           PROGBITS        00000000 00008d 00001a 00   A  0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 7] .text.__x86.get_p PROGBITS        00000000 0000a7 000004 00 AXG  0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 8] .comment          PROGBITS        00000000 0000ab 000012 01  MS  0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 9] .note.GNU-stack   PROGBITS        00000000 0000bd 000000 00      0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [10] .eh_frame         PROGBITS        00000000 0000c0 000050 00   A  0   0  4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [11] .rel.eh_frame     REL             00000000 000274 000010 08   I 12  10  4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [12] .symtab           SYMTAB          00000000 000110 0000f0 10     13  11  4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [13] .strtab           STRTAB          00000000 000200 000042 00      0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [14] .shstrtab         STRTAB          00000000 000284 000082 00      0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Key to Flags:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    L (link order), O (extra OS processing required), G (group), T (TLS),</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    C (compressed), x (unknown), o (OS specific), E (exclude),</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    p (processor specific)</span></span><br></pre></td></tr></table></figure><p> readelf输出的结果就是ELF的文件段表的内容。段表的是一个“Elf32_Shdr”结构为元素的数组。“Elf_Shdr”又被称为段描述符。“Elf32_Shdr”结构被定义在“/usr/include/elf.h”，结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word sh_name;</span><br><span class="line">    Elf32_Word sh_type;</span><br><span class="line">    Elf32_Word sh_flags;</span><br><span class="line">    Elf32_Addr sh_addr;</span><br><span class="line">    Elf32_off  sh_offset;</span><br><span class="line">    Elf32_Word sh_size;</span><br><span class="line">    Elf32_Word sh_link;</span><br><span class="line">    Elf32_Word sh_info;</span><br><span class="line">    Elf32 Word sh_addralign;</span><br><span class="line">    Elf32_Word sh_entsize;</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p>Elf32_Shdr的各个成员含义如下：</p><div class="table-container"><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>sh_name</td><td>段名是个字符串，它位于一个叫做“.shstrtab”的字符串表。sh_name是段名字符串在“.shstrtab”中的偏移</td></tr><tr><td>sh_type</td><td>类型</td></tr><tr><td>sh_flags</td><td>段标志</td></tr><tr><td>sh_addr</td><td>如果该段可以被加载，则sh_addr为该段被加载后在进程地址空间中的虚拟地址，否则该值为0</td></tr><tr><td>sh_offset</td><td>如果该段存在于文件中，则表示该段在文件中的偏移；否则无意义。比如sh_offset对于BSS段来说就没有意义</td></tr><tr><td>sh_size</td><td>段的长度</td></tr><tr><td>sh_link / sh_info</td><td>段的链接信息</td></tr><tr><td>sh_addralign（段地址对齐）</td><td>有些段对段地址对齐有要求，比如我们假设有个段刚开始的位置包含了一个double变量，因为x86系统要求浮点数的存储地址必须是本身的整数倍，也就是说保存 double变量的地址必须是8字节的整数倍。这样对一个段来说，它的 sh_addr必须是8的整数倍<br/><br/>由于地址对齐的数量都是2的指数倍，sh_addralign表示是地址对齐数量中的指数，即 sh_addrlign=3表示对齐为2的3次方倍，即8倍,依此类推所以一个段的地址 sh_addr必须满足下面的条件，$sh_addr\% \left( 2^{sh_addrlign}\right) =0 $ <br/><br/>如果 sh_addralign为0或1，则表示该段没有对齐要求</td></tr><tr><td>sh_entsize（项的长度）</td><td>有些段包含了一些固定大小的项，比如符号表，它包含的每个符号所占的大小都是一样的。对于这种段，sh_entsize表示每个项的大小。如果为0，则表示该段不包含固定大小的项</td></tr></tbody></table></div><h5 id="段的类型（sh-type）"><a href="#段的类型（sh-type）" class="headerlink" title="段的类型（sh_type）"></a>段的类型（sh_type）</h5><p>段的名字只是在链接和编译过程中有意义，但它不能真正地表示段的类型。我们也可以将一个数据段命名为“text”，对于编译器和链接器来说，主要决定段的属性的是段的类型(sh_type)和段的标志位(sh_flags)。该字段的取值如下：</p><div class="table-container"><table><thead><tr><th>常量</th><th style="text-align:center">值</th><th>含义</th></tr></thead><tbody><tr><td>SHT_NULL</td><td style="text-align:center">0</td><td>无效段</td></tr><tr><td>SHT_PROGBITS</td><td style="text-align:center">1</td><td>代码段、数据段都是该类型</td></tr><tr><td>SHT_SYMTAB</td><td style="text-align:center">2</td><td>符号表</td></tr><tr><td>SHT_STRTAB</td><td style="text-align:center">3</td><td>字符串表</td></tr><tr><td>SHT_RELA</td><td style="text-align:center">4</td><td>重定位表</td></tr><tr><td>SHT_HASH</td><td style="text-align:center">5</td><td>符号表的哈希表</td></tr><tr><td>SHT_DYNAMIC</td><td style="text-align:center">6</td><td>动态链接信息</td></tr><tr><td>SHT_NOTE</td><td style="text-align:center">7</td><td>提示性信息</td></tr><tr><td>SHT_NOBITS</td><td style="text-align:center">8</td><td>表示该段在文件中没有内容</td></tr><tr><td>SHT_REL</td><td style="text-align:center">9</td><td>该段包含了重定位信息，用与静态链接</td></tr><tr><td>SHT_SHLIB</td><td style="text-align:center">10</td><td>保留</td></tr><tr><td>SHT_DNYSYM</td><td style="text-align:center">11</td><td>动态链接的符号表</td></tr></tbody></table></div><h5 id="段的标志位（sh-flag）"><a href="#段的标志位（sh-flag）" class="headerlink" title="段的标志位（sh_flag）"></a>段的标志位（sh_flag）</h5><p>段的标志位表示该段在进程虚拟地址在地址空间中的属性，比如是否可写，是否可执行等。该字段的取值如下：</p><div class="table-container"><table><thead><tr><th>常量</th><th style="text-align:center">值</th><th>含义</th></tr></thead><tbody><tr><td>SHF_WRITE</td><td style="text-align:center">1</td><td>表示该段在进程空间中可写</td></tr><tr><td>SHF_ALLOC</td><td style="text-align:center">2</td><td>表示该段在进程空间中须要分配空间。有些包含指示或控制信息的段不须要在进程空间中被分配空间，它们一般不会有这个标志。像代码段、数据段和bss段都会有这个标志位</td></tr><tr><td>SHF_EXECINSTR</td><td style="text-align:center">4</td><td>表示该段在进程空间中可执行，一般代码段是这个属性</td></tr></tbody></table></div><p>常见的段的标志位如下：</p><div class="table-container"><table><thead><tr><th>段名</th><th style="text-align:left">sh_type</th><th style="text-align:center">sh_flag</th></tr></thead><tbody><tr><td>.bss</td><td style="text-align:left">SHT_NOBITS</td><td style="text-align:center">SHF_ALLOC + SHF_WRITE</td></tr><tr><td>.comment</td><td style="text-align:left">SHT_PROGBITS</td><td style="text-align:center">none</td></tr><tr><td>.data</td><td style="text-align:left">SHT_PROGBITS</td><td style="text-align:center">SHF_ALLOC + SHF_WRITE</td></tr><tr><td>.debug</td><td style="text-align:left">SHT_PROGBITS</td><td style="text-align:center">none</td></tr><tr><td>.dynamic</td><td style="text-align:left">SHT_DYNAMIC</td><td style="text-align:center">SHF_ALLOC + SHF_WRITE<br/>有些系统里.dynamic是只读的只有SHF_ALLOC</td></tr><tr><td>.hash</td><td style="text-align:left">SHT_HASH</td><td style="text-align:center">SHF_ALLOC</td></tr><tr><td>.line</td><td style="text-align:left">SHT_PROGBITS</td><td style="text-align:center">none</td></tr><tr><td>.note</td><td style="text-align:left">SHT_NOTE</td><td style="text-align:center">none</td></tr><tr><td>.rodata</td><td style="text-align:left">SHT_PROGBITS</td><td style="text-align:center">SHF_ALLOC</td></tr><tr><td>.shstrtab</td><td style="text-align:left">SHT_STRTAB</td><td style="text-align:center">none</td></tr><tr><td>.strtab</td><td style="text-align:left">SHT_PROGBITS</td><td style="text-align:center">如果ELF文件中有可装载的段须要用到该字符串表，那么该字符串表也将被装载到进程空间，则有SHF_ALLOC标志位</td></tr><tr><td>.symtab</td><td style="text-align:left">SHT_STRTAB</td><td style="text-align:center">同字符串表</td></tr><tr><td>.text</td><td style="text-align:left">SHT_PROGBITS</td><td style="text-align:center">SHF_ALLOC + SHF_EXECINSTR</td></tr></tbody></table></div><h5 id="段的链接信息（sh-link、sh-info）"><a href="#段的链接信息（sh-link、sh-info）" class="headerlink" title="段的链接信息（sh_link、sh_info）"></a>段的链接信息（sh_link、sh_info）</h5><p>如果段是和链接相关的，如重定位表、符号表等，那么这些段的含义如下：</p><div class="table-container"><table><thead><tr><th>sh_type</th><th style="text-align:left">sh_link</th><th style="text-align:center">sh_info</th></tr></thead><tbody><tr><td>SHT_DYNAMIC</td><td style="text-align:left">该段所使用的字符串表在段表中的下标</td><td style="text-align:center">0</td></tr><tr><td>SHT_HASH</td><td style="text-align:left">该段所使用的符号表在段表中的下标</td><td style="text-align:center">0</td></tr><tr><td>SHT_REL</td><td style="text-align:left">该段所使用的相应符号表在段表中的下标</td><td style="text-align:center">该重定位表所作用的段在段表中的下标</td></tr><tr><td>SHT_RELA</td><td style="text-align:left">该段所使用的相应符号表在段表中的下标</td><td style="text-align:center">该重定位表所作用的段在段表中的下标</td></tr><tr><td>SHT_SYMTAB</td><td style="text-align:left">操作系统相关</td><td style="text-align:center">操作系统相关</td></tr><tr><td>SHT_DYNSYM</td><td style="text-align:left">操作系统相关</td><td style="text-align:center">操作系统相关</td></tr><tr><td>other</td><td style="text-align:left">SHN_UNDEF</td><td style="text-align:center">0</td></tr></tbody></table></div><h4 id="3-4-3-重定位表"><a href="#3-4-3-重定位表" class="headerlink" title="3.4.3 重定位表"></a>3.4.3 重定位表</h4><p>链接器在处理目标文件时，须要对目标文件的代码段和数据段中那些对绝对地址的引用的位置进行重定位。这些重定位的信息都记录在ELF文件的重定位表里面，对于每个须要重定位的代码段或数据段，都会有一个相应的重定位表。比如之前的示例中，”rel.text“就是针对“text”段的重定位表。而”data“段则没有对绝对地址的引用，所以没有针对”data“段的重定位表”rel. data“。</p><h4 id="3-4-4-字符串表"><a href="#3-4-4-字符串表" class="headerlink" title="3.4.4 字符串表"></a>3.4.4 字符串表</h4><p>ELF文件中用到了很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。这样就诞生了字符串表这个结构。</p><p>最常见的字符串表就是”.strtab“和”.shstrtab“。这两个字符串表分别为字符串表（String Table）和段表字符串表（Section Header String Table）。字符串表用来保存普通的字符串，如符号的名字；段表字符串表用来保存段表中用到的字符串，如段名。</p><h3 id="3-5-链接的接口——符号"><a href="#3-5-链接的接口——符号" class="headerlink" title="3.5 链接的接口——符号"></a>3.5 链接的接口——符号</h3><p>在开发中，每个模块都会使用其他模块的功能，或者提供功能给其他模块引用，上述方法能成功工作是因为模块的函数或者变量都有自己独特的名字，避免了引用时发生混淆。在链接中这些函数和变量统称为符号，它们的名字就是符号名。</p><p>整个链接过程就是基于符号才能够正确完成。所以链接中很关键的一环就是符号管理，每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录了目标文件中所用到的所有符号。每个定义的符号有个对应的值，叫做符号值( Symbol Value)，对于变量和函数来说，符号值就是它们的地址。除了函数和变量之外，还存在其他几种不常用到的符号。我们将符号表中所有的符号进行分类，它们有可能是下面这些类型中的一种：</p><ul><li>定义在本目标文件的全局符号。可以被其他目标文件引用</li><li>在本目标文件中引用却在其他文件中定义的全局符号。这一般叫外部符号</li><li>局部符号。如本地的局部变量，这类符号仅仅在编译单元内部可见，因为链接器仅仅关注模块间的关系，所以这些符号其实对链接器来说没有什么作用。不过调试器可以使用这些符号来分析程序或崩溃时的核心转储文件</li><li>段名 、行号。这些符号用来提供一些辅助功能</li></ul><p>对于链接器来说，最重要的还是前面两种符号。</p><h4 id="3-5-1-ELF-符号表结构"><a href="#3-5-1-ELF-符号表结构" class="headerlink" title="3.5.1 ELF 符号表结构"></a>3.5.1 ELF 符号表结构</h4><p>ELF文件的符号表往往是文件的”symtab“段。它的结构很简单，是一个Elf32_Sym结构（32位ELF文件）的数组，每个Elf32_Sym结构对应一个符号。这个数组的第一个元素，也就是下标0的元素为无效的”未定义“符号。Elf32_Sym的结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word st_name;</span><br><span class="line">    Elf32_Addr st_value;</span><br><span class="line">    Elf32_Word st_size;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; </span><br><span class="line">    Elf32_Half    st_shndx;</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p>Elf32_Sym的各个成员含义如下：</p><div class="table-container"><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>st_name</td><td>符号名，这个字段的值是该符号在字符串表中的下标</td></tr><tr><td>st_value</td><td>符号相对应的值。这个值跟符号有关，可能是一个绝对值，也可能是一个地址等，不同的符号，它所对应的值含义不同</td></tr><tr><td>st_size</td><td>符号大小。对于包含数据的符号，这个值是该数据类型的大小。如 double 类型的符号就是 8 个字节</td></tr><tr><td>st_info</td><td>符号类型和绑定信息</td></tr><tr><td>st_other</td><td>目前未用</td></tr><tr><td>st_shndx</td><td>符号所在的段</td></tr></tbody></table></div><h5 id="符号值（st-value）"><a href="#符号值（st-value）" class="headerlink" title="符号值（st_value）"></a>符号值（st_value）</h5><p>每个符号都有一个对应的值，如果符号是一个函数或者变量的定义，那么符号的值就是这个函数或者变量的地址，更准确地说应该分成下面几种情况区别对待：</p><ul><li>在目标文件中，如果符号不是”COMMON“类型的。st_value表示该符号在段中的偏移。即符号所对应的函数或者变量位于 st_shndx 指定的段，偏移 st_value 的位置。这也是目标文件中定义全局变量的符号最常见的情况</li><li>如果符号是”COMMON“类型的。st_value表示该符号的对齐属性</li><li>在可执行文件中，st_value表示符号的虚拟地址</li></ul><h5 id="符号类型和绑定信息（st-info）"><a href="#符号类型和绑定信息（st-info）" class="headerlink" title="符号类型和绑定信息（st_info）"></a>符号类型和绑定信息（st_info）</h5><p>该字段低 4 位表示符号的类型：</p><div class="table-container"><table><thead><tr><th>宏定义名</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>STB_LOCAL</td><td>0</td><td>局部符号，对目标文件外的编译单位不可见</td></tr><tr><td>STB_GLOBAL</td><td>1</td><td>全局符号，对外部可见</td></tr><tr><td>STB_WEAK</td><td>2</td><td>弱符号</td></tr></tbody></table></div><p>高 28 位表示符号的绑定信息：</p><div class="table-container"><table><thead><tr><th>宏定义名</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>STB_NOTYPE</td><td>0</td><td>位置类型符号</td></tr><tr><td>STB_OBJECT</td><td>1</td><td>数据对象，如变量、数组</td></tr><tr><td>STB_FUNC</td><td>2</td><td>函数或者可执行代码</td></tr><tr><td>STB_SECTION</td><td>3</td><td>该符号是一个段</td></tr><tr><td>STB_FILE</td><td>4</td><td>一般是该目标文件所对应的源文件名</td></tr></tbody></table></div><h5 id="符号所在段（st-shndx）"><a href="#符号所在段（st-shndx）" class="headerlink" title="符号所在段（st_shndx）"></a>符号所在段（st_shndx）</h5><p>如果符号定义在本目标文件中，那这个成员表示符号所在的段在段表中的下标；如果不在本目标文件中，或者一些特殊符号 st_shndx 的值有些特殊：</p><div class="table-container"><table><thead><tr><th>宏定义名</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>SHN_ABS</td><td>0xFFF1</td><td>表示该符号包含一个绝对值。如文件名的符号就是此类型</td></tr><tr><td>SHN_COMMON</td><td>0xFFF2</td><td>表示该符号是一个”COMMON“块类型的符号。一般来说未初始化的全局符号定义就是该类型</td></tr><tr><td>SHN_UNDEF</td><td>0</td><td>表示该符号未定义。这个符号表示该符号在本目标文件被引用，但是定义在其他目标文件中</td></tr></tbody></table></div><h4 id="3-5-2-特殊符号"><a href="#3-5-2-特殊符号" class="headerlink" title="3.5.2 特殊符号"></a>3.5.2 特殊符号</h4><p>  在用 ld作为链接器来链接产生可执行文件时，它会生成一些特殊的符号，这些符号并没有在源代码中定义，但是可以直接引用。一些典型的特殊符号如下：</p><ul><li><code>__FILE__</code> 编译单元对应的文件名</li><li><p><code>__FUNCTION__</code> 符号所的函数</p></li><li><p><code>__executable_start</code> 程序起始地址</p></li><li><code>_end</code> 程序结束地址</li></ul><h4 id="3-5-3-符号修饰与函数签名"><a href="#3-5-3-符号修饰与函数签名" class="headerlink" title="3.5.3 符号修饰与函数签名"></a>3.5.3 符号修饰与函数签名</h4><p>在 C 语言之前已具备很多用汇编实现的程序库，这些库的符号名和对应的函数/变量名是一样的。为了避免名字冲突，Unix C 的编译器规定，C 语言源代码文件中的所有全局的变量和函数经过编译以后，相对应的符号名前加上下划线”_“，这个办法在当时解决了大部分的符号名冲突的问题。</p><p>到后来 C++在设计时就考虑到了这一点，引入了命名空间特性，才彻底解决符号名冲突的问题。一组用来确定函数唯一性的关键信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息称之为函数签名( Function Signature)。函数签名用于识别不同的函数，C++使用特定的名称修饰方法，使得每个函数签名对应唯一一个修饰后的名称。</p><p>生成函数签名以及根据函数签名生成对应的名称的方法可能每个编译器的实现都不一样，导致不同厂家的编译器产生的库不能相互链接，这也是 C++二进制难以兼容的原因之一。</p><h4 id="3-5-4-extern-“C”"><a href="#3-5-4-extern-“C”" class="headerlink" title="3.5.4 extern “C”"></a>3.5.4 extern “C”</h4><p>有时C++要和 C 兼容，C++有一个用来声明或定义一个 C 的符号的<code>extern &quot;C&quot;</code>关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"c"</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> var;    <span class="comment">//多行形式</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"c"</span> <span class="keyword">int</span> var;  <span class="comment">//单行形式</span></span><br></pre></td></tr></table></figure><p>C++编译器会将在<code>extern &quot;C&quot;</code>的大括号内部的代码当做 C 语言代码来处理，此时 C++的名称修饰机制就不会起作用。</p><h4 id="3-5-5-弱符号与强符号"><a href="#3-5-5-弱符号与强符号" class="headerlink" title="3.5.5 弱符号与强符号"></a>3.5.5 弱符号与强符号</h4><p>强弱符号是用来处理同一个符号在不同模块被重复定义的而出现的。对于 C / C++ 编译器来说，函数和以及初始化的全局变量是强符号，未初始化的全局变量是弱符号。不过强弱符号也可以用特定的修饰关键字单独指定。链接器会按照下列规则处理与选择被多次定义的全局符号：</p><ul><li>规则1：不允许强符号被多次定义；如果有多次重复定义，则链接器会报错</li><li>规则2：如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号</li><li>规则3：如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的个。比如目标文件A定义全局变量global为int型，占4个字节；目标文件B定义global为double型，占8个字节，那么目标文件A和B链接后，符号global占8个字节(尽量不要使用多个不同类型的弱符号，否则容易导致很难发现的程序错误)</li></ul><h5 id="强引用和弱引用"><a href="#强引用和弱引用" class="headerlink" title="强引用和弱引用"></a>强引用和弱引用</h5><p>目前我们所看到的对外部目标文件的符号引用在目标文件被最终链接成可执行文件时，它们须要被正确决议，如果没有找到该符号的定义，链接器就会报符号未定义错误，这种被称为强引用。</p><p>与之相对应还有一种弱引用，在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器对于该引用不报错。链接器处理强引用和弱引用的过程几乎一样，只是对于未定义的弱引用，链接器不认为它是一个错误。一般对于未定义的弱引用，链接器默认其为0，或者是一个特殊的值，以便于程序代码能够识别。</p><p>这种弱符号和弱引用对于库来说十分有用，比如库中定义的弱符号可以被用户定义的强符号所覆盖，从而使得程序可以使用自定义版本的库函数；或者程序可以对某些扩展功能模块的引用定义为弱引用，当我们将扩展模块与程序链接在一起时，功能模块就可以正常使用；如果我们去掉了某些功能模块，那么程序也可以正常链接，只是缺少了相应的功能，这使得程序的功能更加容易裁剪和组合。</p><h4 id="3-5-6-调试信息"><a href="#3-5-6-调试信息" class="headerlink" title="3.5.6 调试信息"></a>3.5.6 调试信息</h4><p>目标文件里面还有可能保存的是调试信息。几乎所有现代的编译器都支持源代码级别的调试，比如我们可以在函数里面设置断点，可以监视变量变化，可以单步行进等，前提是编译器必须提前将源代码与目标代码之间的关系保存下来，比如目标代码中的地址对应源代码中的哪行、函数和变量的类型、结构体的定义、字符串保存到目标文件里面。</p><p>现在的ELF文件采用一个叫DWARF（Debug With Arbitrary Record Format）的标准的调试信息格式来保存调试信息。值得注意的是，调试信息在目标文件中一般占据很大的空间，有时候甚至比代码和数据本身大好几倍，所以当代码完成开发时，往往要用 release 模式编译，把调试信息去掉。</p><h2 id="4-静态链接"><a href="#4-静态链接" class="headerlink" title="4 静态链接"></a>4 静态链接</h2><h3 id="4-1-空间与地址分配"><a href="#4-1-空间与地址分配" class="headerlink" title="4.1 空间与地址分配"></a>4.1 空间与地址分配</h3><p>如两个静态文件 A 和 B 链接成 AB，链接器会采取”合并同类项“的方式把两个文件相同的段合并起来，如 A 的代码段和 B 的代码段合在一起，形成一个新的代码段。最后文件 AB 的大小是根据 A 和 B 的所有段的大小来确定的。</p><p>合并的过程一般是两步：</p><ol><li>扫描全部输入文件，获得它们各个段的长度，并把所有符号以及符号引用收集起来，形成全局符号表</li><li>用第 1 步获得到的信息，进行符号解析和重定位，调整文件中的各种引用地址</li></ol><h3 id="4-2-符号解析与重定位"><a href="#4-2-符号解析与重定位" class="headerlink" title="4.2 符号解析与重定位"></a>4.2 符号解析与重定位</h3><h4 id="4-2-1-重定位"><a href="#4-2-1-重定位" class="headerlink" title="4.2.1 重定位"></a>4.2.1 重定位</h4><p>符号在段内的位置是相对不变的，而且这个相对位置在编译时已经确定，所以只要段的起始地址确定，符号地址也随之确定。所以在多个段合并后，每个段的起始地址也确定下来，此时段内的符号地址能具体地计算出来。</p><p>完成空间和地址的分配后，链接器就进入了符号解析和重定位的步骤，这也是静态链接的核心内容。</p><h4 id="4-2-2-重定位表"><a href="#4-2-2-重定位表" class="headerlink" title="4.2.2 重定位表"></a>4.2.2 重定位表</h4><p>重定位的工作中最重要的一项数据结构就是重定位表，它用来保存如何修改相应的段里的内容的信息。每个要被重定位的地方叫一个重定位入口（Relocation Entry），重定位入口的偏移（Offset）表示该入口在要被重定位的段中的位置。</p><p>对于 32 位的 x86 系列处理器来说，重定位表的结构是一个 Elf32_Rel 结构的数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  Elf32_Addr r_offset;</span><br><span class="line">  Elf32_Word r_info;</span><br><span class="line">&#125; Elf32_Rel</span><br></pre></td></tr></table></figure><p>具体的字段解释如下：</p><div class="table-container"><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>r_offset</td><td>对于可重定位文件来说，这个值是该重定位入口所要修正的位置的第一个字节相对于段起始的偏移；<br/>对于可执行文件或共享对象文件来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址</td></tr><tr><td>r_info</td><td>这个成员的低8位表示重定位入口的类型，高24位表示重定位入口的符号在符号表中的下标。对于可执行文件和共享目标文件来说，它们的重定位入口是动态链接类型的</td></tr></tbody></table></div><h4 id="4-2-3-符号解析"><a href="#4-2-3-符号解析" class="headerlink" title="4.2.3 符号解析"></a>4.2.3 符号解析</h4><p>平时在编写程序的时候常遇到的问题就是，链接时符号未定义。导致这个问题的原因很多，最常见的一般都是链接时缺少了某个库，或者输入目标文件路径不正确或符号的声明与定义不一样。</p><p>通过前面指令重定位的介绍，现在可以更加深层次地理解为什么缺少符号的定义会导致链接错误。其实重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。重定位的过程中，每个重定位的入口都是对一个符号的引用，那么当链接器须要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。</p><p>在链接器扫描完所有的输入目标文件之后，理论上所有这些未定义的符号都应该能够在全局符号表中找到，否则链接器就报符号未定义错误。</p><h4 id="4-2-4-指令修正方式"><a href="#4-2-4-指令修正方式" class="headerlink" title="4.2.4 指令修正方式"></a>4.2.4 指令修正方式</h4><p>32 位的 x86 处理器支持的寻址方式特别多，很多是从 16 位开始一直兼容上来的。到现在已经用的不多，现在主要的还是以下两种：</p><ul><li>绝对近址32位寻址</li><li>相对近址32位寻址</li></ul><p>前面说到的 r_info 字段的 低 8 位表示重定位入口类型，具体如下：</p><div class="table-container"><table><thead><tr><th>宏定义</th><th>值</th><th>重定位修正方法</th></tr></thead><tbody><tr><td>R_386_32</td><td>1</td><td>绝对寻址修正 S + A</td></tr><tr><td>R_386_PC32</td><td>2</td><td>相对寻址修正 S + A - P</td></tr></tbody></table></div><p>A = 保存在被修正位置的值，这个位置由r_offset字段查询得到</p><p>S = 符号的实际地址，由 r_info 的高 24 位指定的符号的实际地址</p><p>P = 被修正的位置的第一个字节的虚拟地址</p><h5 id="绝对寻址修正"><a href="#绝对寻址修正" class="headerlink" title="绝对寻址修正"></a>绝对寻址修正</h5><p>一般进行绝对寻址修正时，就是直接把符号的地址赋值到引用该符号的地方。所以一般引用处的 A 值都是 0</p><h5 id="相对寻址修正"><a href="#相对寻址修正" class="headerlink" title="相对寻址修正"></a>相对寻址修正</h5><p>相对寻址需要计算符号引用的地方和符号相距的距离，所以上述的公式可以先简化成 S - P，这里 S 就是符号地址，P 就是引用符号的地址。</p><p>x86 执行相对近调用指令时，后面参数的偏移量的计算公式是：目的地地址 - 源地址 - call指令长度。是不是看着很熟悉。和上面的 S - P 公式有点像了，这里就知道为什么要加上 A了。A 的值就是call 指令的长度，由编译器在编译时计算得出，在32位x86的CPU上A的值一般为-4</p><h3 id="4-4-C-相关问题"><a href="#4-4-C-相关问题" class="headerlink" title="4.4 C++相关问题"></a>4.4 C++相关问题</h3><ul><li>C++的模板、虚函数表、外部内联函数可能在各种实例中出现，会形成大量冗余代码。所以C++的编译器把每个模板的代码放在一个单独的段里，重复的模板只会产生一个段，通过这样的方法来去除冗余</li><li>全局构造与析构代码放在.init和.finit 段，确保能在main之前前执行构造方法，在main之后执行析构方法</li><li>C++的模板、多继承、命名空间等诸多特性导致符号的生成规则因素过多，ABI的兼容性难度很大</li></ul><h3 id="4-6-链接过程控制"><a href="#4-6-链接过程控制" class="headerlink" title="4.6 链接过程控制"></a>4.6 链接过程控制</h3><ul><li>用命令行参数</li><li>把链接指令放在目标文件里面</li><li>用链接脚本控制链接过程</li></ul><h3 id="4-7-BFD-库"><a href="#4-7-BFD-库" class="headerlink" title="4.7 BFD 库"></a>4.7 BFD 库</h3><p>不同平台的目标文件格式千差万别，导致编译器和链接器很难处理不同平台的目标文件，特别是还具有跨平台特性的编译器来说，更是头疼。</p><p>所以业界出现了BFD（Binary File Descriptor library）项目，它能把目标文件抽象成一个统一的模型。</p>]]></content>
    
    <summary type="html">
    
      《程序员的自我修养》的读书笔记
    
    </summary>
    
      <category term="CS基础" scheme="http://petpwiuta.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>pod install 特别慢的终极解决方案😋</title>
    <link href="http://petpwiuta.github.io/2019/04/03/pod%20install%20%E7%89%B9%E5%88%AB%E6%85%A2%E7%9A%84%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://petpwiuta.github.io/2019/04/03/pod install 特别慢的终极解决方案/</id>
    <published>2019-04-03T02:59:43.000Z</published>
    <updated>2019-04-03T02:59:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pod-install-特别慢的终极解决方案😋"><a href="#pod-install-特别慢的终极解决方案😋" class="headerlink" title="pod install 特别慢的终极解决方案😋"></a>pod install 特别慢的终极解决方案😋</h2><p><strong>pod install 在终端更新慢</strong> 其实真正慢的并不在 <strong>pod</strong> 命令，而是在于 <strong>github</strong>访问速度慢，那么真正的解决方案就是要加快 <strong>git</strong>命令的速度。当然，加速<strong>git</strong>的方法就是开代理。</p><p>我使用的 <strong>shadowsocks代理</strong>，默认代理端口为<strong>1080</strong>，打开小飞机，配置好代理之后，去终端输入<strong>git</strong>配置命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1086</span><br><span class="line"><span class="meta">#</span><span class="bash"> socks5://127.0.0.1:1086 1086端口号是shadowsocks的默认设置，实际以自己的机器为准</span></span><br></pre></td></tr></table></figure><p>如此就从根本上解决了问题。<strong>代理前 10k/s ☹️ 代理后 600k/s</strong> 😍</p><p>如果要恢复/移除上面设置的 <strong>git</strong>代理，使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.https://github.com.proxy</span><br></pre></td></tr></table></figure><h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><ul><li><a href="https://blog.csdn.net/wuquan0625/article/details/47401235" target="_blank" rel="noopener">https://blog.csdn.net/wuquan0625/article/details/47401235</a></li></ul>]]></content>
    
    <summary type="html">
    
      用git内置的proxy提高github访问速度
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>UIStackView</title>
    <link href="http://petpwiuta.github.io/2019/04/01/UIStackView/"/>
    <id>http://petpwiuta.github.io/2019/04/01/UIStackView/</id>
    <published>2019-04-01T02:46:11.000Z</published>
    <updated>2019-04-01T02:46:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h1><p>UIStackview是一个流式布局的工具。贼好用😝😝</p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>UIStackView可以说是Auto Layout最强有力的助手，通过它能大幅简化多个view规律性的布局逻辑。stack view所管理的view都在它的 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616232-arrangedsubviews" target="_blank" rel="noopener"><code>arrangedSubviews</code></a> 属性里。stack view会把这些view根据其在数组中的先后顺序沿着横向/纵向（取决于<a href="https://developer.apple.com/documentation/uikit/uistackview/1616223-axis" target="_blank" rel="noopener"><code>axis</code></a>属性）排列，然当具体的排列效果还和 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616233-distribution" target="_blank" rel="noopener"><code>distribution</code></a>, <a href="https://developer.apple.com/documentation/uikit/uistackview/1616243-alignment" target="_blank" rel="noopener"><code>alignment</code></a>, <a href="https://developer.apple.com/documentation/uikit/uistackview/1616225-spacing" target="_blank" rel="noopener"><code>spacing</code></a>, 等属性有关。</p><p><img src="/images/stackview.png" style="zoom:40%" /></p><p>在Storyboard中使用stack view很简单，打开控件库，选择Horizontal Stack View 或 Vertical Stack View拖到view上，再拖一些其他控件到stack view里面就行了。如果约束足够明确的话Interface Builder会根据你的内容自动调整stack view的大小。另外还有一个快速使用stack view的小技巧，就是选中一组控件以后点击Interface Builder右下角的 <strong>Embed In</strong> <img src="/images/embedin.png" style="zoom:20%" /> 按钮选择stack view就能快速用stack view把选中的控件wrap起来。</p><h3 id="Stack-View-和-Auto-Layout"><a href="#Stack-View-和-Auto-Layout" class="headerlink" title="Stack View 和 Auto Layout"></a>Stack View 和 Auto Layout</h3><p>stack view通过自动布局来确定所管理的view的大小和位置。<code>axis</code>决定了stack view是水平排列还是垂直排列。如果设置 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616220-islayoutmarginsrelativearrangeme" target="_blank" rel="noopener"><code>isLayoutMarginsRelativeArrangement</code></a> 属性为 <code>true</code> ，stack view会基于margin来决定view之间位置（不设置的话就是基于视图的边缘来计算）。</p><p><code>distribution</code>属性用来设置沿着axis方向的各个view的排列方式。当axis是<code>UILayoutConstraintAxisHorizontal</code>就是设置水平方向各个view的排列关系，当axis是<code>UILayoutConstraintAxisVertical</code>就是设置垂直方向各个view的排列关系。</p><p>stack view对子view进行排列时，会依次调用view的<a href="https://developer.apple.com/documentation/uikit/uiview/1622600-intrinsiccontentsize" target="_blank" rel="noopener"><code>intrinsicContentSize</code></a>属性来确定其大小。有一个例外，就是distribution设置成<a href="https://developer.apple.com/documentation/uikit/uistackview/distribution/fillequally" target="_blank" rel="noopener"><code>UIStackView.Distribution.fillEqually</code></a>时，此时stack view会尽量把所有的view拉伸成同样的长度，均匀地填充整个容器。stack view在拉伸时会尝试把其他的view拉得和最长的那个一样长。</p><p><code>alignment</code>属性用来设置垂直于axis方向的各个view的对齐方式。当axis是<code>UILayoutConstraintAxisHorizontal</code>就是设置垂直方向各个view的对齐关系，当axis是<code>UILayoutConstraintAxisVertical</code>就是设置水平方向各个view的对齐关系。</p><p>stack view对子view进行对齐时，也会依次调用view的<a href="https://developer.apple.com/documentation/uikit/uiview/1622600-intrinsiccontentsize" target="_blank" rel="noopener"><code>intrinsicContentSize</code></a>属性来确定其大小。当然也有一个例外，就是alignment设置为<a href="https://developer.apple.com/documentation/uikit/uistackview/alignment/fill" target="_blank" rel="noopener"><code>UIStackView.Alignment.fill</code></a> 时，此时stack view会尽量把所有的view拉伸成同样的高度，均匀地填充整个容器。stack view在拉伸时会尝试把其他的view拉得和最高的那个一样高。</p><h3 id="Stack-View的位置和大小"><a href="#Stack-View的位置和大小" class="headerlink" title="Stack View的位置和大小"></a>Stack View的位置和大小</h3><p>stack view可以根据所管理的view推导出自己的大小，但是它无法确定自己的位置。所需要明确地写出位置约束。只要指定两个的相邻边的位置stack view就能确定其自身的位置。与此同时stack view也会根据内容来自动调整自己的宽度和高度：</p><ul><li>沿着axis方向的宽度等于其管理的所有view的尺寸加上view之间的间距</li><li>垂直于axis方向的高度等于所管理的view中最高的那个</li><li>如果stack view的 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616220-islayoutmarginsrelativearrangeme" target="_blank" rel="noopener"><code>isLayoutMarginsRelativeArrangement</code></a> 属性设置为 <code>true</code>, stack view的尺寸会包含margins的大小</li></ul><p>当然，上面的这些都是默认的行为，如果不能满足要求还能直接给stack view加高度或宽度的约束。stack view会根据 <a href="https://developer.apple.com/documentation/uikit/uistackview/distribution" target="_blank" rel="noopener"><code>UIStackView.Distribution</code></a> 和 <a href="https://developer.apple.com/documentation/uikit/uistackview/alignment" target="_blank" rel="noopener"><code>UIStackView.Alignment</code></a> 等设置来调整子view的排列和对齐来满足约束条件。 </p><p>虽然stack view仅仅只是一个布局容器，但是它也支持基于first/last baseline的布局：</p><ul><li>horizontal方向的stack view <a href="https://developer.apple.com/documentation/uikit/uiview/1622452-forfirstbaselinelayout" target="_blank" rel="noopener"><code>forFirstBaselineLayout</code></a>和 <a href="https://developer.apple.com/documentation/uikit/uiview/1622633-forlastbaselinelayout" target="_blank" rel="noopener"><code>forLastBaselineLayout</code></a> 会返回所管理的view中最高的那个对应的属性。 如果最高的那个也是stack view的话会进行递归调用，直到返回正常结果</li><li>vertical方向的stack view <code>forFirstBaselineLayout</code>会返回所管理的第一个子view，<code>forLastBaselineLayout</code>会返回最后一个。同样的如果第一个/最后一个还是stack view的话也会递归式调用</li></ul><blockquote><p>注意</p><p>Baseline alignment 仅仅只能在view的frame高度等于自己的intrinsic.height时才能正常工作，换句话说就是view如果被压缩或拉伸的话baseline alignment可能就会有bug</p></blockquote><h3 id="Stack-View的常用属性"><a href="#Stack-View的常用属性" class="headerlink" title="Stack View的常用属性"></a>Stack View的常用属性</h3><p>stack view虽然是view的子类，它只负责管理其排列视图的位置和大小，本身不会被渲染出来。所以一些外观相关的属性（如<a href="https://developer.apple.com/documentation/uikit/uiview/1622591-backgroundcolor" target="_blank" rel="noopener"><code>backgroundColor</code></a>）对它没有效果，也不能重载 <a href="https://developer.apple.com/documentation/uikit/uiview/1622626-layerclass" target="_blank" rel="noopener"><code>layerClass</code></a>, <a href="https://developer.apple.com/documentation/uikit/uiview/1622529-draw" target="_blank" rel="noopener"><code>draw(_:)</code></a>等方法。</p><ul><li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616223-axis" target="_blank" rel="noopener"><code>axis</code></a> 确定了stack的方向，选项是vertically/horizontally.</li><li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616233-distribution" target="_blank" rel="noopener"><code>distribution</code></a> 用来设置沿着axis方向的各个view的排列方式</li><li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616243-alignment" target="_blank" rel="noopener"><code>alignment</code></a> 用来设置垂直与axis方向的各个view的对齐方式</li><li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616225-spacing" target="_blank" rel="noopener"><code>spacing</code></a> view之间的最小间距</li><li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616224-isbaselinerelativearrangement" target="_blank" rel="noopener"><code>isBaselineRelativeArrangement</code></a> 当axis设置为垂直方向时才有用。垂直方向的view是否用基于baseline排列，这个属性在排列一些文本控件时很管用</li><li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616220-islayoutmarginsrelativearrangeme" target="_blank" rel="noopener"><code>isLayoutMarginsRelativeArrangement</code></a> 是否基于margin进行排列</li></ul><h3 id="Stack-View的Arranged-Views和Subviews"><a href="#Stack-View的Arranged-Views和Subviews" class="headerlink" title="Stack View的Arranged Views和Subviews"></a>Stack View的Arranged Views和Subviews</h3><p>stack view保证 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616232-arrangedsubviews" target="_blank" rel="noopener"><code>arrangedSubviews</code></a> 属性一直是其 <a href="https://developer.apple.com/documentation/uikit/uiview/1622614-subviews" target="_blank" rel="noopener"><code>subviews</code></a> 的子集. 具体规则如下:</p><ul><li><p>当stack view添加view到<code>arrangedSubviews</code> 时, 它也会把view添加到自己的subviews数组里面（如果已经添加过就不重复添加）</p></li><li><p>当一个view从stack view的subview中移除时，它也会从 <code>arrangedSubviews</code> 中移除</p></li><li><p>当一个view从stack view的 <code>arrangedSubviews</code> 中移除时，这个view<font color="red"> <strong>并不会</strong></font>从stack view的<code>arrangedSubviews</code>中移除</p></li></ul><p>  虽然<code>arrangedSubviews</code>属性一直是其<code>subviews</code>的子集，但这两个数组内的元素顺序并不一定是一致的。</p><ul><li><code>arrangedSubviews</code>中的顺序决定了view在容器中出现的顺序。在水平方向的stack view中，view是沿着阅读方向（绝大部分语言是从左到右，阿拉伯语是从右到左。不过这个不取决于系统语言设置，取决于布局是用left/right还是leading/trailing）排列的。index小的在前，index大的在后</li><li>而<code>subviews</code> 中的顺序决定子view的Z-order。Z-order高的会把低的view盖住</li></ul><h3 id="Stack-View-动态内容"><a href="#Stack-View-动态内容" class="headerlink" title="Stack View 动态内容"></a>Stack View 动态内容</h3><p>当对stack view<a href="https://developer.apple.com/documentation/uikit/uistackview/1616232-arrangedsubviews" target="_blank" rel="noopener"><code>arrangedSubviews</code></a> 进行添加/插入/删除，以及对它所管理的子view的属性进行修改时，stack view的内容会自动更新。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Appears to remove the first arranged view from the stack.</span></span><br><span class="line"><span class="comment">// The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout.</span></span><br><span class="line"><span class="keyword">let</span> firstView = stackView.arrangedSubviews[<span class="number">0</span>]</span><br><span class="line">firstView.isHidden = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>同样的，如果修改stack view的属性，它的内容也会根据属性的变化而动态地调整。比如设置<a href="https://developer.apple.com/documentation/uikit/uistackview/1616223-axis" target="_blank" rel="noopener"><code>axis</code></a>动态地改变stack view的方向。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Toggle between a vertical and horizontal stack</span></span><br><span class="line"><span class="keyword">if</span> stackView.axis == .<span class="type">Horizontal</span> &#123;</span><br><span class="line">    stackView.axis = .<span class="type">Vertical</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    stackView.axis = .<span class="type">Horizontal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在动画block里面调整子view的属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animates removing the first item in the stack.</span></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.25</span>) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> firstView = stackView.arrangedSubviews[<span class="number">0</span>]</span><br><span class="line">    firstView.isHidden = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      UIStackView 官方文档翻译
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Jenkins进行iOS项目自动化发布</title>
    <link href="http://petpwiuta.github.io/2019/01/16/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8CiOS%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B8%83/"/>
    <id>http://petpwiuta.github.io/2019/01/16/使用Jenkins进行iOS项目自动化发布/</id>
    <published>2019-01-16T02:11:04.000Z</published>
    <updated>2019-01-16T02:11:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用Jenkins进行iOS项目自动化发布"><a href="#使用Jenkins进行iOS项目自动化发布" class="headerlink" title="使用Jenkins进行iOS项目自动化发布"></a>使用Jenkins进行iOS项目自动化发布</h3><p>前段时间把iOS发布逻辑迁移到fastlane平台，现在发布调一下fastlane脚本就好，对开发人员极度友好。不过后来发现虽然开发人员用得爽了，不过还是要被测试妹子催着打包，于是想釜底抽薪，把这个功能做得更彻底一点，直接让测试妹子自己来打包，这样就把iOS开发同学彻底解放了～</p><p>公司内网已经部署了一台linux系统的jenkins服务器，上面集成了一些后端和前端的发布逻辑，所以直接添加一个iOS项目的发布流程就行。Xcode环境只能跑在Mac OS上，所以iOS项目的发布流程势必要做远程服务。</p><p>在调研的时候打算在Mac OS上启一个http server，自己写相关的逻辑。后来发现jenkins有远程job互调用的功能，所以方案就变成在Mac OS上也部署一套jenkins，暴露出一些打包服务，然后在公司的jenkins中调用。因为有两套jenkins环境的配置（提供服务的和使用服务的），姑且称之为调用端和执行端。下面就来简单说一下这两部分的具体配置。</p><h4 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h4><p><img src="/images/jenkins-ios/c-1.png" alt="c-1"></p><h4 id="执行端"><a href="#执行端" class="headerlink" title="执行端"></a>执行端</h4><p>执行端主要就是提供一个http服务，用http协议来触发构建任务。下面是具体步骤：</p><ol><li>在jenkins中新建一个任务，这里选“自由风格的软件项目”</li></ol><p><img src="/images/jenkins-ios/a-0.png" alt="a-0"></p><ol><li>然后在General中勾选“参数化构建过程”，这里因为需要接收主调方发送的构建参数，所以要选这一项。因为要通知调用方执行结果，所以构建参数里增加“callbackurl”</li></ol><p><img src="/images/jenkins-ios/a-1.png" alt="a-1"></p><ol><li>接着在构建触发器中勾选“触发远程构建”，并填写身份证令牌。这里的身份证令牌和用户无关，仅仅只是这个job的api令牌，这里可以随便填一个，只要不太容易被猜到就行</li></ol><p><img src="/images/jenkins-ios/a-2.png" alt="a-2"></p><ol><li>最后在构建中增加“执行shell”选项。这里可以写执行任务的逻辑，我这儿就是简单的切换到工程目录，再调用fastlane打包，结束后回调完成的url</li></ol><p><img src="/images/jenkins-ios/a-3.png" alt="a-3"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/projectPath          <span class="comment">#项目路径</span></span><br><span class="line">git checkout branch       <span class="comment">#切换到指定分支</span></span><br><span class="line">fastlane inhousepackage   <span class="comment">#调用fastlane完成打包</span></span><br><span class="line">curl  <span class="variable">$&#123;callbackurl&#125;</span>      <span class="comment">#调用回调url，通知调用方任务完成</span></span><br></pre></td></tr></table></figure><ol><li>到了这一步就完成了项目配置，不过因为用户认证相关的设置还没有完成，所以这个任务还不能被远程触发。点击右上角用户名可以进入到用户设置页面，点击设置，在“API Token”中添加一个token，使用这个token和用户名就能在其他机器上触发任务</li></ol><p><img src="/images/jenkins-ios/a-5.png" alt="a-5"></p><ol><li><p>完成上面这些设置后，会得到下列信息。主调方有了这些信息就能触发远程构建</p><blockquote><ul><li><p>用户名(userName)</p></li><li><p>用户令牌(userToken)</p></li><li>任务令牌(jobToken)</li><li>执行任务的机器ip地址，jenkins服务端口号码</li><li>jenkins任务名字(jobName)</li><li>回调url，这个非必须，不过不传的话无法知道任务是否已经结束(callbackurl)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#最后用上面这些信息拼接成类似下面这样的URL，通过http协议访问就能触发这台机器上的远程任务</span></span><br><span class="line">jobTriggerURL = <span class="string">"http://<span class="variable">$&#123;userName&#125;</span>:<span class="variable">$&#123;userToken&#125;</span>@<span class="variable">$&#123;jobServerIPAndPort&#125;</span>/job/<span class="variable">$&#123;jobName&#125;</span>/buildWithParameters?token=<span class="variable">$&#123;jobToken&#125;</span>&amp;callbackurl=<span class="variable">$&#123;callbackurl&#125;</span>"</span></span><br><span class="line">curl jobTriggerURL</span><br></pre></td></tr></table></figure></blockquote></li></ol><h4 id="调用端"><a href="#调用端" class="headerlink" title="调用端"></a>调用端</h4><p>当执行端设置好以后，调用端的设置就比较简单了。</p><ol><li>在jenkins中新建一个任务，这里选“流水线”，因为调用端的逻辑用到了一些pipeline插件，而且还有一些逻辑要处理，用流水线可以实现更精确控制</li></ol><p><img src="/images/jenkins-ios/b-1.png" alt="b-1"></p><ol><li>在“高级项目选项”中的“流水线”里写下下面的逻辑：</li></ol><p><img src="/images/jenkins-ios/b-2.png" alt="b-2"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">stage (<span class="string">"Wait remote iOS package job finish."</span>) &#123;</span><br><span class="line">    node &#123;</span><br><span class="line">        hook = registerWebhook()   <span class="comment">#这里使用了Webhook Step Plugin插件</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        ip = sh (</span><br><span class="line">            script: <span class="string">"ifconfig en0 | sed -n 's/[\\s\\t]*inet \\([0-9\\.]*\\) .*/\\1/p' | tr -d '\\t\\n'"</span>,</span><br><span class="line">            returnStdout: <span class="literal">true</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        url = sh (</span><br><span class="line">            script: <span class="string">"echo \"<span class="variable">$&#123;hook.getURL()&#125;</span>\" | sed -n 's/localhost:[0-9]*/<span class="variable">$&#123;ip&#125;</span>:8080/p'"</span>,</span><br><span class="line">            returnStdout: <span class="literal">true</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#$&#123;hook.getURL()&#125;获取的回调url中host部分是localhost，所以需要用本机ip替换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里的所有信息都是在执行实际任务的机器上获取的，具体细节看“执行端”部分</span></span><br><span class="line">        user =  <span class="string">"username"</span>  <span class="comment">#用户名字</span></span><br><span class="line">        userToken = <span class="string">""</span>      <span class="comment">#用户认证token</span></span><br><span class="line">        jobToken = <span class="string">"triggertoken123"</span>  <span class="comment">#任务token</span></span><br><span class="line">        jobServerIP = <span class="string">"172.20.24.122:8080"</span> </span><br><span class="line">        jobName = <span class="string">"iOS"</span></span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        <span class="comment">#获取到上面的这些信息以后拼接成下面这个样式的url，发送get请求就能触发远程job</span></span><br><span class="line">        <span class="comment">#因为有些参数包含特殊字符，所以需要加上--data-urlencode来进行转义</span></span><br><span class="line">        jobTriggerURL = <span class="string">"http://<span class="variable">$&#123;user&#125;</span>:<span class="variable">$&#123;userToken&#125;</span>@<span class="variable">$&#123;jobServerIP&#125;</span>/job/<span class="variable">$&#123;jobName&#125;</span>/buildWithParameters"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"job url:<span class="variable">$&#123;jobTriggerURL&#125;</span>"</span></span><br><span class="line">        sh(<span class="string">"curl --data-urlencode \"token=<span class="variable">$&#123;jobToken&#125;</span>\" --data-urlencode \"callbackurl=<span class="variable">$&#123;url&#125;</span>\" <span class="variable">$&#123;jobTriggerURL&#125;</span>"</span>)</span><br><span class="line">        </span><br><span class="line">   </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Webhook called with data: <span class="variable">$&#123;url&#125;</span>"</span></span><br><span class="line">        data = waitForWebhook hook</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚本的主要逻辑是调用远程job，然后等待远程任务发送回调请求。这里用到了<a href="https://wiki.jenkins.io/display/JENKINS/Webhook+Step+Plugin" target="_blank" rel="noopener">Webhook Step Plugin</a>插件，它主要作用是获取一个回调URL，并挂起当前执行的脚本，直到回调url被调用以后再继续执行。</p><p>经过上面的配置后就能在公司jenkins上进行iOS项目自动化发布了。如果jenkins是在外网，则会麻烦一些，需要连vpn或者在NAT上做一个端口映射才行。</p>]]></content>
    
    <summary type="html">
    
      使用Jenkins进行iOS项目自动化发布
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>中国互联网拓扑结构</title>
    <link href="http://petpwiuta.github.io/2018/12/26/%E4%B8%AD%E5%9B%BD%E4%BA%92%E8%81%94%E7%BD%91%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/"/>
    <id>http://petpwiuta.github.io/2018/12/26/中国互联网拓扑结构/</id>
    <published>2018-12-26T06:31:59.000Z</published>
    <updated>2018-12-26T06:31:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中国互联网拓扑结构"><a href="#中国互联网拓扑结构" class="headerlink" title="中国互联网拓扑结构"></a>中国互联网拓扑结构</h2><h3 id="1-中国7大骨干网运营商"><a href="#1-中国7大骨干网运营商" class="headerlink" title="1 中国7大骨干网运营商"></a>1 中国7大骨干网运营商</h3><p>目前中国有七家骨干网运营商，分别是中国电信、中国联通、中国移动、中国教育和科研计算机网、中国科技网 、中国国际电子商务网和中国长城互联网。</p><ul><li>中国电信，拥有2张全国骨干网：中国公用计算机互联网（CHINANET / CHINA163）和中国电信下一代承载网（ChinaNet Next Carrying Network，简称CN2）。</li><li>中国联通，拥有2张全国骨干网：中国网通互联网（CHINA169）和旧中国网通互联网（CNCNET）。原中国金桥信息网(CHINAGBN)由吉通公司负责建设、运营和管理，2002年5月16日，吉通公司并入中国网通；2009年中国网通与中国联通合并。2009年工业和信息化部同意原中国网通互联网骨干网（CHINA169）和原中国联通互联网骨干网（UNINET）实施网络融合，并将 UNINET 作为下级网络接入 CHINA169。中国网通互联网（CHINA169）是从中国公用计算机互联网（CHINA163）拆分而来，但中国网通从中国电信拆分前已经拥有一张独立的网络（CNCNET），自治域为AS9929，现在也称作中国联通工业互联网（China Unicom Industrial Internet，简称CUII），定位为主要提供国际和国内跨地市MPLS VPN和大客户互联网专线任务的承载，常用于企业宽带和IDC，已经极少见于家用宽带。</li><li>中国移动，拥有1张全国骨干网：中国移动互联网（CMNET），于2000年1月组建。</li><li>中国教育和科研计算机网（CERNET）：始建于1994年，由中国教育部投资并管理，是中国最大的公益性、学术性计算机互联网络，网络总控中心设在清华大学。</li><li>中国科技网（CSTNET）：中国科技网的前身是中国科学院于1989年8月建立的中关村教育与科研示范网络（NCFC）。1994年4月，NCFC与美国NSFNET直接互联，实现了中国与国际互联网的首次全功能网络连接。1996年2月，以NCFC为基础发展起来的中国科学院院网（CASNET）更名为中国科技网（CSTNET）。</li><li>中国国际经济贸易互联网（CIETNET）：全国外贸系统企事业单位专用，由中国国际电子商务中心负责组建、运行和维护，不设国际出口带宽。</li><li>中国长城互联网（CGWNET）：军队专用，不设国际出口带宽。</li></ul><h3 id="2-骨干网的基本技术概念"><a href="#2-骨干网的基本技术概念" class="headerlink" title="2 骨干网的基本技术概念"></a>2 骨干网的基本技术概念</h3><ul><li>骨干网（backbone  network）：核心节点互相连接组成的网络，保障核心节间信息转发，不负责直接接入用户</li><li>支撑网：监管业务网的网络。类似于管理磁盘的软件本身就要占用一部分磁盘空间，管理网络的系统也需要使用一部分网络资源。</li><li>接入网（Access Network）：指骨干网络到用户终端之间的网络。因为终端网络介质较多，所以网络类型也很多，如有线的光纤，双绞线；无线的wifi，蜂窝移动网，卫星等</li></ul><h3 id="3-中国电信网络拓扑结构"><a href="#3-中国电信网络拓扑结构" class="headerlink" title="3 中国电信网络拓扑结构"></a>3 中国电信网络拓扑结构</h3><h4 id="中国电信163"><a href="#中国电信163" class="headerlink" title="中国电信163"></a>中国电信163</h4><p>163网络分为骨干网和城域网两层结构。骨干网层面，又可分为三层：核心层、汇接层和接入层，另外核心层还连接有国际出入口层、互联互通层。骨干网分为3大片区：北京、上海、广州。</p><p>骨干网3大片区又细分为9个大区：<br>北京片区：北京大区、天津大区、西安大区<br>上海片区：上海大区、南京大区、杭州大区<br>广州片区：广州大区、武汉大区、成都大区</p><ul><li><p>核心层：<br>  超级核心：北京、上海、广州<br>  普通核心：天津、西安、南京、杭州、武汉、成都<br>  核心节点间Full-Mesh连接<br>  负责各省份间信息交互，超级核心还负责与国内其他运营商、国际访问的流量交互</p></li><li><p>汇接层：<br>  北方省份落地设备，南方省份省网汇聚设备<br>  各省份双方向上联，分别连接到一个超级核心和一个普通核心节点，部分省份三方向上联</p></li></ul><ul><li>接入层：<br>未完成扁平化的省份还有地市接入层设备，用于接入省内城域网</li><li><p>中国电信ChinaNet网络骨干拓扑<br><img src="/images/networking-structure/Picture1.png" alt="中国电信ChinaNet网络骨干拓扑"></p></li><li><p>中国电信ChinaNet网络省内拓扑结构<br><img src="/images/networking-structure/Picture2.png" alt="中国电信ChinaNet网络省内拓扑结构"></p></li><li>国内互联互通层：<br>在北京、上海、广州三个超级核心设有互联互通设备（E路由器） ，互联互通设备（E路由器）直接连接在超级核心C路由器</li><li>ChinaNet通过互联互通设备与部分其它运营商互联和流量互访<br><img src="/images/networking-structure/Picture3.png" alt="ChinaNet通过互联互通设备与部分其它运营商互联和流量互访"></li><li>ChinaNet－国际网间互联拓扑<br><img src="/images/networking-structure/Picture4.png" alt="ChinaNet－国际网间互联拓扑"></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E9%AA%A8%E5%B9%B2%E7%BD%91%E8%BF%90%E8%90%A5%E5%95%86" target="_blank" rel="noopener">中国骨干网运营商</a></li><li><a href="https://wenku.baidu.com/view/4e3ab12681c758f5f71f67b9.html?from=search" target="_blank" rel="noopener">中国电信运营商骨干网络架构</a></li><li><a href="http://blog.51cto.com/juispan/2095304" target="_blank" rel="noopener">中国运营商网络分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      中国互联网拓扑结构
    
    </summary>
    
      <category term="CS基础" scheme="http://petpwiuta.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Symbolicatecrash符号化crash日志</title>
    <link href="http://petpwiuta.github.io/2018/12/26/%E4%BD%BF%E7%94%A8Symbolicatecrash%E7%AC%A6%E5%8F%B7%E5%8C%96crash%E6%97%A5%E5%BF%97/"/>
    <id>http://petpwiuta.github.io/2018/12/26/使用Symbolicatecrash符号化crash日志/</id>
    <published>2018-12-26T06:30:18.000Z</published>
    <updated>2018-12-26T06:30:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Symbolicatecrash符号化crash日志"><a href="#使用Symbolicatecrash符号化crash日志" class="headerlink" title="使用Symbolicatecrash符号化crash日志"></a>使用Symbolicatecrash符号化crash日志</h2><ol><li><p>准备工作<br>解析crash日志需要3个文件：</p><ul><li><code>.crash</code>文件</li><li><code>.dSYM</code>文件</li><li><code>symbolicatecrash</code>工具</li></ul></li><li><p>配置symbolicatecrash<br>Xcode的symbolicatecrash路径如下：<br><code>/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash</code><br>如果在该路径下找不到工具的话可能是因为不同版本这个工具的位置不一样，可以用下面的命令搜索：<br><code>find /Applications/Xcode.app -name symbolicatecrash -type f</code></p><p> 到找symbolicatecrash以后还需要倒入环境变量才能使用，不然会报</p><blockquote><p>Error: “DEVELOPER_DIR” is not defined at ./symbolicatecrash<br>的错误</p></blockquote><p> 用<code>export DEVELOPER_DIR=&quot;/Applications/Xcode.app/Contents/Developer&quot;</code>就能设置环境变量，如果报错可能是安装了多个xcode，xcod的名字被修改了，如果是这样执行<code>xcode-select --print-path</code> 找到DEVELOPER_DIR，然后再执行上面的命令</p><p> 当然，设置环境变量也有一劳永逸的办法，就是把环境变量直接加到<code>~/.bash_profile</code>中，如果是zsh的话就是<code>~/.zshrc</code>。打开配置文件，在末尾添加</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="type">Add</span> environment variable <span class="type">DEVELOPER_DIR</span>  </span><br><span class="line">export <span class="type">DEVELOPER_DIR</span>=/<span class="type">Applications</span>/<span class="type">Xcode</span>.app/<span class="type">Contents</span>/<span class="type">Developer</span></span><br></pre></td></tr></table></figure><p>然后重启终端或者执行source命令刷新</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="type">Add</span> environment variable <span class="type">DEVELOPER_DIR</span>  </span><br><span class="line">source ~/.bash_profile</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li><li><p>符号化crash文件<br>到这一步就是调用symbolicatecrash工具进行符号化了，代码如下：<br><code>symbolicatecrash [.crash 文件] [.dSYM文件] &gt; [输出文件]</code></p></li><li><p>参考</p><ul><li><a href="https://www.jianshu.com/p/2ccb50520cb1" target="_blank" rel="noopener"> Xcode 7.3 解析（符号化） iOS Crash 文件（.crash）</a></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      使用Symbolicatecrash符号化crash日志
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS Fastlane打包教程</title>
    <link href="http://petpwiuta.github.io/2018/12/26/iOS%20Fastlane%E6%89%93%E5%8C%85%E6%95%99%E7%A8%8B/"/>
    <id>http://petpwiuta.github.io/2018/12/26/iOS Fastlane打包教程/</id>
    <published>2018-12-26T06:22:44.000Z</published>
    <updated>2018-12-26T06:22:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iOS-Fastlane打包教程"><a href="#iOS-Fastlane打包教程" class="headerlink" title="iOS Fastlane打包教程"></a>iOS Fastlane打包教程</h3><p><a href="https://fastlane.tools/" target="_blank" rel="noopener">Fastlane</a>是一套由Ruby编写的自动打包以及分发工具集。它的设计类似于Unix中的shell pipeline，每个功能由特定的工具实现，通过不同的工具的连接组合成强大的功能。</p><blockquote><p>下面这些是Fastlane提供的常用工具：</p><ul><li><p><code>gym</code>: 打包 iOS App，是对<em>xcodebuild</em>的封装</p></li><li><p><code>match</code>: 用于在团队中同步证书和配置文件的工具</p></li></ul><ul><li><code>deliver</code>: 将应用截图，元数据和 app 上传到 App Store</li><li><code>produce</code>: 使用命令行在 iTunes Connect 后台和 Dev Portal 创建新的 iOS app</li></ul></blockquote><p>这里仅仅是列出了最常用的工具，Fastlane标准安装包中的<a href="https://docs.fastlane.tools/actions/" target="_blank" rel="noopener"><strong>工具</strong></a>非常多，而且还有<a href="https://www.jianshu.com/p/0520192c9bd7" target="_blank" rel="noopener"><strong>自定义插件</strong></a>功能，这里就不赘述。</p><h4 id="1-安装Fastlane"><a href="#1-安装Fastlane" class="headerlink" title="1 安装Fastlane"></a>1 安装Fastlane</h4><p> Fastlane本质是一个Ruby脚本的集合，所以机器上首先得安装Ruby。OS X 10.9(Mavericks)以后默认安装的是 Ruby 2.0 本。可能有些脚本或者工具要求更高的版本，所以安装的时候尽量选最新版的Ruby。</p><p>这里用<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>作为包管理器来安装Ruby：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">brew install ruby</span></span><br></pre></td></tr></table></figure><p>安装完Ruby以后才是我们的主角Fastlane：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo gem install fastlane</span></span><br></pre></td></tr></table></figure><p>等安装脚本执行完就可以开始Fastlane之旅啦！</p><h4 id="2-Fastlane设置"><a href="#2-Fastlane设置" class="headerlink" title="2 Fastlane设置"></a>2 Fastlane设置</h4><p>当Fastlane安装好以后，切换到想要用Fastlane进行打包的工程目录，然后初始化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">fastlane init</span></span><br></pre></td></tr></table></figure><p>输入上面这个命令以后Fastlane会调用交互式脚本会询问你关于App的一些信息，按照实际信息填写完以后会生成下面这个结构的目录</p><p><img src="/images/fastlant-folder-structure.png" style="zoom:50%" align=left/></p><p>fastlane文件夹里面包含了Appfile、Fastfile等文件，它们其实都是ruby语法的脚本文件。上面这些都不用手动添加，运行对应的工具以后就会由工具自动生成，配置文件按需生成，不运行特定工具就不会有对应配置文件产生，如Matchfile，它在你运行<code>fastlane match</code>并输入相关信息后才会出现。</p><p>下面是常见的配置文件的用途：</p><ul><li>Appfile 记录了app_identifier、apple_id、itc_team_id、team_id等信息</li><li>Fastfile 最核心的文件。自己编写的Fastlane脚本逻辑都写在这个文件中</li><li>Matchfile 如果是用Match来管理证书的话会有这个文件，里面记录了Match工具在运行时所需要的app_identifier、team_id、username、git_url等信息</li></ul><p>fastlane的很多工具既可以写在Fastfile中当一个函数来调用，也可以直接在shell命令行用<code>fastlane 工具名</code>这种方式当命令来使（实际上是一样的，都是执行了对应的ruby脚本）。</p><p>上述文件里的配置信息会同步到Fastfile脚本的执行context中，如果用户在脚本里调用工具时没有指定这些字段的值，就会使用配置文件中的，反之就会以脚本里指定的为准。比如在Appfile中有app_identifier字段，你在Appfile中写的是a，在Fastfile中调用match时如果不写app_identifier就会取Appfile中的值也就是a，如果明确指定app_identifier为b，则会以b为准。不过在脚本中指定app_identifier为新值并不会把Appfile中的也改掉。</p><p>除了上面说的以外还有一种情况，就是在Matchfile和Appfile中都指定了app_identifier，这到底以哪个为准？这种情况下会以你运行的命令对应的配置文件为准，比如你运行的是match，它有自己的配置文件Matchfile，则app_identifier会以Matchfile中的为准。如果拿不准的话可以看fastlane的输出log，里面会详细列出脚本执行时的各种环境变量。</p><h4 id="3-Fastfile样例"><a href="#3-Fastfile样例" class="headerlink" title="3 Fastfile样例"></a>3 Fastfile样例</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">default_platform <span class="symbol">:ios</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span> <span class="keyword">do</span></span><br><span class="line">  before_all <span class="keyword">do</span>   </span><br><span class="line">    backup_project_info_file()</span><br><span class="line">    cocoapods()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  after_all <span class="keyword">do</span> <span class="params">|lane|</span></span><br><span class="line">    restore_project_info_file()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  error <span class="keyword">do</span> <span class="params">|lane, exception|</span></span><br><span class="line">    restore_project_info_file()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  desc <span class="string">"Deploy a new enterprise version"</span></span><br><span class="line">  lane <span class="symbol">:inhouse</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#start archive</span></span><br><span class="line">    build_app(</span><br><span class="line">      <span class="symbol">workspace:</span> <span class="string">"Demo.xcworkspace"</span>,</span><br><span class="line">      <span class="symbol">scheme:</span> <span class="string">"Demo"</span>,</span><br><span class="line">      <span class="symbol">configuration:</span> <span class="string">"Release"</span>,</span><br><span class="line">      <span class="symbol">clean:</span> <span class="literal">true</span>,</span><br><span class="line">      <span class="symbol">export_options:</span> <span class="string">"./fastlane/EnterpriseExportOptions.plist"</span>,</span><br><span class="line">      <span class="symbol">build_path:</span> <span class="string">"./Build/"</span>,</span><br><span class="line">      <span class="symbol">output_directory:</span> <span class="string">"./Build/"</span>,</span><br><span class="line">      <span class="symbol">include_symbols:</span> <span class="literal">false</span>,  <span class="comment">#ipa包中包含符号文件</span></span><br><span class="line">      <span class="symbol">output_name:</span> <span class="string">"Demo.ipa"</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">#make change log from commit history</span></span><br><span class="line">    log = changelog_from_git_commits(<span class="symbol">merge_commit_filtering:</span> <span class="string">"exclude_merges"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#upload to pger</span></span><br><span class="line">    pgyer(<span class="symbol">api_key:</span> <span class="string">"api key"</span>, <span class="symbol">user_key:</span> <span class="string">"ukey"</span> ,<span class="symbol">update_description:</span> log)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#post notification by dingding</span></span><br><span class="line">    dingding_noti(</span><br><span class="line">      <span class="string">"./Build/Demo.ipa"</span>,  <span class="comment">#ipa path</span></span><br><span class="line">      <span class="string">""</span>,   <span class="comment">#ipa url</span></span><br><span class="line">      <span class="string">""</span>, <span class="comment">#icon url</span></span><br><span class="line">      log <span class="comment">#change log</span></span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lane <span class="symbol">:inhouse</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">#自定义逻辑</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面这个格式就是定义一个action，当你使用<code>fastlane inhouse</code>时里面的自定义代码就会被运行。</p><p>这是一个典型的Fastfile逻辑，先是调用build_app来archive并导出ipa文件，再调用changelog_from_git_commits生成change log，然后把ipa上传到蒲公英分发系统，最后再用钉钉通知任务完成。这里是在单个target以及证书和相关profile都配置好的情况下的demo。不过在实际中往往会有动态修改target信息，用match更新证书和profile等逻辑，最终的脚本就要比这个复杂很多。</p><h4 id="4-Fastlane-Jenkins"><a href="#4-Fastlane-Jenkins" class="headerlink" title="4 Fastlane+Jenkins"></a>4 Fastlane+Jenkins</h4><p>其实Jenkins对移动端的打包支持的并不好，所以在Fastlane成熟以后很多人都把打包逻辑迁移到Fastlane上了。这里Jenkins就演变成变成一个CI控制台，仅仅用来做权限控制和脚本触发器。</p><p>Jenkins中集成Fastlane就很简单了，在编译的环节直接调用本地的Fastlane脚本就行。</p><h4 id="5-题外话"><a href="#5-题外话" class="headerlink" title="5 题外话"></a>5 题外话</h4><p>Fastlane踩坑下来发现这套方案功能确实很强大，然而也很复杂。你得学Ruby（有些逻辑不一定能找到现成的插件，得自己写），然后还得把Fastlane的运行逻辑搞清楚，学习成本还是有一点的。所以Fastlane方案适合产品比较多，发版逻辑比较复杂的中大型公司。</p><p>在前几年专门做移动端CI的服务商还还不多，但现在移动领域CI集成方案已经很丰富。并且Xcode Server在经过几个版本的迭代以后基本上已经能满足大部分CI需求。所以Fastlane并非是唯一的选择，根据自己的需求选择合适的方案就行，<a href="https://medium.com/xcblog/five-options-for-ios-continuous-delivery-without-fastlane-2a32e05ddf3d" target="_blank" rel="noopener">这篇文章</a>详细介绍了除Fastlane以外其他的CI方案。</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li><p><a href="https://xiaozhuanlan.com/topic/4591867203" target="_blank" rel="noopener">Fastlane 的神秘花园</a></p></li><li><p><a href="https://medium.com/xcblog/five-options-for-ios-continuous-delivery-without-fastlane-2a32e05ddf3d" target="_blank" rel="noopener">Five Options for iOS Continuous Delivery without Fastlane</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      iOS Fastlane打包教程
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>移动开发中的CI方案简介</title>
    <link href="http://petpwiuta.github.io/2018/12/26/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84CI%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B/"/>
    <id>http://petpwiuta.github.io/2018/12/26/移动开发中的CI方案简介/</id>
    <published>2018-12-26T06:12:45.000Z</published>
    <updated>2018-12-26T06:12:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="移动开发中的CI方案简介"><a href="#移动开发中的CI方案简介" class="headerlink" title="移动开发中的CI方案简介"></a>移动开发中的CI方案简介</h3><p> <a href="https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/" target="_blank" rel="noopener">Continuous integration</a> (CI) 是软件工程中的重要概念，以前在传统的软件开发中用的比较多（以前常说的daily build or nightly build意思和CI差不多）。现在随着移动App的流行，相关的工具以及方法论在移动开发中也有所体现。这里简单说一下现在移动研发领域的CI现状（CI工具一般都是跨语言的，所以下面列出的这些工具大部分也能在前后端开发中使用）。</p><p>现在CI的解决方案很多，有开源的也有收费的。开源的免费，绝大部分功能都够用，不过出问题得自己处理，不过如果选热门的开源解决方案的话基本上常见问题都有人帮你踩坑了，所以这点不用担心（反之如果选冷门开源方案一定要做好自己改代码的心理准备）。商业方案除了贵以外没啥缺点，一般就是衡量价格、功能，以及各厂商的差异化功能。</p><h4 id="开源方案"><a href="#开源方案" class="headerlink" title="开源方案"></a>开源方案</h4><ul><li><p><a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a></p><p>Jenkins是一款著名的开源CI工具，除了界面丑点，其他功能基本上和一般收费方案没什么区别。很多公司团队会基于Jenkins做二次开发，把后端、前端和移动端的CI都集成到Jenkins中。</p></li><li><p><a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis CI</a></p><p>Travis CI是一个开源的在线<a href="https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88" target="_blank" rel="noopener">持续集成</a>服务，用来构建和测试托管在Github上的代码。它和Github类似，对开源项目免费，其他项目要收费。这个用来做个人项目比较方便，如果公司要用的话可以选它的付费企业版服务。</p></li><li><p><a href="https://about.gitlab.com/" target="_blank" rel="noopener">GitLab</a></p><p>GitLab是互联网公司常用的开源代码管理工具，在8.0版本上也有CI功能了。</p></li></ul><h4 id="收费方案"><a href="#收费方案" class="headerlink" title="收费方案"></a>收费方案</h4><ul><li><p><a href="https://circleci.com/" target="_blank" rel="noopener">Circle CI</a></p><p>Circle CI本身是在线服务，不过企业版支持私有化部署。</p></li><li><p><a href="https://www.bitrise.io/" target="_blank" rel="noopener">Bitrise</a></p><p>Bitrise是专门为移动应用而设计的CI在线服务，企业版支持私有化部署。</p></li><li><p><a href="https://visualstudio.microsoft.com/zh-hans/app-center/" target="_blank" rel="noopener">Visual Studio App Center</a></p><p>Visual Studio App Center和Bitrise一样，是微软专门为移动应用而设计的CI在线服务</p></li></ul><p>这里只是对市面上常见的CI方案做了下汇总，如果想看看各种方案的详细对比可以看<a href="https://hackernoon.com/top-ci-cd-tools-for-your-android-and-ios-projects-8d356b983b3b" target="_blank" rel="noopener">这篇文章</a>。</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li><a href="https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/" target="_blank" rel="noopener">Continuous integration</a></li><li><a href="https://hackernoon.com/top-ci-cd-tools-for-your-android-and-ios-projects-8d356b983b3b" target="_blank" rel="noopener">Best Jenkins alternatives. Top CI/CD Tools for your Android and iOS projects</a></li></ul>]]></content>
    
    <summary type="html">
    
      移动开发中的CI方案简介
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Xcode Signing 机制</title>
    <link href="http://petpwiuta.github.io/2018/12/26/Xcode%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/"/>
    <id>http://petpwiuta.github.io/2018/12/26/Xcode签名机制/</id>
    <published>2018-12-26T06:12:11.000Z</published>
    <updated>2018-12-26T06:12:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Xcode-Signing-机制"><a href="#Xcode-Signing-机制" class="headerlink" title="Xcode Signing 机制"></a>Xcode Signing 机制</h3><h4 id="历史遗留问题"><a href="#历史遗留问题" class="headerlink" title="历史遗留问题"></a>历史遗留问题</h4><p>做iOS开发经验稍长的同学都知道Xcode8以前的证书管理机制做的比较简单。就是一旦发现你的机器没有provisionProfile所关联的证书，就会在界面上显示红色按钮，你点击“Fix it”，然后Xcode就revoke provisionProfile所关联的证书，然后在帮你申请一个新的。</p><p>这个单人单机的情况下没有什么问题，不过你如果有2台以上的mac就会发现“Fix it”这个按钮不能随便点。多台mac一般都是把私钥copy到每一台电脑上，如果在哪台电脑上点了“Fix it”，这时辛辛苦苦复制好的私钥就会revoke，瞬间所有mac都不能正常干活了。如果是一个人有多台电脑还好点，这个问题在团队里面更严重，多人有多人电脑时，很可能会有人误点到“Fix it”按钮，而造成整个团队罢工的情况。所以一般小组成员都会互相告诫不能随便点“Fix it”按钮，甚至有人还写了插件来禁用这个按钮。</p><p>这种痛苦的情况在Xcode8上得到了彻底解决。</p><h4 id="Xcode8引入的新的开发证书的更新机制"><a href="#Xcode8引入的新的开发证书的更新机制" class="headerlink" title="Xcode8引入的新的开发证书的更新机制"></a>Xcode8引入的新的开发证书的更新机制</h4><p>Xcode8引入的最大改变就是provisionProfile中关联的证书变成了多个，一个develop版本的provisionProfile中可以关联所有开发人员自己的证书。只要在机器上有列表中的任何一个证书就能进行代码签名，这样在新成员来时仅仅更新它自己的证书以及provisionProfile就行，并不会影响其他人，这个步骤在Xcode8中非常简单，只需要一个点击就能搞定</p><p>Xcode的这些操作都是在后台进行的，不过你如果想要了解估计的细节可以在左侧的“Show the Report navigator(最后一个选项)”选项卡中看到<br><img src="/images/xcode-sign.png" alt=""></p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ul><li><p>Automatically manage signning<br>在这种模式下每个开发人员都会有自己的develop证书，这时尽量用自己develop证书来archive，而不要用公共的开发证书，避免了别人不小心把公用证书revoke导致的一系列问题</p></li><li><p>manully manage signning<br>手动管理证书的时候主要不要选和自己帐号相关联的证书，因为自己的帐号只有自己有，到团队其他成员的机器上就不能工作了。这时候就选develope这样的默认值就行了</p></li></ul><h4 id="相关引用"><a href="#相关引用" class="headerlink" title="相关引用"></a>相关引用</h4><ul><li><a href="https://developer.apple.com/videos/play/wwdc2017/403/" target="_blank" rel="noopener">What’s New in Signing for Xcode and Xcode Server - WWDC2017</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2016/401" target="_blank" rel="noopener">What’s New in Xcode App Signing - WWDC2016</a></li></ul>]]></content>
    
    <summary type="html">
    
      Xcode Signing 机制
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Match工具介绍</title>
    <link href="http://petpwiuta.github.io/2018/12/26/Match%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    <id>http://petpwiuta.github.io/2018/12/26/Match工具介绍/</id>
    <published>2018-12-26T06:11:28.000Z</published>
    <updated>2018-12-26T06:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Match工具介绍"><a href="#Match工具介绍" class="headerlink" title="Match工具介绍"></a>Match工具介绍</h3><p>Match是Fastlane工具集中非常重要的一个，它负责iOS应用生命周期中的各种证书和profile的创建和维护。想想各位被各种证书和profile问题所支配的恐惧就知道它的厉害之处。</p><h4 id="1-功能特性"><a href="#1-功能特性" class="headerlink" title="1 功能特性"></a>1 功能特性</h4><ul><li><p>创建、更新和删除Xcode所需的各种证书和Profiles</p></li><li><p>使用Git管理上述的文件，达到团队内共享证书和Profiles的目的</p></li><li><p>证书和Profiles在进入Git仓库时会进行加密，进一步保证安全性</p></li><li><p>支持多账户，多target</p></li></ul><h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h4><p>Match内部使用cert、sign来分别进行证书以及profiles的管理。cert、sign是对苹果官方的API的二次封装，使用它们配置好证书和profiles以后，再指定一个Git仓库的地址，以及加密证书和profiles的密码，Match就会用指定的密码把证书和profiles加密，然后在把加密后的文件commit到版本库，并push到Git仓库地址。当其他成员需要这些信息的时候使用Match命令，它就会从Git仓库pull加密过的文件，并询问密码，得到密码后再把这些文件解密并添加到keychain和Profiles目录。这样就像Git管理代码一样实现了团队内共享证书和Profiles的目的。</p><h4 id="3-用法"><a href="#3-用法" class="headerlink" title="3 用法"></a>3 用法</h4><h5 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fastlane match init</span><br></pre></td></tr></table></figure><p>会进入交互式shell环境，按照实际情况输入app_identifier、team_id、username、git_url等信息后会在fastlane目录生成Matchfile。</p><h5 id="3-2-生成并同步证书和profile"><a href="#3-2-生成并同步证书和profile" class="headerlink" title="3.2 生成并同步证书和profile"></a>3.2 生成并同步证书和profile</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开发环境证书</span></span><br><span class="line">$ fastlane match development</span><br><span class="line"><span class="comment"># 产品环境证书</span></span><br><span class="line">$ fastlane match appstore</span><br><span class="line"><span class="comment"># 内测环境证书</span></span><br><span class="line">$ fastlane match adhoc</span><br></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li><p><a href="http://icyleaf.com/2017/03/fastlane-match-in-action/" target="_blank" rel="noopener">你虐我千百遍，我待你如初恋，直到我遇到 match</a></p></li><li><p><a href="https://docs.fastlane.tools/actions/match/" target="_blank" rel="noopener">match doc</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      Match工具介绍
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>给Xcode8安装插件</title>
    <link href="http://petpwiuta.github.io/2017/11/13/%E7%BB%99Xcode8%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/"/>
    <id>http://petpwiuta.github.io/2017/11/13/给Xcode8安装插件/</id>
    <published>2017-11-13T08:03:39.000Z</published>
    <updated>2017-11-13T08:03:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="给Xcode8安装插件"><a href="#给Xcode8安装插件" class="headerlink" title="给Xcode8安装插件"></a>给Xcode8安装插件</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Xcode8以后安装以前<a href="http://alcatraz.io/" target="_blank" rel="noopener">Alcatraz</a>上的插件就行不通了，不过网上也有很多方案，主要是重新给Xcode签名。这里把这些文章做一个汇总。</p><p>在Xcode8以后，苹果为了安全性(比如防止再次出现XcodeGhost事件)，把Xcode增加了签名校验，不会再加载以前Alcatraz下载的插件。并给出了自己的插件机制(<a href="https://developer.apple.com/videos/play/wwdc2016/414/" target="_blank" rel="noopener">Xcode Source Editor Extension</a>)，但是这个插件机制实用性很低。所以很多人就想着要继续使用以前的插件。</p><p>现在的主流方案是是把Xcode复制一份，一个没有重签名，用来打包上线。另外一份重签名后，重新使用以前的插件，仅仅用来写代码。下面就来说说<strong>如何进行Xcode重签名</strong>、以及<strong>如何让以往的插件能在重签名的Xcode上跑起来</strong>。</p><h4 id="Xcode重签名"><a href="#Xcode重签名" class="headerlink" title="Xcode重签名"></a>Xcode重签名</h4><ol><li>创建自签名证书<br>打开钥匙串，创建新证书，名称填XcodeSigner，证书类型选择代码签名(名字里面尽量不要包含空格，免得在命令行容易出错)<br><img src="/images/Xcod8plugin/xcode8_resign_1.png" alt=""><br><img src="/images/Xcod8plugin/xcode8_resign_2.png" alt=""></li><li><p>复制Xcode。这里因为要留一份未重签名的Xcode来打包，所以这里先复制一份，并重命名为XcodeSigner</p></li><li><p>给Xcode重签名(这里的Xcode已经重命名为XcodeSigner)<br><code>sudo codesign -f -s XcodeSigner /Applications/XcodeSigner.app</code></p></li></ol><p>经过上面这些步骤Xcode就已经被重签名了，什么？你说为什么三步，能一步到位吗，恩、问得好。还真有一步到位的解决方案。<br><a href="https://github.com/fpg1503/MakeXcodeGr8Again" target="_blank" rel="noopener">MakeXcodeGr8Again</a>把上面说的这三步合在了一起，并提供了CLI和GUI两种使用方式。一步到位！</p><p>运行重新签名过后的Xcode很多人会发现以前的插件还是没有工作。这个问题在以前就有。原因是插件的<code>DVTPlugInCompatibilityUUIDs</code>包含了可运行的Xcode版本id，Xcode更新以后需要把新Xcode的id添加到插件的<code>DVTPlugInCompatibilityUUIDs</code>中。</p><h4 id="把Xcode-id加入DVTPlugInCompatibilityUUIDs"><a href="#把Xcode-id加入DVTPlugInCompatibilityUUIDs" class="headerlink" title="把Xcode id加入DVTPlugInCompatibilityUUIDs"></a>把Xcode id加入DVTPlugInCompatibilityUUIDs</h4><ol><li><p>获取Xcode的uuid<br>Xcode的Info.plist里就保存了自己的uuid。</p><p>可以<code>右键点击Xcode</code>-&gt;<code>显示包内容</code>-&gt;<code>Contents/Info.plist</code>-&gt;<code>复制DVTPlugInCompatibilityUUID</code>来获取</p><p>也可以通过<code>defaults read /Applications/Xcode.app/Contents/Info.plist DVTPlugInCompatibilityUUID</code>命令来获取</p></li><li><p>把uuid加入插件的DVTPlugInCompatibilityUUIDs<br>Xcode插件放在<code>~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins</code>为xcplugin格式。通过显示包内容可以看到xcplugin中有个<code>Info.plist</code>，DVTPlugInCompatibilityUUIDs字段就是。</p></li></ol><p>把uuid更新到插件中需要两步，但是！插件有很多个，一个个来肯定要把人逼疯，这里当然有all in one的解决方案。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~&#x2F;Library&#x2F;Application\ Support&#x2F;Developer&#x2F;Shared&#x2F;Xcode&#x2F;Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add &#96;defaults read &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Info.plist DVTPlugInCompatibilityUUID&#96;</span><br></pre></td></tr></table></figure><p>这个命令主要做了这些：<br>通过<code>find</code>在插件目录下找到所有插件的Info.plist文件。<br>通过<code>xargs</code>对上一步的搜索结果进行枚举，针对每一个Info.plist文件，利用<code>defaults write</code>命令将当前Xcode版本的uuid加到DVTPlugInCompatibilityUUIDs中。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="http://www.jianshu.com/p/309da7b2119d" target="_blank" rel="noopener">如何在Xcode8上安装插件</a></li><li><a href="http://joeshang.github.io/2015/04/10/fix-xcode-upgrade-plugin-invalid/" target="_blank" rel="noopener">Xcode升级后插件失效的原理与修复办法</a></li></ul>]]></content>
    
    <summary type="html">
    
      Xcode8上继续使用老插件
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>NSURLProtocol总结</title>
    <link href="http://petpwiuta.github.io/2017/09/10/NSURLProtocol%E4%BB%8B%E7%BB%8D/"/>
    <id>http://petpwiuta.github.io/2017/09/10/NSURLProtocol介绍/</id>
    <published>2017-09-10T15:49:45.000Z</published>
    <updated>2017-09-10T15:49:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NSURLProtocol总结"><a href="#NSURLProtocol总结" class="headerlink" title="NSURLProtocol总结"></a>NSURLProtocol总结</h2><p>NSURLProtocol可以说是苹果允许的一个中间人攻击组件，功能非常强大。但是关于NSURLProtocol的官方文档不多，不过业内已经有很多人踩坑，网上相关的文章比较多，这里把网上搜集到的相关文章做一个汇总</p><h3 id="NSURLProtocol介绍"><a href="#NSURLProtocol介绍" class="headerlink" title="NSURLProtocol介绍"></a>NSURLProtocol介绍</h3><p>NSURLProtocol是URL Loading System中的一个模块，能拦截这个系统中发出的所有请求，那具体是哪些类发出的请求呢？<code>NSURLConnection</code>、<code>NSURLSession</code>、<code>UIWebVIew(页面内部的所有请求包括ajax)</code>、<code>WKWebVIew(不能直接拦截，需要hack)</code>，以及基于他们的封装如<code>AFNetworking</code>、<code>Alamofire</code>等都是能拦截的，而基于<code>CFNetwork</code>的请求则不能被拦截</p><p>进行拦截以后可以做非常多的自定义行为，比如说：</p><ul><li>拦截图片加载请求，转为从本地文件加载</li><li>对HTTP返回内容进行mock和stub</li><li>对发出请求的header进行格式化</li><li>对发出的媒体请求进行签名</li><li>创建本地代理服务，用于数据变化时对URL请求的更改</li><li>故意制造畸形或非法返回数据来测试程序的鲁棒性</li><li>过滤请求和返回中的敏感信息</li><li>在既有协议基础上完成对 NSURLConnection 的实现且与原逻辑不产生矛盾</li></ul><h3 id="NSURLProtocol的用法"><a href="#NSURLProtocol的用法" class="headerlink" title="NSURLProtocol的用法"></a>NSURLProtocol的用法</h3><h4 id="新建、注册子类"><a href="#新建、注册子类" class="headerlink" title="新建、注册子类"></a>新建、注册子类</h4><p><code>NSURLProtocol</code>是一个抽象类，必须被子类化之后才能使用，所以要新建一个继承于它的子类。</p><p>基于NSURLConnection或者使用[NSURLSession sharedSession]创建的网络请求，调用registerClass方法即可<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSURLProtocol</span> registerClass:NetworkURLProtocol.class];   <span class="comment">//注册</span></span><br><span class="line">[<span class="built_in">NSURLProtocol</span> unregisterClass:NetworkURLProtocol.class]; <span class="comment">//注销</span></span><br></pre></td></tr></table></figure></p><p>而基于NSURLSession的网络请求，需要通过配置NSURLSessionConfiguration对象的protocolClasses属性来注册。(网络上有<a href="http://tech.lede.com/2017/02/15/rd/iOS/iOS_NSURLProtocol/" target="_blank" rel="noopener">文章</a>说protocolClasses这个数组里只有第一个NSURLProtocol会起作用。并以OHHTTPStubs库为例子，它是在注册先NSURLProtocol插入到protocolClasses的第一个，进行拦截。拦截完成之后又进行移除。这个还没有做实验证实)<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *sessionConfiguration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">sessionConfiguration.protocolClasses = @[NetworkURLProtocol.class];</span><br><span class="line"><span class="comment">//取消注册的话直接把protocol从数组中移除就行</span></span><br></pre></td></tr></table></figure></p><h4 id="重载必要的方法"><a href="#重载必要的方法" class="headerlink" title="重载必要的方法"></a>重载必要的方法</h4><p>(1)当遍历到我们自定义的NSURLProtocol时，系统先会调用<code>canInitWithRequest:</code>这个方法。顾名思义，这是整个流程的入口，只有这个方法返回YES我们才能够继续后续的处理。我们可以在这个方法的实现里面进行请求的过滤，筛选出需要进行处理的请求<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否有已编辑的标识，用来识别是第一次过来的请求还是已经改写过的请求</span></span><br><span class="line">    <span class="built_in">BOOL</span> isEditedRequest = [[<span class="built_in">NSURLProtocol</span> propertyForKey:<span class="string">@"NetworkURLProtocol"</span> inRequest:request] boolValue];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据配置来过滤请求</span></span><br><span class="line">    <span class="built_in">BOOL</span> configDeny = ![[NetworkManager sharedManager].config canCaptureRequest:request];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isEditedRequest || configDeny) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2)<code>canInitWithRequest</code>返回YES后系统会把请求回调到这里。在这里完成请求的编辑/替换工作。需要注意的是系统会以这个方法返回值为参数，再次调用上面说到的<code>canInitWithRequest</code>方法，所以这里一定要添加一些标志变量来区分请求是否被编辑，不然系统就会因为循环调用这两个方法而陷入死循环<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [request mutableCopy];</span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@YES</span><br><span class="line">                        forKey:<span class="string">@"NetworkURLProtocol"</span></span><br><span class="line">                     inRequest:mutableReqeust];</span><br><span class="line">    <span class="keyword">return</span> [mutableReqeust <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(3)处理开始和结束的状态<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Request被编辑完后，系统会调用这个方法，这里一般用来发起请求</span></span><br><span class="line"><span class="comment">//这里方法里一定要有手动发起网络请求的逻辑，否则整个流程就不会往下走</span></span><br><span class="line">- (<span class="keyword">void</span>)startLoading  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:[[<span class="keyword">self</span> <span class="keyword">class</span>] canonicalRequestForRequest:<span class="keyword">self</span>.request] delegate:<span class="keyword">self</span> startImmediately:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求结束后会调用这个方法，在这里取消请求，以及做一些数据处理工作</span></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于判断你的自定义reqeust是否相同，这里返回默认实现即可。主要应用场景是某些直接使用缓存而非再次请求网络的地方。如果不是用来做缓存的话这个方法可以不实现</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> requestIsCacheEquivalent:a toRequest:b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="调用NSURLProtocolClient协议方法"><a href="#调用NSURLProtocolClient协议方法" class="headerlink" title="调用NSURLProtocolClient协议方法"></a>调用NSURLProtocolClient协议方法</h4><p>NSURLProtocol给了一次机会让我们接管请求，我们在完成接管的过程中还是需要向我们的客户端(发起请求的业务代码)提供服务。NSURLProtocol实例中有个<code>id &lt;NSURLProtocolClient&gt; client</code>属性来帮我们做到这一点，我们只需要在合适的时机来调用<code>NSURLProtocolClient</code>协议规定的方法就行。<br>注意我们的模拟行为需要尽可能的和系统保持一致，所以<code>NSURLProtocolClient</code>协议规定的方法最好在对应的时机都要有相应的调用，换句话说就是<code>NSURLProtocolClient</code>协议规定的每一个方法都至少调用一遍</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSURLConnectionDelegate</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">  didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didFailWithError:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)connectionShouldUseCredentialStorage:(<span class="built_in">NSURLConnection</span> *)connection &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge &#123;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didReceiveAuthenticationChallenge:challenge];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">didCancelAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge &#123;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didCancelAuthenticationChallenge:challenge];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSURLConnectionDataDelegate</span></span><br><span class="line">- (<span class="built_in">NSURLRequest</span> *)connection:(<span class="built_in">NSURLConnection</span> *)connection willSendRequest:(<span class="built_in">NSURLRequest</span> *)request redirectResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    <span class="comment">//并非重定向请求才会走这个方法，一般的请求也会回调到这里。如果不做判断话会导致把一般请求当成重定向，而且在ios8.1上会直接崩溃</span></span><br><span class="line">    <span class="keyword">if</span> (response != <span class="literal">nil</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.response = response;</span><br><span class="line">        [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> wasRedirectedToRequest:request redirectResponse:response];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageAllowed</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSCachedURLResponse</span> *)connection:(<span class="built_in">NSURLConnection</span> *)connection willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedResponse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NSURLProtocol的注意事项"><a href="#NSURLProtocol的注意事项" class="headerlink" title="NSURLProtocol的注意事项"></a>NSURLProtocol的注意事项</h3><p>(1) NSURLProtocol多线程问题。有同学可能会想到网络请求中多个request都会走NSURLProtocol的代理方法，那会不会有并发的问题。其实每个网络请求都会实例化一个NSURLProtocol的子类对象，所以每个网络请求之间不会互相影响</p><p>(2) NSURLProtocolClient回调必须跟发起请求的代码发送保持在一个线程、相同的Runloop。这个也很好理解，因为我们的改写逻辑对客户端(一般是业务代码)应该是透明的，所以行为和状态都应该和系统的网络请求框架保持一致：因此我们要在start方法中记录当前线程和Runloop模式。然后在记录的线程以相同的Runloop模式回调NSURLProtocolClient的方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:onThread:withObject:waitUntilDone:modes:];</span><br></pre></td></tr></table></figure></p><p>(3) NSURLSession的POST请求拿不到HTTPBody。苹果官方的解释是Body是NSData类型，而且还没有大小限制。为了性能考虑，拦截时就没有拷贝</p><p>(4) WKWebview不能直接拦截。WKWebView在独立于app进程之外的进程中执行网络请求，请求数据不经过主进程，因此在WKWebView上直接使用NSURLProtocol无法拦截请求。需要hack一下，具体的技术方案请看”<a href="https://blog.yeatse.com/2016/10/26/support-nsurlprotocol-in-wkwebview/" target="_blank" rel="noopener">让WKWebView支持NSURLProtocol</a>“</p><p>(5) 多个NSURLProtocol嵌套使用。若一个项目中存在多个NSURLProtocol，那么NSURLProtocol的拦截顺序跟注册的方式和顺序有关。<br>对于使用registerClass方法注册：多个NSURLProtocol拦截顺序为注册顺序的反序，即后注册的的NSURLProtocol先拦截。<br>对于通过配置NSURLSessionConfiguration对象的protocolClasses属性来注册的：<br>protocolClasses这个数组里据说只有第一个NSURLProtocol会起作用。(还没做实验证实)</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://developer.apple.com/library/content/samplecode/CustomHTTPProtocol/Introduction/Intro.html" target="_blank" rel="noopener">CustomHttpProtocol苹果官方示例</a></li><li><a href="http://blog.csdn.net/jingcheng345413/article/details/54967739" target="_blank" rel="noopener">NSURLProtocol概述</a></li><li><a href="http://tech.lede.com/2017/02/15/rd/iOS/iOS_NSURLProtocol/" target="_blank" rel="noopener">NSURLProtocol全攻略</a></li><li><a href="https://blog.yeatse.com/2016/10/26/support-nsurlprotocol-in-wkwebview/" target="_blank" rel="noopener">让WKWebView支持NSURLProtocol</a></li><li><a href="https://github.com/AliSoftware/OHHTTPStubs" target="_blank" rel="noopener">OHHTTPStubs库</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653578513&amp;idx=1&amp;sn=961bf5394eecde40a43060550b81b0bb&amp;chksm=84b3b716b3c43e00ee39de8cf12ff3f8d475096ffaa05de9c00ff65df62cd73aa1cff606057d&amp;mpshare=1&amp;scene=1&amp;srcid=0214nkrYxApaVTQcGw3U9Ryp" target="_blank" rel="noopener">WKWebView那些坑</a></li></ul>]]></content>
    
    <summary type="html">
    
      NSURLProtocol可以说是苹果允许的一个中间人攻击组件，功能非常强大。但是关于NSURLProtocol的官方文档不多，不过业内已经有很多人踩坑，网上相关的文章比较多，这里把网上搜集到的相关文章做一个汇总
    
    </summary>
    
      <category term="iOS开发" scheme="http://petpwiuta.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
</feed>
