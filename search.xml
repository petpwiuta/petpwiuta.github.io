<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[NSURLProtocol总结]]></title>
      <url>http://yoursite.com/2017/09/10/NSURLProtocol%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="NSURLProtocol总结"><a href="#NSURLProtocol总结" class="headerlink" title="NSURLProtocol总结"></a>NSURLProtocol总结</h2><p>NSURLProtocol可以说是苹果允许的一个中间人攻击组件，功能非常强大。但是关于NSURLProtocol的官方文档不多，不过业内已经有很多人踩坑，网上相关的文章比较多，这里把网上搜集到的相关文章做一个汇总</p>
<h3 id="NSURLProtocol介绍"><a href="#NSURLProtocol介绍" class="headerlink" title="NSURLProtocol介绍"></a>NSURLProtocol介绍</h3><p>NSURLProtocol是URL Loading System中的一个模块，能拦截这个系统中发出的所有请求，那具体是哪些类发出的请求呢？<code>NSURLConnection</code>、<code>NSURLSession</code>、<code>UIWebVIew(页面内部的所有请求包括ajax)</code>、<code>WKWebVIew(不能直接拦截，需要hack)</code>，以及基于他们的封装如<code>AFNetworking</code>、<code>Alamofire</code>等都是能拦截的，而基于<code>CFNetwork</code>的请求则不能被拦截</p>
<p>进行拦截以后可以做非常多的自定义行为，比如说：</p>
<ul>
<li>拦截图片加载请求，转为从本地文件加载</li>
<li>对HTTP返回内容进行mock和stub</li>
<li>对发出请求的header进行格式化</li>
<li>对发出的媒体请求进行签名</li>
<li>创建本地代理服务，用于数据变化时对URL请求的更改</li>
<li>故意制造畸形或非法返回数据来测试程序的鲁棒性</li>
<li>过滤请求和返回中的敏感信息</li>
<li>在既有协议基础上完成对 NSURLConnection 的实现且与原逻辑不产生矛盾</li>
</ul>
<h3 id="NSURLProtocol的用法"><a href="#NSURLProtocol的用法" class="headerlink" title="NSURLProtocol的用法"></a>NSURLProtocol的用法</h3><h4 id="新建、注册子类"><a href="#新建、注册子类" class="headerlink" title="新建、注册子类"></a>新建、注册子类</h4><p><code>NSURLProtocol</code>是一个抽象类，必须被子类化之后才能使用，所以要新建一个继承于它的子类。</p>
<p>基于NSURLConnection或者使用[NSURLSession sharedSession]创建的网络请求，调用registerClass方法即可<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSURLProtocol</span> registerClass:NetworkURLProtocol.class];   <span class="comment">//注册</span></div><div class="line">[<span class="built_in">NSURLProtocol</span> unregisterClass:NetworkURLProtocol.class]; <span class="comment">//注销</span></div></pre></td></tr></table></figure></p>
<p>而基于NSURLSession的网络请求，需要通过配置NSURLSessionConfiguration对象的protocolClasses属性来注册。(网络上有<a href="http://tech.lede.com/2017/02/15/rd/iOS/iOS_NSURLProtocol/" target="_blank" rel="external">文章</a>说protocolClasses这个数组里只有第一个NSURLProtocol会起作用。并以OHHTTPStubs库为例子，它是在注册先NSURLProtocol插入到protocolClasses的第一个，进行拦截。拦截完成之后又进行移除。这个还没有做实验证实)<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *sessionConfiguration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">sessionConfiguration.protocolClasses = @[NetworkURLProtocol.class];</div><div class="line"><span class="comment">//取消注册的话直接把protocol从数组中移除就行</span></div></pre></td></tr></table></figure></p>
<h4 id="重载必要的方法"><a href="#重载必要的方法" class="headerlink" title="重载必要的方法"></a>重载必要的方法</h4><p>(1)当遍历到我们自定义的NSURLProtocol时，系统先会调用<code>canInitWithRequest:</code>这个方法。顾名思义，这是整个流程的入口，只有这个方法返回YES我们才能够继续后续的处理。我们可以在这个方法的实现里面进行请求的过滤，筛选出需要进行处理的请求<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//是否有已编辑的标识，用来识别是第一次过来的请求还是已经改写过的请求</span></div><div class="line">    <span class="built_in">BOOL</span> isEditedRequest = [[<span class="built_in">NSURLProtocol</span> propertyForKey:<span class="string">@"NetworkURLProtocol"</span> inRequest:request] boolValue];</div><div class="line">    </div><div class="line">    <span class="comment">//根据配置来过滤请求</span></div><div class="line">    <span class="built_in">BOOL</span> configDeny = ![[NetworkManager sharedManager].config canCaptureRequest:request];</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (isEditedRequest || configDeny) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(2)<code>canInitWithRequest</code>返回YES后系统会把请求回调到这里。在这里完成请求的编辑/替换工作。需要注意的是系统会以这个方法返回值为参数，再次调用上面说到的<code>canInitWithRequest</code>方法，所以这里一定要添加一些标志变量来区分请求是否被编辑，不然系统就会因为循环调用这两个方法而陷入死循环<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request  </div><div class="line">&#123;  </div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [request mutableCopy];</div><div class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@YES</div><div class="line">                        forKey:<span class="string">@"NetworkURLProtocol"</span></div><div class="line">                     inRequest:mutableReqeust];</div><div class="line">    <span class="keyword">return</span> [mutableReqeust <span class="keyword">copy</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(3)处理开始和结束的状态<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Request被编辑完后，系统会调用这个方法，这里一般用来发起请求</span></div><div class="line"><span class="comment">//这里方法里一定要有手动发起网络请求的逻辑，否则整个流程就不会往下走</span></div><div class="line">- (<span class="keyword">void</span>)startLoading  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:[[<span class="keyword">self</span> <span class="keyword">class</span>] canonicalRequestForRequest:<span class="keyword">self</span>.request] delegate:<span class="keyword">self</span> startImmediately:<span class="literal">YES</span>];</div><div class="line">&#125;</div><div class="line"><span class="comment">//请求结束后会调用这个方法，在这里取消请求，以及做一些数据处理工作</span></div><div class="line">- (<span class="keyword">void</span>)stopLoading</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span>.connection cancel];</div><div class="line">&#125;</div><div class="line"><span class="comment">//用于判断你的自定义reqeust是否相同，这里返回默认实现即可。主要应用场景是某些直接使用缓存而非再次请求网络的地方。如果不是用来做缓存的话这个方法可以不实现</span></div><div class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> requestIsCacheEquivalent:a toRequest:b];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="调用NSURLProtocolClient协议方法"><a href="#调用NSURLProtocolClient协议方法" class="headerlink" title="调用NSURLProtocolClient协议方法"></a>调用NSURLProtocolClient协议方法</h4><p>NSURLProtocol给了一次机会让我们接管请求，我们在完成接管的过程中还是需要向我们的客户端(发起请求的业务代码)提供服务。NSURLProtocol实例中有个<code>id &lt;NSURLProtocolClient&gt; client</code>属性来帮我们做到这一点，我们只需要在合适的时机来调用<code>NSURLProtocolClient</code>协议规定的方法就行。<br>注意我们的模拟行为需要尽可能的和系统保持一致，所以<code>NSURLProtocolClient</code>协议规定的方法最好在对应的时机都要有相应的调用，换句话说就是<code>NSURLProtocolClient</code>协议规定的每一个方法都至少调用一遍</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSURLConnectionDelegate</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</div><div class="line">  didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didFailWithError:error];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)connectionShouldUseCredentialStorage:(<span class="built_in">NSURLConnection</span> *)connection &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</div><div class="line">didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge &#123;</div><div class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didReceiveAuthenticationChallenge:challenge];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</div><div class="line">didCancelAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge &#123;</div><div class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didCancelAuthenticationChallenge:challenge];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSURLConnectionDataDelegate</span></div><div class="line">- (<span class="built_in">NSURLRequest</span> *)connection:(<span class="built_in">NSURLConnection</span> *)connection willSendRequest:(<span class="built_in">NSURLRequest</span> *)request redirectResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</div><div class="line">    <span class="comment">//并非重定向请求才会走这个方法，一般的请求也会回调到这里。如果不做判断话会导致把一般请求当成重定向，而且在ios8.1上会直接崩溃</span></div><div class="line">    <span class="keyword">if</span> (response != <span class="literal">nil</span>)&#123;</div><div class="line">        <span class="keyword">self</span>.response = response;</div><div class="line">        [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> wasRedirectedToRequest:request redirectResponse:response];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> request;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</div><div class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageAllowed</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didLoadData:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSCachedURLResponse</span> *)connection:(<span class="built_in">NSURLConnection</span> *)connection willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse &#123;</div><div class="line">    <span class="keyword">return</span> cachedResponse;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</div><div class="line">    [[<span class="keyword">self</span> client] URLProtocolDidFinishLoading:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="NSURLProtocol的注意事项"><a href="#NSURLProtocol的注意事项" class="headerlink" title="NSURLProtocol的注意事项"></a>NSURLProtocol的注意事项</h3><p>(1) NSURLProtocol多线程问题。有同学可能会想到网络请求中多个request都会走NSURLProtocol的代理方法，那会不会有并发的问题。其实每个网络请求都会实例化一个NSURLProtocol的子类对象，所以每个网络请求之间不会互相影响</p>
<p>(2) NSURLProtocolClient回调必须跟发起请求的代码发送保持在一个线程、相同的Runloop。这个也很好理解，因为我们的改写逻辑对客户端(一般是业务代码)应该是透明的，所以行为和状态都应该和系统的网络请求框架保持一致：因此我们要在start方法中记录当前线程和Runloop模式。然后在记录的线程以相同的Runloop模式回调NSURLProtocolClient的方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> performSelector:onThread:withObject:waitUntilDone:modes:];</div></pre></td></tr></table></figure></p>
<p>(3) NSURLSession的POST请求拿不到HTTPBody。苹果官方的解释是Body是NSData类型，而且还没有大小限制。为了性能考虑，拦截时就没有拷贝</p>
<p>(4) WKWebview不能直接拦截。WKWebView在独立于app进程之外的进程中执行网络请求，请求数据不经过主进程，因此在WKWebView上直接使用NSURLProtocol无法拦截请求。需要hack一下，具体的技术方案请看”<a href="https://blog.yeatse.com/2016/10/26/support-nsurlprotocol-in-wkwebview/" target="_blank" rel="external">让WKWebView支持NSURLProtocol</a>“</p>
<p>(5) 多个NSURLProtocol嵌套使用。若一个项目中存在多个NSURLProtocol，那么NSURLProtocol的拦截顺序跟注册的方式和顺序有关。<br>对于使用registerClass方法注册：多个NSURLProtocol拦截顺序为注册顺序的反序，即后注册的的NSURLProtocol先拦截。<br>对于通过配置NSURLSessionConfiguration对象的protocolClasses属性来注册的：<br>protocolClasses这个数组里据说只有第一个NSURLProtocol会起作用。(还没做实验证实)</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://developer.apple.com/library/content/samplecode/CustomHTTPProtocol/Introduction/Intro.html" target="_blank" rel="external">CustomHttpProtocol苹果官方示例</a></li>
<li><a href="http://blog.csdn.net/jingcheng345413/article/details/54967739" target="_blank" rel="external">NSURLProtocol概述</a></li>
<li><a href="http://tech.lede.com/2017/02/15/rd/iOS/iOS_NSURLProtocol/" target="_blank" rel="external">NSURLProtocol全攻略</a></li>
<li><a href="https://blog.yeatse.com/2016/10/26/support-nsurlprotocol-in-wkwebview/" target="_blank" rel="external">让WKWebView支持NSURLProtocol</a></li>
<li><a href="https://github.com/AliSoftware/OHHTTPStubs" target="_blank" rel="external">OHHTTPStubs库</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653578513&amp;idx=1&amp;sn=961bf5394eecde40a43060550b81b0bb&amp;chksm=84b3b716b3c43e00ee39de8cf12ff3f8d475096ffaa05de9c00ff65df62cd73aa1cff606057d&amp;mpshare=1&amp;scene=1&amp;srcid=0214nkrYxApaVTQcGw3U9Ryp" target="_blank" rel="external">WKWebView那些坑</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS平台Webview和原生代码交互]]></title>
      <url>http://yoursite.com/2017/02/20/iOS%E5%B9%B3%E5%8F%B0Webview%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BB%A3%E7%A0%81%E4%BA%A4%E4%BA%92/</url>
      <content type="html"><![CDATA[<h1 id="iOS平台Webview和原生代码交互"><a href="#iOS平台Webview和原生代码交互" class="headerlink" title="iOS平台Webview和原生代码交互"></a>iOS平台Webview和原生代码交互</h1><p>最近遇到很多原生和前端进行交互的业务逻辑，前前后后做了一些调研。现在把常用的方法总结一下。<br>前端和原生交互大致分为这几种方式:拦截URL、WKWebView、JavaScriptCore，下面来分别说一下这几种方式的实现以及优缺点。</p>
<h2 id="1-拦截URL"><a href="#1-拦截URL" class="headerlink" title="1.拦截URL"></a>1.拦截URL</h2><h3 id="1-1-通过Webview的委托方法拦截"><a href="#1-1-通过Webview的委托方法拦截" class="headerlink" title="1.1 通过Webview的委托方法拦截"></a>1.1 通过Webview的委托方法拦截</h3><p>UIWebview<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(<span class="type">BOOL</span>)webView:(<span class="type">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="type">NSURLRequest</span> *)request navigationType:(<span class="type">UIWebViewNavigationType</span>)navigationType</div><div class="line">&#123;</div><div class="line">    <span class="type">NSString</span> *url = request.<span class="type">URL</span>.absoluteString;</div><div class="line">	<span class="comment">//判断url特征，进行对应的逻辑处理</span></div><div class="line">    <span class="keyword">return</span> <span class="type">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WKWebview<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(void)webView:(<span class="type">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="type">WKNavigationAction</span> *)navigationAction decisionHandler:(void (^)(<span class="type">WKNavigationActionPolicy</span>))decisionHandler</div><div class="line">&#123;</div><div class="line">    <span class="type">NSString</span> *url = navigationAction.request.<span class="type">URL</span>.absoluteString;</div><div class="line">    <span class="comment">//判断url特征，进行对应的逻辑处理</span></div><div class="line">    decisionHandler(<span class="type">WKNavigationActionPolicyAllow</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>优势：实现简单方便</li>
<li>缺点：如果是用GET请求的话在原生和webview之间传参会有长度限制。而POST请求的话需要只能在UIWebview上才能获取到请求体，在WKWebview里面是无法获取到POST请求体的。</li>
</ul>
<h3 id="1-2-使用WebViewJavascriptBridge"><a href="#1-2-使用WebViewJavascriptBridge" class="headerlink" title="1.2 使用WebViewJavascriptBridge"></a>1.2 使用WebViewJavascriptBridge</h3><p>这个是iOS上使用的比较多的js交互框架，也是基于拦截URL的方式来实现的。不过在自己公司项目中用的不多，所以没有做深入的了解。</p>
<h3 id="1-3-通过NSURLProtocol拦截"><a href="#1-3-通过NSURLProtocol拦截" class="headerlink" title="1.3 通过NSURLProtocol拦截"></a>1.3 通过NSURLProtocol拦截</h3><p>这个是利用了NSURLProtocol会拦截webview的网络请求而实现的，本质上和通过Webview的委托方法拦截差不多。不过据说WKWebView貌似不支持NSURLProtocol，没有做实验，具体是否可行还需要测试。</p>
<h2 id="2-WKWebView"><a href="#2-WKWebView" class="headerlink" title="2.WKWebView"></a>2.WKWebView</h2><p>iOS8，苹果新推出了WebKit，用WKWebView代替UIWebView和WebView。相关的使用和特性可以细读<a href="http://nshipster.cn/wkwebkit/" target="_blank" rel="external">WKWebView</a>和<a href="http://www.appcoda.com/webkit-framework-intro/" target="_blank" rel="external">A Look at the WebKit</a>、<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView那些坑</a>(林泽水原创发表在bugly公众号上的一篇文章，基本上把它的缺陷都点出来了，入坑前必读)。</p>
<p>优点:功能比UIWebview强大很多，调用js的时候可以返回对象以及错误状态；而且js也可以直接反向回调<br>缺点:WKWebview的坑很多，参见上一段落提到的“<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebview那些坑</a>”</p>
<ul>
<li><p>App调用js<br>WKWebView调用js方法和UIWebView类似，一个是<code>evaluateJavaScript</code>，一个是<code>stringByEvaluatingJavaScriptFromString</code>。不过获取返回值的方式不同，WKWebView用的是闭包回调;UIWebview返回的是一个string。</p>
</li>
<li><p>js调用App<br>UIWebView中js是没办法直接回调App的(只能用url的方式间接回调)，而在WKWebView中有了改进。具体步骤分为App注册handler，js调用，App处理handler委托三个步骤</p>
<ol>
<li><p>注册handler</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">config = <span class="type">WKWebViewConfiguration</span>()</div><div class="line"> <span class="comment">//注册js方法</span></div><div class="line">config.userContentController.addScriptMessageHandler(<span class="keyword">self</span>, name: <span class="string">"WebApp"</span>)</div><div class="line"> <span class="comment">// 初始化</span></div><div class="line">webView = <span class="type">WKWebView</span>(frame: <span class="keyword">self</span>.webWrap.frame, configuration: config)</div></pre></td></tr></table></figure>
</li>
<li><p>js调用<br>通过window.webkit.messageHandlers.WebApp找到之前注册的handler对象，然后调用postMessage方法把数据传到WebApp通过上一步的方法解析方法名和参数。WebApp是之前注册的name。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = &#123;</div><div class="line">                 'method' : 'hello',</div><div class="line">                 'param1' : 'liuyanwei',</div><div class="line">               &#125;;</div><div class="line"> window.webkit.messageHandlers.<span class="type">WebApp</span>.postMessage(message);</div></pre></td></tr></table></figure>
</li>
<li><p>处理handler委托<br>之前初始化Webview时指定的MessageHandler要实现WKScriptMessageHandler的协议方法<code>userContentController(userContentController: WKUserContentController, didReceiveScriptMessage message: WKScriptMessage)</code>然后在这里面处理事件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">userContentController</span><span class="params">(<span class="number">_</span> userContentController: WKUserContentController, didReceive message: WKScriptMessage)</span></span> &#123;</div><div class="line">       <span class="comment">//根据传过来数据从而决定app调用的方法</span></div><div class="line">       <span class="keyword">let</span> dict = message.body <span class="keyword">as</span>! <span class="type">Dictionary</span>&lt;<span class="type">String</span>,<span class="type">Any</span>&gt;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="3-JavaScriptCore"><a href="#3-JavaScriptCore" class="headerlink" title="3.JavaScriptCore"></a>3.JavaScriptCore</h2><p>JavaScriptCore中类及协议：<br>JSContext：给JavaScript提供运行的上下文环境,通过-evaluateScript:方法就可以执行js代码<br>JSValue：封装了js与OC中的对应的类型，以及调用js的API等<br>JSManagedValue：管理数据和方法的类<br>JSVirtualMachine：处理线程相关，使用较少<br>JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议，在协议中声明的API都会在js中暴露出来，才能调用</p>
<ul>
<li><p>OC调用js<br>在JavaScriptCore中提供的调用js的方法<code>-(JSValue *)evaluateScript:(NSString *)script</code>方法就可以执行一段JavaScript脚本，并且如果其中有方法、变量等信息都会被存储在其中以便在需要的时候使用。<br>JSValue提供了<code>-(JSValue *)callWithArguments:(NSArray *)arguments</code>方法来将参数传进去调用方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个JSContext对象，就类似于js中的window</span></div><div class="line"> <span class="comment">// 只需要创建一次即可。</span></div><div class="line"><span class="type">JSContext</span> *context = [[<span class="type">JSContext</span> alloc] <span class="keyword">init</span>];</div><div class="line"><span class="comment">// 执行一段js</span></div><div class="line">[context evaluateScript:@<span class="string">"function add(a, b) &#123; return a + b; &#125;"</span>];</div><div class="line"><span class="comment">// 根据下标取出方法</span></div><div class="line"><span class="type">JSValue</span> *add = context[@<span class="string">"add"</span>];</div><div class="line"><span class="type">NSLog</span>(@<span class="string">"Func: %@"</span>, add);</div><div class="line"><span class="comment">// 传入参数 调用取到的方法</span></div><div class="line"><span class="type">JSValue</span> *sum = [add callWithArguments:@[@(<span class="number">7</span>), @(<span class="number">21</span>)]];</div><div class="line"><span class="type">NSLog</span>(@<span class="string">"Sum: %d"</span>,[sum toInt32]);</div><div class="line"><span class="comment">//OutPut:</span></div><div class="line"><span class="comment">// Func: function add(a, b) &#123; return a + b; &#125;</span></div><div class="line"><span class="comment">// Sum: 28</span></div></pre></td></tr></table></figure>
</li>
<li><p>js调用OC<br>使用JavaScriptCore在JS端调用原生代码的时候主要有两种方式：block和方法注入。</p>
<ol>
<li><p>Block方式</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    <span class="type">JSContext</span> *context = [[<span class="type">JSContext</span> alloc] <span class="keyword">init</span>];</div><div class="line">	<span class="comment">// 定义一个block</span></div><div class="line">	context[@<span class="string">"log"</span>] = ^() &#123;</div><div class="line">  	  <span class="type">NSArray</span> *args = [<span class="type">JSContext</span> currentArguments];</div><div class="line">    	<span class="keyword">for</span> (<span class="type">JSValue</span> *jsVal <span class="keyword">in</span> args) &#123;</div><div class="line">  	 		<span class="type">NSLog</span>(@<span class="string">"%@"</span>, jsVal);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="type">JSValue</span> *this = [<span class="type">JSContext</span> currentThis];</div><div class="line">		<span class="type">NSLog</span>(@<span class="string">"this: %@"</span>,this);</div><div class="line">		<span class="type">NSLog</span>(@<span class="string">"-------End Log-------"</span>);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 调用js执行log方法</span></div><div class="line"> [context evaluateScript:@<span class="string">"log('ider', [7, 21],&#123; hello:'world', js:100 &#125;);"</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>OC方法注入<br>这里需要原生自定义一个协议，并且它还需要遵守JSExport协议。协议里的方法，就是暴露给js端的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@<span class="class"><span class="keyword">protocol</span> <span class="title">JavaScriptObjectiveCDelegate</span> &lt;<span class="title">JSExport</span>&gt;</span></div><div class="line">-(<span class="title">void</span>)<span class="title">callWithDict</span>:(<span class="title">NSDictionary</span> *)<span class="title">params</span>;</div><div class="line">@<span class="title">end</span></div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>然后自定义一个对象，让这个对象来实现上面所说的协议<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 此模型用于注入JS的模型，这样就可以通过模型来调用方法。</span></div><div class="line">@interface <span class="type">HYBJsObjCModel</span> : <span class="type">NSObject</span> &lt;<span class="type">JavaScriptObjectiveCDelegate</span>&gt;</div><div class="line">@property (nonatomic, <span class="keyword">weak</span>) <span class="type">JSContext</span> *jsContext;</div><div class="line">@property (nonatomic, <span class="keyword">weak</span>) <span class="type">UIWebView</span> *webView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation <span class="type">HYBJsObjCModel</span></div><div class="line">- (void)callWithDict:(<span class="type">NSDictionary</span> *)params &#123;</div><div class="line"> <span class="type">NSLog</span>(@<span class="string">"Js调用了OC的方法，参数为：%@"</span>, params);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>对象实现完了，在哪里注入呢。在controller的webView加载完成后我们是通过webView的valueForKeyPath获取的，其路径为documentView.webView.mainFrame.javaScriptContext。这样就可以获取到js的context，然后为这个context注入我们的模型对象。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)webViewDidFinishLoad:(<span class="type">UIWebView</span> *)webView </div><div class="line">&#123;</div><div class="line"> <span class="keyword">self</span>.jsContext = [webView valueForKeyPath:@<span class="string">"documentView.webView.mainFrame.javaScriptContext"</span>];</div><div class="line">  <span class="comment">// 通过模型调用方法，这种方式更好些。</span></div><div class="line">  <span class="type">HYBJsObjCModel</span> *model  = [[<span class="type">HYBJsObjCModel</span> alloc] <span class="keyword">init</span>];</div><div class="line">  <span class="comment">// 模型</span></div><div class="line">  <span class="keyword">self</span>.jsContext[@<span class="string">"OCModel"</span>] = model;</div><div class="line">  model.jsContext = <span class="keyword">self</span>.jsContext;</div><div class="line">  model.webView = <span class="keyword">self</span>.webView;</div><div class="line">  <span class="comment">// 增加异常的处理</span></div><div class="line">  <span class="keyword">self</span>.jsContext.exceptionHandler = ^(<span class="type">JSContext</span> *context,   </div><div class="line"> <span class="type">JSValue</span> *exceptionValue) &#123;</div><div class="line">    context.exception = exceptionValue;</div><div class="line">    <span class="type">NSLog</span>(@<span class="string">"异常信息：%@"</span>, exceptionValue);</div><div class="line"> &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的在js端调用的代码如下<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 100px"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>OC方法注入<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Call OC method"</span> <span class="attr">onclick</span>=<span class="string">"OCModel.callWithDict()"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>JavaScript调用本地方法是在子线程中执行的，这里要根据实际情况考虑线程之间的切换。</p>
<h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考:"></a>相关参考:</h2><ul>
<li><a href="http://www.jianshu.com/p/0042d8eb67c0" target="_blank" rel="external">WebView与JS的几种交互</a></li>
<li><a href="http://www.jianshu.com/p/f896d73c670a" target="_blank" rel="external">Objective-C与JavaScript交互的那些事</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《HTTP权威指南》笔记]]></title>
      <url>http://yoursite.com/2017/02/06/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h1 id="《HTTP权威指南》"><a href="#《HTTP权威指南》" class="headerlink" title="《HTTP权威指南》"></a>《HTTP权威指南》</h1><h3 id="第一部分-HTTP：Web的基础"><a href="#第一部分-HTTP：Web的基础" class="headerlink" title="第一部分 HTTP：Web的基础"></a>第一部分 HTTP：Web的基础</h3><h4 id="2-URL与资源"><a href="#2-URL与资源" class="headerlink" title="2 URL与资源"></a>2 URL与资源</h4><p>在Web和URL出现之前,人们要靠分类杂乱的应用程序来访问分布在网络中的数据。大多数人都不会幸运地拥有所有合适的应用程序,或者不能够理解,也没有足够的耐心来使用这些程序。</p>
<p>在URL出现之前,要想和朋友共享complete-catalog.xls文件,就得说这样一些话:“用FTP连接到 ftp.joes-hardware.com上。用匿名登录,然后输入你的用户名作为密码。变换到pub目录。转换为二进制模式。现在,可以将名为complete-catalog.xls的文件下载到本地文件系统,并在那里浏览这个文件了。”</p>
<p>现在,像网景的Navigator和微软的Internet Explorer这样的浏览器都将很多这样的功能捆绑成一个便捷包。通过URL,这些应用程序就可以通过一个接口,以统一的方式去访问许多资源了。只要说“将浏览器指向 ftp://ftp.lots-o-books.com/pub/complete-catalog.xls”就可以取代上面那些复杂的指令了。</p>
<p>URL 为应用程序提供了一种访问资源的手段。实际上,很多用户可能都不知道他们的浏览器在获取所请求资源时所使用的协议和访问方法。</p>
<p>有了Web浏览器,就不再需要用新闻阅读器来阅读因特网新闻,或者用FTP客户端来访问FTP服务器上的文件了,而且也无需用电子邮件程序来收发E-mail报文了。URL告知浏览器如何对资源进行访问和处理,这有助于简化复杂的网络世界。应用程序可以使用URL来简化信息的访问过程。</p>
<p>URL为用户及他们的浏览器提供了找到信息所需的所有条件。URL定义了用户所需的特定资源,它位于何处以及如何获取它。</p>
<h4 id="3-HTTP报文结构"><a href="#3-HTTP报文结构" class="headerlink" title="3 HTTP报文结构"></a>3 HTTP报文结构</h4><ul>
<li>HTTP报文由起始行、首部和报文体(可选)组成</li>
<li>HTTP的方法除了GET以外还有很多种，HEAD是代表让服务器只返回首部，一般用于查看资源的状态、尺寸、类型、是否存在等 。PUT是就是让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档,或者,如果那个URL已经存在的话,就用这个主体来替代它。Trace是用于诊断，收到Trace请求的服务端会把收到的请求完整地回传给客户端。OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法,或者对某些特殊资源支持哪些方法。服务端的响应中的Allow首部会列出所有支持的方法</li>
<li>HTTP的方法是可以扩展的，只要服务端能正常理解和反馈就行</li>
<li>常见状态码：1xx，信息状态码；2xx，成功状态码；3xx重定向状态码、注意当服务端有缓存内容的时候也会返回重定向状态码；4xx客户端错误码；5xx服务端错误码</li>
<li>HTTP的首部就是key-val形式的信息、可以分为通用、请求、响应、实体状态描述等几个大类</li>
</ul>
<h4 id="4-HTTP链接管理"><a href="#4-HTTP链接管理" class="headerlink" title="4 HTTP链接管理"></a>4 HTTP链接管理</h4><ul>
<li>TCP/IP是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集。TCP会把数据拆解成多个分组然后封装成IP数据包发送</li>
<li>一个IP数据包通常包含了一个IP分组首部(通常为20字节); 一个TCP段首部(通常为 20 字节); 一个TCP数据块(0 个或多个字节)。IP 首部包含了源和目的IP地址、长度和其他一些标记。TCP段的首部包含了TCP端口号、TCP 控制标记,以及用于数据排序和完整性检查的一些数字值</li>
<li>HTTP的延迟主要由于以下几个原因造成：（1）DNS查询没有命中 （2）TCP握手 （3）HTTP报文传输 （4）回送HTTP响应</li>
<li>TCP握手：（1）发送SYN=i （2）回送ACK=i+1，SYN=k （3）再发送ACK=k+1，以及载荷数据</li>
<li>延迟确认：在接收方接收到数据后都要发送回执，这个回执会在一定的窗口期(100-200ms)内寻找发送到接收方的数据包来搭便车。所以如果在一段时间内都是单项数据传输的话，可能会因此产生延迟确认现象</li>
<li>TCP慢启动：为了防止网络突然拥堵，TCP实现了慢启动机制。一个TCP连接会随着它成功发送的数据量的增大而提速</li>
<li>TCP的TCP_NODELAY参数：在TCP连接中尽量要发送全尺寸数据（局域网中是1500字节，广域网中为几百字节），所以TCP会启用Nagle算法来尽量把数据赞起来直到达到一个全尺寸的数据包为止。这里就会因为攒数据而产生延迟</li>
<li>当某个TCP端点关闭TCP连接时,会在内存中维护一个小的控制块,用来记录最近所关闭连接的IP地址和端口号。TIME_WAIT端口耗尽是很严重的性能问题,会影响到性能基准,但在现实中相对较少出现</li>
<li>对HTTP对应的TCP进行优化的方案：</li>
<li>并行连接：浏览器并发发起HTTP请求</li>
<li>TCP持久连接：HTTP1.1中默认使用了持久连接。而在HTTP1.0中需要加上Connection: Keep-Alive 首部</li>
<li>管道化连接：现在HTTP1.1中还可以在持久的TCP链接上发送多个请求</li>
</ul>
<h3 id="第二部分-HTTP结构"><a href="#第二部分-HTTP结构" class="headerlink" title="第二部分 HTTP结构"></a>第二部分 HTTP结构</h3><h4 id="5-Web服务器"><a href="#5-Web服务器" class="headerlink" title="5 Web服务器"></a>5 Web服务器</h4><ul>
<li>高性能的Web服务器能够同时支持数千条连接。 因为请求可能会在任意时刻到达,所以Web服务器会不停地观察有无新的Web请求。不同的Web服务器结构会以不同的方式为请求服务。服务器一般分为一下几种：（1）单线程Web服务器（2）多进程及多线程Web服务器 （3）复用 I/O 的服务器（4）复用的多线程Web服务器</li>
</ul>
<h4 id="7-缓存"><a href="#7-缓存" class="headerlink" title="7 缓存"></a>7 缓存</h4><ul>
<li>缓存命中、再验证命中。再验证命中需要向服务端请求数据，如果没有改变就是回传一个304、如果改变了就回传新内容并更新缓存、如果资源被删除就返回404并删除缓存</li>
<li>缓存在现实中是分层次的，如果小的缓存没有命中会把请求发向父级缓存</li>
<li>HTTP的资源附带有过期日期，它是通过Cache-Control首部和Expires 首部告知客户端。当缓存在过期日期之内可以无限次使用缓存，如果过期则会进行再验证。验证如果发现内容没有变化会获取新的首部（包含新的过期日期）</li>
<li>条件方法进行再验证：If-Modified-Since:日期  和 If-None-Match:ETag首部</li>
<li>ETag是为了解决经常被修改，但是文件本身内容却不会变化或者变化不大的情况。这时候通过Etag给资源一个标示符，然后通过标示符来检测文档是否变化</li>
<li>响应首部Cache-Control的取值:no-store禁止存储副本、no-cache会存储副本，但是只有进行再验证后才会回送、must-revalidate、max-age</li>
</ul>
<h3 id="第三部分-识别、认证与安全"><a href="#第三部分-识别、认证与安全" class="headerlink" title="第三部分 识别、认证与安全"></a>第三部分 识别、认证与安全</h3><ul>
<li>Cookies。服务端在相应首部使用Set-cookie可以让浏览器在本地设置Cookies</li>
<li>HTTP提供了一个原生的质询 / 响应(challenge/response)框架,简化了对用户的认<br>证过程。 但是这个认证安全性太弱了，所以现在提出了摘要认证。不过这个摘要认证的安全性也比较弱</li>
<li>数字签名。RSA的私钥和公钥可以互相加解密，RSA证明了签名的作者，而摘要算法保证了内容的真实性</li>
<li>数字证书的真实性由数字签名保证，而数字证书的作用是清晰而真实地公开一个实体所持有的RSA公钥</li>
<li>不要在自己的系统里面轻易的安装非CA签发的证书</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[What's New in iOS]]></title>
      <url>http://yoursite.com/2016/09/16/What's-New-in-iOS10/</url>
      <content type="html"><![CDATA[<p>iOS10出现了很多新特性，这些新特性在官方的《What’s New in iOS》文章中做了一个综合性的简介。作为iOS开发者有必要对系统的新特性做一下跟进，所以就把上述提到的那篇文章翻译了一下，希望能对大家有所帮助！</p>
<h2 id="What’s-New-in-iOS"><a href="#What’s-New-in-iOS" class="headerlink" title="What’s New in iOS"></a>What’s New in iOS</h2><p>这篇文章汇总了在iOS10上引入的关于开发方面的重要新特性，也讲了一些关于新特性的细节。</p>
<p>如果想了解最前沿的新闻和已知的issues可以去看<a href="https://developer.apple.com/ios/download/" target="_blank" rel="external">iOS10 Release Notes</a>。至于iOS10新APIs列表，可以看<a href="https://developer.apple.com/library/content/releasenotes/General/iOS10APIDiffs/index.html" target="_blank" rel="external">iOS 10.0 API Diffs</a>。想了解新设备的细节可以去看<a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="external">iOS Device Compatibility Reference</a>。</p>
<p>关于Swift的更新可以看<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/WhatsNewXcode/introduction.html#//apple_ref/doc/uid/TP40004635-SW3" target="_blank" rel="external">Swift Language</a>和<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external">The Swift Programming Language (Swift 3)</a>。</p>
<h3 id="触觉反馈"><a href="#触觉反馈" class="headerlink" title="触觉反馈"></a>触觉反馈</h3><p>在iPhone7和iPhone 7plus上，触觉反馈是一种获取用户注意力和增加交互沉浸感的新方式(可以理解为Force Touch的进一步运用。译者注)，像系统提供的pickers、switches和sliders都已经具有了触觉反馈特性。</p>
<p>UIKit引入了<code>UIFeedbackGenerator</code>类以及相关的3个子类来提供触觉反馈功能，不同的子类对应不同的触觉反馈场景，详情见下表。</p>
<p><img src="/images/Haptic-feedback.png" alt=""></p>
<p>另外你可以调用UIFeedbackGenerator的实例方法<code>prepare</code>来通知系统在经过一小段延迟后生成触觉反馈。</p>
<h3 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h3><p>Siri现在可以和App集成在一起了，不过只能支持特定类型的App。App集成Siri的方式是用<code>Intents</code>和<code>Intents UI frameworks</code>建立一个或多个应用扩展。下面是Siri支持的App类型：</p>
<ul>
<li>音频视频电话</li>
<li>短信</li>
<li>支付</li>
<li>照片搜索</li>
<li>打车</li>
<li>锻炼(可能是让手机开始记录你的健身活动，译者注)</li>
<li>调整设置(只能在支持CarPlay的汽车上，这个是提供给汽车厂商的)</li>
<li>预定餐厅(需要Apple的额外支持)</li>
</ul>
<p>当用户的Siri指令涉及到你的服务时，SiriKit会给你的App扩展发送一个<code>Intent</code>对象，它描述了用户的指令以及相关的信息。你需要根据<code>Intent</code>对象做出具体处理用户指令的应答。一般情况下Siri会接管所有的用户交互，但你也可以自定义UI来显示更多的信息以及增加品牌曝光 。</p>
<p>SiriKit提供了一个接收App内部发生的交互和活动数据的机制。并定义了一个interaction的对象，这个对象包含了之前说到的<code>Intent</code>对象以及诸如指令开始处理的时刻和持续时间等<code>intent-handling</code>过程的信息。如果App注册的可处理的活动类型刚好与用户的intent同名，即使你没有开发Siri应用扩展，系统也会启动你的App，并发送相关的Siri事件信息。</p>
<p>虽说用户通过地图App和Siri都可以打车，而且还能在地图App里订餐。但你的Intent扩展无论是处理从地图App发起的请求还是从Siri发起的，其方式完全一样。当然，你如果是自定义UI的话，仍可以根据不同的来源定制不同的UI。</p>
<p>想进一步了解SiriKit并给用户一种新方式使用你的服务，可以看<a href="https://developer.apple.com/library/content/documentation/Intents/Conceptual/SiriIntegrationGuide/index.html#//apple_ref/doc/uid/TP40016875" target="_blank" rel="external">SiriKit Programming Guide</a>。想了解如何开发<code>Intents</code>扩展可以看<a href="https://developer.apple.com/reference/intents" target="_blank" rel="external">Intents Framework Reference</a>和<a href="https://developer.apple.com/reference/intentsui" target="_blank" rel="external">Intents UI Framework Reference</a>。</p>
<h3 id="基于场景的智能推荐"><a href="#基于场景的智能推荐" class="headerlink" title="基于场景的智能推荐"></a>基于场景的智能推荐</h3><p>iOS10引入了一种新的方式来增加用户体验，那就是基于场景的智能推荐。如果你提供适当的场景信息的话，系统就可以在合适的时机展示你的App。如果你曾适配过iOS9的App搜索，你就明白如何通过Spotlight、Safari搜索结果、Handoff和Siri建议来展示App内容数据。在iOS10以后，你可以提供用户在App内的活动信息来帮助系统在其他地方展示你的App，例如键盘的词汇联想区、地图、CarPlay、应用切换列表(双击Home键切换应用的那个界面，译者注)、Siri交互界面和锁屏界面(仅对音视频App)。这些和系统深度整合的功能由NSUserActivity，Web<br>markup，Core Spotlight、MapKit、UIKit和Media Player等技术提供。</p>
<p>在iOS10，NSUserActivity对象包含了mapItem属性，它能让你提供用于其他场景的位置信息。例如，你的App显示了一个酒店的信息，你可以在mapItem属性里保存酒店的地理位置信息，当用户切换到一个行程规划App中时，你刚刚保存的酒店地理位置信息会自动提供给它。如果你的App支持应用内搜索，你可以在CSSearchableItemAttributeSet中使用新的基于文本的地址属性，比如<code>thoroughfare</code>和<code>postalCode</code>，来完整地描述用户想去的地理位置。另外注意当你使用mapItem属性时，系统会自动把它的内容填充到contentAttributeSet属性中。</p>
<p>如果要共享一个地理位置信息给系统的话，一定要提供经纬度信息，以及指定CSSearchableItemAttributeSet中的地址属性。另外也建议提供 namedLocation属性，用户能看到位置的名字当然是最好的；此外还有phoneNumbers属性，如果指定了它的值的话，用户可以直接用Siri拨打这个电话。</p>
<p>在iOS9上，给应用内容的镜像站点上添加Web Markup信息可以让用户在Spotlight和Safari搜索结果中直接查看App的内容数据。在iOS10上你可以使用定义在Schema.org上的地理位置相关的词汇，如PostalAddress来进一步提高用户体验。例如，当用户查看你的网站上显示的一个位置时，如果用户切换到地图应用，系统会自动显示这个位置的提示。对于Schema.org上的词汇，Safari同时支持JSON-LD和Micordata编码。</p>
<p>UIKit在UITextInputTraits协议中引入了textContentType属性。你可以告诉系统希望用户在文本框所输入内容的含义。当你提供了这些信息以后，系统能在某些场合自动切换到适当类型的键盘以及增进智能推荐的效果。例如，如果你指定UITextContentTypeFullStreetAddress属性来告诉系统你希望用户输入的是一个地址，系统就会自动提示用户最近所浏览的地址信息。</p>
<p>如果你是媒体播放器类型的App，并且使用了<code>MPPlayableContentManager</code>APIs，在iOS10以后，能让用户在锁屏界面就直接通过你的App播放媒体。</p>
<p>如果你是ride-sharing类型的App，并且使用了<code>MKDirectionsRequest</code>API，iOS10以后，当用户想开始行程时能在应用切换界面显示这个App。想要注册ride-share provider，只需要在Info.plist文件中增加<code>MKDirectionsApplicationSupportedModes</code>字段并把值设为<code>MKDirectionsModeRideShare</code>就可以了。如果你的App仅仅支持ride sharing，系统显示的建议的文字会以“Get a ride to…”开头；如果你的App同时支持ride sharing和其他种类的交通路线(比如骑行或者驾车)系统显示的建议的文字会以“Get directions to…”开头。注意你接收到的MKMapItem对象可能不包含经纬度信息，需要手动获取。</p>
<h3 id="Messages-App扩展"><a href="#Messages-App扩展" class="headerlink" title="Messages App扩展"></a>Messages App扩展</h3><p>在iOS10后，你可以创建和Messages App进行交互的App扩展。它能让用户发送文本、表情、媒体文件以及已读反馈。如果把扩展标记为<code>#images</code>类型，那扩展内的表情(图片)资源就会成为公开的，苹果可以对这些公开的表情进行索引和热度排行。</p>
<p>Messages App的扩展有下面两种：</p>
<ul>
<li>表情包</li>
<li>在Messages App内能展现自定义UI的<code>iMessage app</code>，能让用户浏览表情、文本和媒体文件，并创建、发送以及更新消息</li>
</ul>
<p><code>iMessage app</code>可以让用户直接在Messages App内部直接搜索应用内容的镜像站点上的图片。</p>
<p>创建表情包很简单根本不用敲代码，只要在Xcode里把表情包图片文件夹拖到asset catalog中就行了。</p>
<p>开发一个<code>iMessage app</code>需要使用<code>Messages.framework</code>，Messages framework的详细信息参见<a href="https://developer.apple.com/reference/messages" target="_blank" rel="external">Messages Framework Reference</a>。至于如何创建一个扩展可以看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="external">App Extension Programming Guide</a>。</p>
<p><code>#images app</code>展示了当前最火的表情。你在扩展中公开的表情资源经过苹果的爬虫(如Applebot)收录后会被展示到<code>#images app</code>里。经过下面这几个步骤就能把扩展注册为<code>#images app</code>类型：</p>
<ul>
<li>创建一个<code>iMessage app</code></li>
<li>在app的entitlements里添加<code>com.apple.developer.associated-domains</code>字段。包含了你想要被收录的表情(图片)所在的站点的域名列表。每个域名都需要以<code>spotlight-image-search</code>开头，例如<code>spotlight-image-search:yourdomain.com</code></li>
<li>表情(图片)所在的站点上添加一个以<code>apple-app-site-association</code>命名的字典文件(key-val结构，比如json，译者注)。里面需要包含你的app ID(以team ID或者app ID为前缀)和bundle ID。一个<code>#images</code>索引最多能包含500个paths和patterns(website paths的例子可以看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW4" target="_blank" rel="external">Creating and Uploading the Association File</a>)</li>
<li>允许Applebot进行收录(参见<a href="https://support.apple.com/en-us/HT204683" target="_blank" rel="external">About Applebot</a>)</li>
</ul>
<h3 id="推送通知"><a href="#推送通知" class="headerlink" title="推送通知"></a>推送通知</h3><p>iOS10引入了全新的推送通知框架(UserNotifications.framework)，它统一了本地通知和远程推送通知。你可以用新框架根据时间和地点等条件触发的本地通知。现在这个框架还能在设备收到通知后让你拦截和修改通知的内容。</p>
<p>除了上面说的外在iOS10还引入了推送通知UI框架(UserNotificationsUI.framework) ，当通知到达设备上时可以显示自定义的UI了。而且可以开发对应的扩展来响应用户对通知的操作。</p>
<h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><p>iOS10引入了新的连续语音识别框架<code>Speech.framework</code>，除了语音识别外还能把语音转换成文字。另外语音识别和录音可以同时进行。下面是示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let recognizer = SFSpeechRecognizer()</div><div class="line">let request = SFSpeechURLRecognitionRequest(url: audioFileURL)</div><div class="line">recognizer?.recognitionTask(with: request, resultHandler: &#123; (result, error) in</div><div class="line">     print (result?.bestTranscription.formattedString)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>语音识别中为了提高识别率，苹果会把用户的语音数据临时保存在服务器上，所以算是获取到了用户的隐私数据(关于访问用户的隐私数据的细节可以看<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW3" target="_blank" rel="external">Security and Privacy Enhancements</a>)，所以这里需要用户的授权。获取语音识别的授权需要在Info.plist文件里增加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW52" target="_blank" rel="external">NSSpeechRecognitionUsageDescription</a>字段，内容就是你对数据用途的描述。</p>
<p>另外当你在进行语音识别时记得加上明确的UI引导，这样用户体验会更好。</p>
<h3 id="广色域"><a href="#广色域" class="headerlink" title="广色域"></a>广色域</h3><p>系统中大量的图形组件，如Core Graphics、Core Image、Metal和AVFoundation等现在支持更大的色彩空间。UIKit现在已经集成了这个新特性。<br>下面是使用广色域特性的最佳实践：</p>
<ul>
<li>在iOS10上，<code>[UIColor](https://developer.apple.com/reference/uikit/uicolor)</code>使用了扩展的sRGB色彩空间，initializers no longer clamp raw component values to between 0.0 and 1.0. If your app relies on UIKit to clamp component values (whether you’re creating a color or asking a color for its component values), you need to change your app’s behavior when you link against iOS 10.</li>
<li>iPad Pro(9.7寸)上在UIView自定义draw方法时，色彩空间默认就是扩展的sRGB</li>
<li>如果需要渲染自定义图片对象，使用<a href="https://developer.apple.com/reference/uikit/uigraphicsimagerenderer" target="_blank" rel="external">UIGraphicsImageRenderer</a>来控制生成的位图的色彩空间是extended-range还是standard-range</li>
<li>如果在支持宽色域的设备上用Core Graphics、Metal等底层API处理图片，应该用扩展的色彩空间并且要用16位的floating-point component values. When clamping of color values is necessary, you should do so explicitly</li>
<li>Core Graphics、Core Image和Metal执行Shaders时提供了转换颜色和图片的色彩空间的功能</li>
</ul>
<h3 id="True-Tone-Display适配"><a href="#True-Tone-Display适配" class="headerlink" title="True Tone Display适配"></a>True Tone Display适配</h3><p>True Tone display利用环境光传感器根据用户周边的光照自动调整色彩和显示强度。为了True Tone在标准色上产生的色彩偏移不会给应用带来负面影响，可以在Info.plist添加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW31" target="_blank" rel="external">UIWhitePointAdaptivityStyle</a>字段，并指定适当的类型，例如：</p>
<ul>
<li>如果你的应用是照片编辑类的，对色彩精准地还原才是重中之重。可以指定类型为UIWhitePointAdaptivityStylePhoto来减少True Tone产生的色彩偏移</li>
<li>如果你的应用是阅读类的，舒适的阅读环境对用户最重要。可以指定指定类型为UIWhitePointAdaptivityStyleReading来增加True Tone产生的色彩偏移</li>
</ul>
<h3 id="App-Search增强"><a href="#App-Search增强" class="headerlink" title="App Search增强"></a>App Search增强</h3><p>iOS10上Core Spotlight框架得到了一些增强：</p>
<ul>
<li>应用内搜索</li>
<li>Search continuation</li>
<li>Crowdsourcing deep link popularity with differential privacy</li>
<li>Visualization of validation results</li>
</ul>
<p>新的<a href="https://developer.apple.com/reference/corespotlight/cssearchquery" target="_blank" rel="external">CSSearchQuery</a>类支持应用内搜索。使用这个API可以避免自己维护内容索引，并能马上能利用Spotlight技术带来的便利，类似于，邮件、短信和备忘录的搜索，这个完全是在应用内进行。</p>
<p>在iOS9，通过搜索APIs(比如Core Spotlight、NSUserActivity还有web markup)来索引应用内的内容后，用户就能通过Spotlight和Safari搜索来使用它。在iOS10上，Core Spotlight功能进一步增强。当用户通过搜索特定内容启动App时，可以得知用户搜索的内容，并显示出相应的数据。在Info.plist中增加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW43" target="_blank" rel="external">CoreSpotlightContinuation</a>字段并设置为YES就可以启用这个特性。另外需注意如果开启这个特性需要实现对<a href="https://developer.apple.com/reference/corespotlight/csquerycontinuationactiontype" target="_blank" rel="external">CSQueryContinuationActionType</a>类型的activity continuation的处理逻辑。<a href="https://developer.apple.com/reference/uikit/uiapplicationdelegate/1623072-application" target="_blank" rel="external">application:continueUserActivity:restorationHandler:</a>方法回传的<a href="https://developer.apple.com/reference/foundation/nsuseractivity" target="_blank" rel="external">NSUserActivity</a>对象包含了用户信息，通过<a href="https://developer.apple.com/reference/corespotlight/cssearchquerystring" target="_blank" rel="external">CSSearchQueryString</a>可以取到用户的搜索关键字。</p>
<p>iOS10引入了更具隐私的技术来提高你的App内容在用户搜索中的曝光率。新引入的<a href="https://developer.apple.com/reference/foundation/nsuseractivity/1414701-iseligibleforpublicindexing" target="_blank" rel="external">eligibleForPublicIndexing</a>属性可以告诉系统是否把指定内容设为公共的(所有iOS用户都可以查看,译者注)，当用户使用App或者<a href="https://developer.apple.com/reference/foundation/nsuseractivity" target="_blank" rel="external">NSUserActivity</a>包含一个<code>deep link</code>时，如果它们的<code>eligibleForPublicIndexing</code>被设置成了YES，系统就会把对应的数据经过信息哈希算法生成内容摘要(内容摘要是不包含用户数据的字符串，不能反向还原出原内容，译者注)，然后发送到苹果的服务器。苹果的服务器只用统计这些内容摘要的使用频率就能算出热度排行，从而对搜索进行排名，这个过程完全不涉及到具体的用户数据。</p>
<p>当你用App搜索有效性验证工具测试你的website markup和deep links时，它现在有更人性化的视觉展示了。包括支持的markup(具体定义在<a href="http://schema.org/" target="_blank" rel="external">Schema.org</a>上)。这个工具能查看Applebot对你的应用内容的具体收录信息，类似于title、description、URL以及其他的元素。App搜索有效性验证工具在这里：<a href="https://search.developer.apple.com/appsearch-validation-tool。如果想了解如何支持`deep" target="_blank" rel="external">https://search.developer.apple.com/appsearch-validation-tool。如果想了解如何支持`deep</a> links<code>和</code>markup`可以看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8" target="_blank" rel="external">Mark Up Web Content</a>。</p>
<p>想要了解如何让Messages app内的表情(图片)可以被外部搜索到，可以看<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW4" target="_blank" rel="external">Integrating with the Messages App</a>。</p>
<h3 id="Widget增强"><a href="#Widget增强" class="headerlink" title="Widget增强"></a>Widget增强</h3><p>iOS10重新设计了锁屏界面，现在从锁屏界面右滑就能看见widgets。为了保证widget在各种背景下都好看，需要根据情况调用<a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1771278-widgetprimaryvibrancyeffect" target="_blank" rel="external">widgetPrimaryVibrancyEffect</a>或<a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1771277-widgetsecondaryvibrancyeffect" target="_blank" rel="external">widgetSecondaryVibrancyEffect</a>(这两个方法会替代即将废弃的<a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1613917-notificationcentervibrancyeffect" target="_blank" rel="external">notificationCenterVibrancyEffect</a>)。另外widgets现在新增加了显示模式的概念(通过<a href="https://developer.apple.com/reference/notificationcenter/ncwidgetdisplaymode" target="_blank" rel="external">NCWidgetDisplayMode</a>属性获取显示模式)，需要你根据用户选择的模式显示合适的内容。(现在就是”展开”、”收起”两种模式，需要根据用户的选择，来显示较少或更多的内容，译者注)。</p>
<h3 id="Apple-Pay增强"><a href="#Apple-Pay增强" class="headerlink" title="Apple Pay增强"></a>Apple Pay增强</h3><p>iOS10以后用户可以在网站上使用Apple Pay，还能直接用Siri和地图下达支付命令。对于开发者而言，iOS10引入了同时支持iOS和watchOS的新API，并且支持随时更换银行卡和新沙盒测试环境。</p>
<p>iOS10引入的新API可以直接集成到网站上，当网站集成好Apple Pay后，用户通过Safari(iOS和macOS都行)浏览时就能用Apple Pay付款。想要了解更多关于网站集成Apple Pay的知识可以看<a href="https://developer.apple.com/reference/applepayjs" target="_blank" rel="external">ApplePay JS Framework Reference</a>。</p>
<p>PassKit框架(PassKit.framework)引入的新API不依赖UIkit。比如PKPaymentAuthorizationController和PKPaymentAuthorizationControllerDelegate的特性是由PKPaymentAuthorizationViewController和它的委托来实现的。但它也不需要导入UIKit。 尽管是为了让watchOS和其他情况使用Apple Pay而设计的这些API，但建议实现一套统一的代码框架来适配Apple Pay的所有使用场景(Siri、网站、地图，译者注)。想要了解更多关于Siri集成的知识可以看<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW5" target="_blank" rel="external">SiriKit</a>。</p>
<p>PassKit还有一项新特性。就是让发卡商家从他们的应用中显示卡片。<code>PKPaymentButtonTypeInStore</code>类型的button可以给卡片显示Apple Pay的标志。实现<code>presentPaymentPass:</code>方法就能显示卡片。(<code>presentPaymentPass:</code>方法在<a href="https://developer.apple.com/reference/passkit/pkpasslibrary" target="_blank" rel="external">PKPassLibrary</a>中定义)。</p>
<p>当有新的行银片绑定时，应用能自动适应而不需要重新发版。<a href="https://developer.apple.com/reference/passkit/pkpaymentrequest/1833288-availablenetworks" target="_blank" rel="external">availableNetworks</a>方法可以查询当前可用的银行卡。另外<a href="https://developer.apple.com/reference/passkit/pkpaymentrequest/1619329-supportednetworks" target="_blank" rel="external">supportedNetworks</a>属性可以限定所支持的银行卡。想了解更多关于Apple Pay的知识可以去：<a href="https://developer.apple.com/apple-pay/。" target="_blank" rel="external">https://developer.apple.com/apple-pay/。</a></p>
<p>iOS10引入了新的测试技术，可以直接在设备上添加测试卡片。测试环境返回加密的支付数据。需要下面几步来开启测试环境：<br>1<em> 在iTunes Connect上新建一个iCloud测试账号<br>2</em> 在设备上登录测试账号<br>3<em> 设置这个账号所在的地区<br>4</em> 使用<a href="https://developer.apple.com/apple-pay/上列出的银行卡测试" target="_blank" rel="external">https://developer.apple.com/apple-pay/上列出的银行卡测试</a></p>
<p>注意：如果切换iCloud账号，测试环境也会自动切换。所以最好用真实的卡片在生产环境上测试。</p>
<h3 id="安全和隐私的增强"><a href="#安全和隐私的增强" class="headerlink" title="安全和隐私的增强"></a>安全和隐私的增强</h3><p>iOS10增强了代码的安全性以及用户数据的安全性。想了解更多可以看：<a href="https://developer.apple.com/security/。" target="_blank" rel="external">https://developer.apple.com/security/。</a></p>
<ul>
<li>如果应用启用了ATS，但又想在加载web内容的时候使用非安全连接。只需要在Info.plist中添加<code>NSAllowsArbitraryLoadsInWebContent</code>字段就行</li>
<li><code>SecKey</code>API增强了非对称加密key的生成。请使用<code>SecKey</code>API来替代废弃的Common Data Security Architecture (CDSA) APIs</li>
<li>SSL/TLS中已经默认禁用RC4对称加密算法了，而且Secure Transportations API未来也不会再支持SSLv3。建议尽可能地使用SHA-1和3DES加密算法</li>
<li>在iOS10上出现了可以在多台登录iCloud的设备上互相复制粘贴的功能(<a href="https://developer.apple.com/reference/uikit/uipasteboard" target="_blank" rel="external">UIPasteboard</a>)。你可以针对指定的设备把剪贴板功能做限制以及给剪贴板加上超时时间(超过时间不使用里面的内容，剪贴板就会被清空)。另外具名剪贴板不再被持久化了，作为替代你现在可以用共享式的容器。还有就是”Find”剪贴板(通过<a href="https://developer.apple.com/reference/uikit/uipasteboardnamefind" target="_blank" rel="external">UIPasteboardNameFind</a>获取)从iOS10开始被禁用了。</li>
<li>现在访问用户受保护的数据都需要在Info.plist里添加对应的字段，并附上对数据的用途的描述。例如如果要访问日历数据的话就需要在Info.plist中添加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW15" target="_blank" rel="external">NSCalendarsUsageDescription</a>并写上你用日历数据的目的。如果未经允许就读取数据会造成应用闪退。</li>
</ul>
<h3 id="CallKit"><a href="#CallKit" class="headerlink" title="CallKit"></a>CallKit</h3><p>CallKit框架(CallKit.framework)现在允许VoIP应用的呼入直接通过系统来电UI展现出来。这样用户就能直接在锁屏界面接听或拒绝VoIP呼叫，并且这个呼叫会被记录在最近通话之中。</p>
<p>CallKit还引入了来电拦截和骚扰电话识别扩展。利用这些扩展可以根据系统给定的电话号码给出具体的提示或者告诉系统这个电话是否该被拦截。</p>
<h3 id="News-Publisher增强"><a href="#News-Publisher增强" class="headerlink" title="News Publisher增强"></a>News Publisher增强</h3><p>News Publisher现在可以很容易地通过Apple News向用户提供新闻、杂志以及web内容。无论是主流杂志和新闻机构还是独立的记者和博客，任何人都可以注册为News Publisher。想要了解更多关于这方面的信息可以看：<a href="https://newsresources.apple.com。" target="_blank" rel="external">https://newsresources.apple.com。</a></p>
<h3 id="视频订阅账户"><a href="#视频订阅账户" class="headerlink" title="视频订阅账户"></a>视频订阅账户</h3><p>iOS10引入了视频订阅账户框架(VideoSubscriberAccount.framework)来帮助支持授权流媒体/视频的应用从有线电视/卫星电视供应商获取授权。使用这个框架可以达到多个视频应用一键登录的效果(必须是支持VideoSubscriberAccount的应用)，大大提升了用户体验。</p>
<h3 id="App扩展"><a href="#App扩展" class="headerlink" title="App扩展"></a>App扩展</h3><p>iOS10引入了多个新类型的App扩展：</p>
<ul>
<li>Call Directory</li>
<li>Intents</li>
<li>Itents UI</li>
<li>Messages</li>
<li>Notification Content</li>
<li>Notification Service</li>
<li>Sticker Pack</li>
</ul>
<p>另外，iOS10还包含了对第三方键盘的一些增强：</p>
<ul>
<li>可以用<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy" target="_blank" rel="external">UITextDocumentProxy </a>来检测用户正在输入的语言，并据此调整键盘。</li>
<li>新增的handleInputModeListFromView:withEvent:方法能显示系统的键盘切换按钮</li>
</ul>
<p>虽然你能自定义输入法切换按钮的外观，但这个按钮一定要放到和系统键盘一样的位置。想要了解关于应用扩展的信息可以看：<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="external">App Extension Programming Guide</a></p>
<h3 id="其他框架的改动"><a href="#其他框架的改动" class="headerlink" title="其他框架的改动"></a>其他框架的改动</h3><p>除了上述的主要改动外，iOS10还包含了其他的改进。</p>
<h5 id="AVFoundation-Camera-Capture"><a href="#AVFoundation-Camera-Capture" class="headerlink" title="AVFoundation Camera Capture"></a>AVFoundation Camera Capture</h5><p>AVFoundation框架(AVFoundation.framework)中的媒体采集组件包含了多项重要改进。</p>
<h6 id="Dual-Camera-and-Device-Discovery"><a href="#Dual-Camera-and-Device-Discovery" class="headerlink" title="Dual Camera and Device Discovery"></a>Dual Camera and Device Discovery</h6><p>iPhone7 plus的相机有2个镜头，一个为广角镜一个为长焦镜，但它们组合在一起成为一个双镜头相机。当使用这个双镜头相机时，iOS根据环境和设置自动地使用两者或者其中某一个。当你通过<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice" target="_blank" rel="external">AVCaptureDevice</a>来拍照或录视频时可以选择双镜头相机(iOS自动调整两个镜头的使用)或者单独指定是广角镜还是长焦镜。</p>
<p>在iOS10以后可以通过下面的方法使用摄像机：</p>
<ul>
<li>调用<code>defaultDeviceWithDeviceType:mediaType:position:</code>方法。  (指定<code>AVCaptureDeviceTypeBuiltInDuoCamera</code>参数启用双镜头相机。如果返回值为nil，说明设备上没有双镜头相机；指定<code>AVCaptureDeviceTypeBuiltInWideAngleCamera</code>参数启用默认的后置相机)</li>
<li>实例化一个<code>AVCaptureDeviceDiscoverySession</code>对象，指定相关的参数，并从设备列表中选择想要使用的摄像机</li>
</ul>
<p>注意：<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice" target="_blank" rel="external">AVCaptureDevice</a>的<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice/1386237-devices" target="_blank" rel="external">devices</a>和<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice/1390520-deviceswithmediatype" target="_blank" rel="external">devicesWithMediaType:</a>方法在iOS10被弃用。并且不提供访问双镜头相机和广角镜相机的方法。</p>
<p>当使用双镜头相机时，RAW格式和大部分手动控制特性都暂时不可用。这两个特性必须在单镜头相机上才能开启。关于每个镜头的性能参数可以看<a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="external">iOS Device Compatibility Reference</a>。</p>
<h6 id="New-Photo-Capture-API"><a href="#New-Photo-Capture-API" class="headerlink" title="New Photo Capture API"></a>New Photo Capture API</h6><p>新的<a href="https://developer.apple.com/reference/avfoundation/avcapturephotooutput" target="_blank" rel="external">AVCapturePhotoOutput</a>类为图片处理提供了统一的方案。这个方案能提供更细粒度的控制，监听整个采样过程以及支持新的Live Photos、RAW格式等新特性。建议用它替换<a href="https://developer.apple.com/reference/avfoundation/avcapturestillimageoutput" target="_blank" rel="external">AVCaptureStillImageOutput</a>(AVCaptureStillImageOutput在iOS10已经废弃)。</p>
<h6 id="Wide-Color"><a href="#Wide-Color" class="headerlink" title="Wide Color"></a>Wide Color</h6><p>摄像机采样现在已经支持输出宽色域数据(需要在支持宽色域的设备，译者注)。默认情况下<a href="https://developer.apple.com/reference/avfoundation/avcapturesession" target="_blank" rel="external">AVCaptureSession</a>会自动配置是否启用宽色域，具体的细节可以看：<a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="external">iOS Device Compatibility Reference</a></p>
<h5 id="AVFoundation-Media"><a href="#AVFoundation-Media" class="headerlink" title="AVFoundation Media"></a>AVFoundation Media</h5><p>AVFoundation框架(AVFoundation.framework)中的媒体播放和编辑组件包含了下列改进：</p>
<ul>
<li>不用再根据内容是视频文件还是HTTP流媒体来设置不同的<a href="https://developer.apple.com/reference/avfoundation/avplayeritem" target="_blank" rel="external">AVPlayerItem</a>了。在iOS10以后，仅仅需要设置<a href="https://developer.apple.com/reference/avfoundation/avplayer/1388846-rate" target="_blank" rel="external">rate</a>属性，AVFoundation会自动进行后续的配置</li>
<li>新的<a href="https://developer.apple.com/reference/avfoundation/avplayerlooper" target="_blank" rel="external">AVPlayerLooper</a>类让重复播放媒体的部分内容变更容易(就是复读机功能，译者注)</li>
<li>用<a href="https://developer.apple.com/reference/avfoundation/avassetdownloadurlsession" target="_blank" rel="external">AVAssetDownloadURLSession</a>类来离线媒体资源，包括HTTP流媒体等(离线到设备上，然后无网的时候也能看，译者注)。它跟FairPlay Streaming结合在一起时还能离线加密的HTTP流媒体</li>
</ul>
<h5 id="AVKit"><a href="#AVKit" class="headerlink" title="AVKit"></a>AVKit</h5><p>AVKit框架(AVKit.framework)，包含了<code>updatesNowPlayingInfoCenter</code>属性，可以调用它来刷新<code>Now Playing Info Center</code>。</p>
<h5 id="Core-Data"><a href="#Core-Data" class="headerlink" title="Core Data"></a>Core Data</h5><p>Core Data框架(CoreData.framework)包含了下列改进：</p>
<ul>
<li><a href="https://developer.apple.com/reference/coredata/nspersistentstorecoordinator" target="_blank" rel="external">NSPersistentStoreCoordinator</a>现在维护了一个SQLite连接池。<a href="https://developer.apple.com/reference/coredata/nsmanagedobjectcontext" target="_blank" rel="external">NSManagedObjectContext</a>对象(没有父MOCs)透明地支持并发查询and faulting without serializing against each other.</li>
<li><a href="https://developer.apple.com/reference/coredata/nsmanagedobjectcontext" target="_blank" rel="external">NSManagedObjectContext</a>对象和SQLite存储在WAL文件里，<code>journal_model</code>支持现在支持query generation特性。These allow a MOC to be pinned to a version of the database at a point in time and perform all future fetching and faulting against that version of the database. Pinned MOCs are moved to the most recent transaction with any save, and query generations do not survive the process’s life time.</li>
<li>新的<a href="https://developer.apple.com/reference/coredata/nspersistentcontainer" target="_blank" rel="external">NSPersistentContainer</a>类提供了高层API来维护对<code>NSPersistentStoreCoordinator</code>和<a href="https://developer.apple.com/reference/coredata/nsmanagedobjectmodel" target="_blank" rel="external">NSManagedObjectModel</a>以及其他配置源的引用</li>
<li>Core Data现在进一步地与Xcode集成在一起。并能自动生成和更新<a href="https://developer.apple.com/reference/coredata/nsmanagedobject" target="_blank" rel="external">NSManagedObject</a></li>
<li><code>NSManagedObject</code>包含了多个获取和创建其子类的快捷方法。<code>NSManagedObject</code> subclasses that have a 1:1 relationship with an entity now support <code>entity</code>.</li>
<li>Core Data对API进行了一些Swift friendly式的调整，包括像参数化的<a href="https://developer.apple.com/reference/coredata/nsfetchrequest" target="_blank" rel="external">NSFetchRequest</a>对象</li>
</ul>
<p>更多信息参见<a href="https://developer.apple.com/reference/coredata" target="_blank" rel="external">Core Data Framework Reference</a></p>
<h5 id="Core-Image"><a href="#Core-Image" class="headerlink" title="Core Image"></a>Core Image</h5><p>Core Image框架(CoreImage.framework)包含了下面这些改进。</p>
<p>搭载A8、A9CPU的设备开始支持RAW格式的图片。对于第三方相机产生的RAW格式的图片CoreImage也能很好地支持，使用RAW格式的图片需要调用<a href="https://developer.apple.com/reference/coreimage/cifilter/1437879-init" target="_blank" rel="external">filterWithImageData:options:</a>或<a href="https://developer.apple.com/reference/coreimage/cifilter/1438096-init" target="_blank" rel="external">filterWithImageURL:options:</a>来创建一个<a href="https://developer.apple.com/reference/coreimage/cifilter" target="_blank" rel="external">CIFilter</a>对象，再根据RAW Image Options选项调整RAW数据，最后从<a href="https://developer.apple.com/reference/coreimage/cifilter/1438169-outputimage" target="_blank" rel="external">outputImage</a>属性中得到处理后的图片数据。</p>
<p>现在可以用<a href="https://developer.apple.com/reference/coreimage/ciimage/1639637-withextent" target="_blank" rel="external">imageWithExtent:processorDescription:argumentDigest:inputFormat:outputFormat:options:roiCallback:processor:</a>方法在Core Image滤镜中插入自定义的处理逻辑。这个方法添加了一个回调Block，这个Block会在处理图片数据和输出图片数据之间的一个时刻被调用。在Block里能获取到像素数据或Metal纹理数据，你在这里可以运行自定义的图形算法。</p>
<p>在写自定义图形处理逻辑或重写滤镜内核时除了Core Image的contex的色彩空间外还能用其他的色彩空间，可以用 <a href="https://developer.apple.com/reference/coreimage/ciimage/1645898-matchedfromworkingspace" target="_blank" rel="external">imageByColorMatchingWorkingSpaceToColorSpace:</a>和<a href="https://developer.apple.com/reference/coreimage/ciimage/1645896-matchedtoworkingspace" target="_blank" rel="external">imageByColorMatchingColorSpaceToWorkingSpace:</a>方法来互相转换。</p>
<p>在Core Image框架的优化下渲染<a href="https://developer.apple.com/reference/uikit/uiimage" target="_blank" rel="external">UIImage</a>对象的效率得到大幅提升(比如用<a href="https://developer.apple.com/reference/uikit/uiimage/1624114-init" target="_blank" rel="external">initWithCIImage:</a>方法初始化)。另外UIImageView中的宽色域的支持是由它内部的Core Image对象实现的。</p>
<p>Core Image核心代码现在可以指定输出像素格式。</p>
<p>Core Image引入了5个新滤镜：</p>
<ul>
<li>CINinePartTiled</li>
<li>CINinePartStretched</li>
<li>CIHueSaturationValueGradient</li>
<li>CIEdgePreserveUpsampleFilter</li>
<li>CIClamp</li>
</ul>
<h5 id="Core-Motion"><a href="#Core-Motion" class="headerlink" title="Core Motion"></a>Core Motion</h5><p>Core Motion框架(CoreMotion.framework)引入了计步器事件，它可以实时监听手机用户的运动状态，包括跑步、暂停等。在支持这个特性的设备上可以用<a href="https://developer.apple.com/reference/coremotion/cmpedometer" target="_blank" rel="external">CMPedometer</a>APIs来注册并接受实时计步事件。</p>
<h5 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h5><p>Foundation框架(Foundation.framework)包含了下列增强：</p>
<ul>
<li>新的<a href="https://developer.apple.com/reference/foundation/nsdateinterval" target="_blank" rel="external">NSDateInterval</a>类提供了判断某个时刻是否处于指定的时间段内。</li>
<li><a href="https://developer.apple.com/reference/foundation/nslocale" target="_blank" rel="external">NSLocale</a>增加了获取本地化信息的属性</li>
<li>新的<a href="https://developer.apple.com/reference/foundation/nsmeasurement" target="_blank" rel="external">NSMeasurement</a>类能把尺寸转换成不同的单位，并在两种尺寸之间进行计算。新的<a href="https://developer.apple.com/reference/foundation/measurementformatter" target="_blank" rel="external">NSMeasurementFormatter</a>类可以把尺寸进行本地化(转换成当地惯用单位，译者注)</li>
<li>新的<a href="https://developer.apple.com/reference/foundation/unit" target="_blank" rel="external">NSUnit</a>类以其子类<a href="https://developer.apple.com/reference/foundation/nsdimension" target="_blank" rel="external">NSDimension</a>能表示特定的计量单位</li>
</ul>
<h5 id="GameKit"><a href="#GameKit" class="headerlink" title="GameKit"></a>GameKit</h5><p>GameKit框架(GameKit.framework)包含了下列改进：</p>
<ul>
<li>Game Center应用现在已经被移除。如果游戏中实现了GameKit特性，需要自定义相关的UI。例如，你的游戏支持排行榜，你可以直接从Game Center获取相关数据并用自定义的视图展示(当然，直接用<a href="https://developer.apple.com/reference/gamekit/gkgamecenterviewcontroller" target="_blank" rel="external">GKGameCenterViewController</a>对象也行)</li>
<li>新的账户类型，由<a href="https://developer.apple.com/reference/gamekit/gkcloudplayer" target="_blank" rel="external">GKCloudPlayer</a>实现，支持iCloud-only游戏账号</li>
<li>Game Center对其内部的数据持久化提供了新的解决方案。一个游戏会话(<a href="https://developer.apple.com/reference/gamekit/gkgamesession" target="_blank" rel="external">GKGameSession</a>)拥有参与这个会话的玩家列表。你需要做的是决定何时以及如何从服务端存储和遍历数据或在玩家之间传输数据。游戏会话技术非常适用于回合制比赛、实时比赛以及其他多人互动游戏上</li>
</ul>
<h5 id="GameplayKit"><a href="#GameplayKit" class="headerlink" title="GameplayKit"></a>GameplayKit</h5><p>GameplayKit框架(GameplayKit.framework)包含了下列的改进：</p>
<ul>
<li>用于增强游戏场景效果的声音合成器。以及看起来更自然的纹理和更真实的相机移动。</li>
<li>空间隔离减少了游戏数据处理复杂度，让数据搜索效率更高</li>
<li>新的Monte Carlo策略(<a href="https://developer.apple.com/reference/gameplaykit/gkmontecarlostrategist" target="_blank" rel="external">GKMonteCarloStrategist</a>)类能帮你免除对可能产生的动作进行详尽地计算</li>
<li>新的决策树API能让游戏的AI设计起来更方便(前提是你的游戏AI是通过玩家行为数据用决策树来生成的)</li>
<li><a href="https://developer.apple.com/reference/gameplaykit/gkagent3d" target="_blank" rel="external">GKAgent3D</a>和<a href="https://developer.apple.com/reference/gameplaykit/gkgraphnode3d" target="_blank" rel="external">GKGraphNode3D</a>类引入了对existing agent和path-finding的3D支持</li>
<li><a href="https://developer.apple.com/reference/gameplaykit/gkobstaclegraph" target="_blank" rel="external">GKObstacleGraph</a>有了性能更好的替代品——<a href="https://developer.apple.com/reference/gameplaykit/gkmeshgraph" target="_blank" rel="external">GKMeshGraph</a>它能生成更自然的路径</li>
<li>新的<a href="https://developer.apple.com/reference/gameplaykit/gkscene" target="_blank" rel="external">GKScene</a>、<a href="https://developer.apple.com/reference/gameplaykit/gksknodecomponent" target="_blank" rel="external">GKSKNodeComponent</a>和SpriteKit以及Xcode editor的结合让集成GameplayKit、SpriteKit变得前所未有地简单</li>
</ul>
<h5 id="HealthKit"><a href="#HealthKit" class="headerlink" title="HealthKit"></a>HealthKit</h5><p>HealthKit框架(HealthKit.framework)包含了下列改进：</p>
<ul>
<li>新的<a href="https://developer.apple.com/reference/healthkit/hkcdadocument" target="_blank" rel="external">HKCDADocument</a>类，代表CDA文件(遵循Clinical Document Architecture标准的文件)</li>
<li>新的<a href="https://developer.apple.com/reference/healthkit/hkworkoutconfiguration" target="_blank" rel="external">HKWorkoutConfiguration</a>类，能让你为一项锻炼指定<a href="https://developer.apple.com/reference/healthkit/hkworkoutconfiguration/1649492-activitytype" target="_blank" rel="external">activityType</a>和<a href="https://developer.apple.com/reference/healthkit/hkworkoutconfiguration/1649491-locationtype" target="_blank" rel="external">locationType</a></li>
<li>新的<a href="https://developer.apple.com/reference/healthkit/hkwheelchairuseobject" target="_blank" rel="external">HKWheelchairUseObject</a>特征对象类型和<a href="https://developer.apple.com/reference/healthkit/hkhealthstore" target="_blank" rel="external">HKHealthStore</a>相关的方法<a href="https://developer.apple.com/reference/healthkit/hkhealthstore/1648356-wheelchairuse" target="_blank" rel="external">wheelchairUseWithError:</a></li>
<li>新的代表天气的元数据key，比如<a href="https://developer.apple.com/reference/healthkit/hkweathercondition/hkweatherconditionclear" target="_blank" rel="external">HKWeatherConditionClear</a>和<a href="https://developer.apple.com/reference/healthkit/hkweathercondition/hkweatherconditioncloudy" target="_blank" rel="external">HKWeatherConditionCloudy</a>。还有锻炼类的，比如<a href="https://developer.apple.com/reference/healthkit/hkworkoutactivitytype/1649808-flexibility" target="_blank" rel="external">HKWorkoutActivityTypeFlexibility</a>和<a href="https://developer.apple.com/reference/healthkit/hkworkoutactivitytype/hkworkoutactivitytypewheelchairrunpace" target="_blank" rel="external">HKWorkoutActivityTypeWheelchairRunPace</a></li>
</ul>
<h5 id="HomeKit"><a href="#HomeKit" class="headerlink" title="HomeKit"></a>HomeKit</h5><p>iOS10以后，iPad可以变成家庭控制中心，允许进行远程访问，运行自动任务触发器以及共享用户授权。另外HomeKit框架(HomeKit.framework)添加了对摄像机和门铃的支持，并引入了很多新API：</p>
<ul>
<li>调用并控制网络摄像机，显示实时视频流和截图以及控制摄像机、扬声器和话筒</li>
<li>Access new services and characteristics</li>
<li>For the primary service, link services and valid values to provide more context and configuration about the accessories</li>
</ul>
<p>现在可以用Apple家居设备设置流程来添加或者设置家居设备。想要了解更多可以看<a href="https://developer.apple.com/reference/homekit" target="_blank" rel="external">HomeKit Framework Reference</a></p>
<h5 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a>Metal</h5><p>iOS10以后Metal引入了一些新特性并对某些方面进行了增强，比如：</p>
<ul>
<li>支持tessellation。允许3D游戏和应用进行更细致地渲染</li>
<li>函数专精化。这样就能开发出高度优化的函数来处理材质和光照</li>
<li>资源堆和更小内存的渲染目标。在未来会对资源分配进行更细粒度的控制来优化性能</li>
</ul>
<h5 id="ModelIO"><a href="#ModelIO" class="headerlink" title="ModelIO"></a>ModelIO</h5><p>ModelIO框架(ModelIO.framework)包含了下列改进：</p>
<ul>
<li>支持USD格式</li>
<li>新的<code>MDLMaterialPropertyGraph</code>类让运行时修改models更容易</li>
<li><a href="https://developer.apple.com/reference/modelio/mdlvoxelarray" target="_blank" rel="external">MDLVoxelArray</a>类现在支持signed distance fields</li>
<li>可以实现<code>MDLLightProbeIrradianceDataSource</code>协议来添加assisted light probe</li>
</ul>
<h5 id="Photos"><a href="#Photos" class="headerlink" title="Photos"></a>Photos</h5><p>Photos框架(Photos.framework)现在支持对Live Photo进行编辑了。特别是新<a href="https://developer.apple.com/reference/photos/phlivephotoeditingcontext" target="_blank" rel="external">PHLivePhotoEditingContext</a>类允许你编辑视频和Live Photo中的静态内容。Core Image的性能增强在这里也得以体现，想要了解更多请看<a href="https://developer.apple.com/reference/coreimage/ciimageprocessorinput" target="_blank" rel="external">CIImageProcessorInput</a>和<a href="https://developer.apple.com/reference/coreimage/ciimageprocessoroutput" target="_blank" rel="external">CIImageProcessorOutput</a>。</p>
<h5 id="ReplayKit"><a href="#ReplayKit" class="headerlink" title="ReplayKit"></a>ReplayKit</h5><p>ReplayKit框架(ReplayKit.framework)包含了下列增强：</p>
<ul>
<li>ReplayKit支持广播服务，用户可以通过第三方广播自己的屏幕内容。使用下面这些API就能够集成这个新特性 <a href="https://developer.apple.com/reference/replaykit/rpscreenrecorder" target="_blank" rel="external">RPScreenRecorder</a>、<a href="https://developer.apple.com/reference/replaykit/rpbroadcastactivityviewcontroller" target="_blank" rel="external">RPBroadcastActivityViewController</a>、<a href="https://developer.apple.com/reference/replaykit/rpbroadcastcontroller" target="_blank" rel="external">RPBroadcastController</a></li>
<li>若要参与ReplayKit广播，第三方广播服务商需要实现相应的应用扩展。这个扩展应该具有让用户接入并配置广播的功能</li>
</ul>
<h5 id="SceneKit"><a href="#SceneKit" class="headerlink" title="SceneKit"></a>SceneKit</h5><p>The SceneKit framework (SceneKit.framework) includes several enhancements.</p>
<p>A new Physically Based Rendering (PBR) system allows you to leverage the latest in 3D graphics research to create more realistic results with simpler asset authoring. Specifically:</p>
<ul>
<li><p>Use the new <a href="https://developer.apple.com/reference/scenekit/scnmaterial.lightingmodel/1640553-physicallybased" target="_blank" rel="external">SCNLightingModelPhysicallyBased</a> shading model to opt into PBR shading for materials. PBR materials require only three fundamental properties—<a href="https://developer.apple.com/reference/scenekit/scnmaterial/1462589-diffuse" target="_blank" rel="external">diffuse</a>, <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1640554-metalness" target="_blank" rel="external">metalness</a>, and <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1640555-roughness" target="_blank" rel="external">roughness</a>—to produce a wide range of realistic shading effects. (The <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1462542-normal" target="_blank" rel="external">normal</a>, <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1462579-ambientocclusion" target="_blank" rel="external">ambientOcclusion</a>, and selfIllumination material properties also remain useful for PBR materials, but you can now ignore the large number of other properties used for traditional materials.)</p>
</li>
<li><p>PBR shading works best with environment-based lighting, which causes even diffuse surfaces to pick up the colors of the scene around them. Use the <a href="https://developer.apple.com/reference/scenekit/scnscene/1639532-lightingenvironment" target="_blank" rel="external">lightingEnvironment</a> property to assign global image-based lighting to an entire scene, and place light probes in the Xcode scene editor to pick up the local lighting contributions from objects within your scene.<br>Authors of PBR scene content often prefer working in physically based terms, so you can now define lighting using intensity (in lumens) and color temperature (in degrees Kelvin), and import specifications for real-world light fixtures using the IESProfileURL property.</p>
</li>
</ul>
<p>Add even more realism with the new HDR features and effects in the <a href="https://developer.apple.com/reference/scenekit/scncamera" target="_blank" rel="external">SCNCamera</a> class. With HDR rendering, SceneKit captures a much wider range of brightness and contrast in a scene, then allows you to customize the tone mapping that adapts that scene for the narrower range of a device’s display. Enable exposure adaptation to create automatic effects when, for example, the player in your game moves from a darkened area into sunlight. Or use vignetting, color fringing, and color grading to add a filmic look to your game.</p>
<p>Although linear, more color-accurate rendering is the basis for PBR shading and HDR camera features, it produces better results even for traditional rendering. By default, SceneKit now performs all color calculations in a linear (not gamma-adjusted) color space, and uses the P3 color gamut of devices that include wide-color displays. This feature is enabled automatically for all apps linking against the iOS 10 SDK, and has a few ramifications for content design and asset management:</p>
<ul>
<li>SceneKit color matches all colors. In previous versions, SceneKit would read only the color values from material colors specified as <a href="https://developer.apple.com/reference/appkit/nscolor" target="_blank" rel="external">NSColor</a> or <a href="https://developer.apple.com/reference/uikit/uicolor" target="_blank" rel="external">UIColor</a> objects, ignoring color profile information and assuming the sRGB color space.</li>
<li>SceneKit interprets color component values specified within shader modifier or custom Metal or OpenGL shader code in linear RGB space.</li>
<li>SceneKit reads and adjusts for color profile information in texture images. Design textures for a linear brightness ramp, and use Asset Catalogs in Xcode to make sure your images use the correct color profile.</li>
<li>If necessary, you can disable linear space rendering with the <code>SCNDisableLinearSpaceRendering</code> key in your app’s Info.plist file, and wide color rendering with the <code>SCNDisableWideGamut</code> key.<br>Geometry can now be loaded from scene files or programmatically defined using arbitrary polygon primitives (<a href="https://developer.apple.com/reference/scenekit/scngeometryprimitivetype/scngeometryprimitivetypepolygon" target="_blank" rel="external">SCNGeometryPrimitiveTypePolygon</a>). SceneKit automatically triangulates polygon meshes for rendering, but makes use of the underlying polygon mesh for more accurate surface subdivision (to learn more, see the <a href="https://developer.apple.com/reference/scenekit/scngeometry/1524177-subdivisionlevel" target="_blank" rel="external">subdivisionLevel</a> property).</li>
</ul>
<h5 id="SpriteKit"><a href="#SpriteKit" class="headerlink" title="SpriteKit"></a>SpriteKit</h5><p>The SpriteKit framework (SpriteKit.framework) includes the following enhancements:</p>
<ul>
<li>A new tilemap solution supports square, hexagonal, and isometric tilemaps that make it easy to create 2D, 2.5D, and side-scroller games. The Xcode editor provides comprehensive support for organizing your tiles and creating your tilemap. For more information, see the <code>SKTileMapNode</code>, <code>SKTileGroup</code>, <code>SKTileGroupRule</code>, and <code>SKTileSet</code> classes .</li>
<li>The new <code>SKWarpGeometry</code> class is used to stretch or distort how a <a href="https://developer.apple.com/reference/spritekit/skspritenode" target="_blank" rel="external">SKSpriteNode</a> or <a href="https://developer.apple.com/reference/spritekit/skeffectnode" target="_blank" rel="external">SKEffectNode</a> object is rendered. The warp is specified by a set of control points. New <a href="https://developer.apple.com/reference/spritekit/skaction" target="_blank" rel="external">SKAction</a> types can be used to animate between different warp effects.</li>
<li>A custom shader can use attributes that can be configured separately by each node that uses the shader. To add an attribute, create an <code>SKAttribute</code> object and attach it to your shader. Then, for each node that uses that shader, attach an <code>SKAttributeValue</code> object.]</li>
<li>The <a href="https://developer.apple.com/reference/spritekit/skview" target="_blank" rel="external">SKView</a> class defines new methods that give you finer control over when and how your scene is rendered.</li>
</ul>
<h5 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h5><p>UIKit框架(UIKit.framework)包含了大量的改进，包括：</p>
<ul>
<li>新的基于对象互动式动画系统，可以很方便的持有它，并和用户手势进行交互。想要了解更多请看<a href="https://developer.apple.com/reference/uikit/uiviewanimating" target="_blank" rel="external">UIViewAnimating Protocol Reference</a>、<a href="https://developer.apple.com/reference/uikit/uiviewpropertyanimator" target="_blank" rel="external">UIViewPropertyAnimator Class Reference</a>、<a href="https://developer.apple.com/reference/uikit/uitimingcurveprovider" target="_blank" rel="external">UITimingCurveProvider Protocol Reference</a>、<a href="https://developer.apple.com/reference/uikit/uicubictimingparameters" target="_blank" rel="external">UICubicTimingParameters Class Reference</a>、 <a href="https://developer.apple.com/reference/uikit/uispringtimingparameters" target="_blank" rel="external">UISpringTimingParameters Class Reference</a></li>
<li>新的<a href="https://developer.apple.com/reference/uikit/uipreviewinteraction" target="_blank" rel="external">UIPreviewInteraction</a>类和 <a href="https://developer.apple.com/reference/uikit/uipreviewinteractiondelegate" target="_blank" rel="external">UIPreviewInteractionDelegate</a>协议可以为peek和pop操作提供自定义界面</li>
<li><code>UIAccessibilityCustomRotor</code>以及相关的类可以让应用更好地集成辅助性技术，类似于向VoiceOver提供朗读内容。你可以创建自定义的rotor，返回拼写错误的单词的位置来让用户得知文档中的拼写错误</li>
<li><code>UIAccessibilityIsAssistiveTouchRunning</code>和<code>UIAccessibilityAssistiveTouchStatusDidChangeNotification</code>可以在AssistiveTouch激活的时候通知你。<code>UIAccessibilityHearingDevicePairedEar</code>和<code>UIAccessibilityHearingDevicePairedEarDidChangeNotification</code>能让你得知MFi助听器的配对状态</li>
<li>新的<a href="https://developer.apple.com/reference/uikit/uipasteboard" target="_blank" rel="external">UIPasteboard</a>提供了对大部分类实例兼容类型的声明，以及提供了对剪贴板内对象的生命周期进行限制的选项</li>
<li><a href="https://developer.apple.com/reference/uikit/uipasteboard" target="_blank" rel="external">UIPasteboard</a>的新选项</li>
<li><a href="https://developer.apple.com/reference/uikit/uifont" target="_blank" rel="external">UIFont</a>的<code>preferredFontForTextStyle:compatibleWithTraitCollection:</code>方法提供了对labels、text fields和其他文本控件的动态字体支持</li>
<li>当设备的<code>UIContentSizeCategory</code>改变时<code>UIContentSizeCategoryAdjusting</code>协议提供了<code>adjustsFontForContentSizeCategory</code>属性来帮你更新相关的字体</li>
<li>对tab bar item的badge外观的更多控制，诸如背景颜色和text attributes</li>
<li>所有的scrol view及其子类都支持refresh control了</li>
<li><a href="https://developer.apple.com/reference/uikit/uiapplication" target="_blank" rel="external">UIApplication</a>的新方法<code>openURL:options:completionHandler:</code>为异步执行，并在主线程执行回调(这个方法将来要取代<a href="https://developer.apple.com/reference/uikit/uiapplication/1622961-openurl" target="_blank" rel="external">openURL:</a>)</li>
<li>新的<code>UICloudSharingController</code>类和<code>UICloudSharingControllerDelegate</code>协议可以初始化Cloudkit分享操作，并向用户展示一个相关配置选项的界面</li>
<li>增强了<a href="https://developer.apple.com/reference/uikit/uicollectionview" target="_blank" rel="external">UICollectionView</a>以及新增了<a href="https://developer.apple.com/reference/uikit/uicollectionviewdatasourceprefetching" target="_blank" rel="external">UICollectionViewDataSourcePrefetching</a>协议，通过提前获取cell的方式增强了滑动体验</li>
</ul>
<h5 id="WebKit"><a href="#WebKit" class="headerlink" title="WebKit"></a>WebKit</h5><p>WebKit框架(WebKit.framework)的<a href="https://developer.apple.com/reference/webkit/wkwebview" target="_blank" rel="external">WKWebView</a>增强了peek和pop操作。在iOS10上用户可以使用<a href="https://developer.apple.com/reference/webkit/wkuidelegate/1648359-webview" target="_blank" rel="external">webView:shouldPreviewElement:</a>方法来决定是否在指定的链接上显示预览页面。</p>
<h3 id="Deprecated-APIs"><a href="#Deprecated-APIs" class="headerlink" title="Deprecated APIs"></a>Deprecated APIs</h3><p>iOS10把下列的APIs标记为废弃：</p>
<ul>
<li><a href="https://developer.apple.com/reference/cloudkit/ckdiscoverallcontactsoperation" target="_blank" rel="external">CloudKit CKDiscoverAllContactsOperation</a>、<a href="https://developer.apple.com/reference/cloudkit/ckdiscovereduserinfo" target="_blank" rel="external">CKDiscoveredUserInfo</a>、<a href="https://developer.apple.com/reference/cloudkit/ckdiscoveruserinfosoperation" target="_blank" rel="external">CKDiscoverUserInfosOperation</a>, <a href="https://developer.apple.com/reference/cloudkit/ckfetchrecordchangesoperation" target="_blank" rel="external">CKFetchRecordChangesOperation</a>。作为替代可以使用 <a href="https://developer.apple.com/reference/cloudkit/ckdiscoveralluseridentitiesoperation" target="_blank" rel="external">CKDiscoverAllUserIdentitiesOperation</a>、<a href="https://developer.apple.com/reference/cloudkit/ckuseridentity" target="_blank" rel="external">CKUserIdentity</a>、<a href="https://developer.apple.com/reference/cloudkit/ckdiscoveruseridentitiesoperation" target="_blank" rel="external">CKDiscoverUserIdentitiesOperation</a>和 <a href="https://developer.apple.com/reference/cloudkit/ckfetchrecordzonechangesoperation" target="_blank" rel="external">CKFetchRecordZoneChangesOperation</a>。<br>多个<a href="https://developer.apple.com/reference/cloudkit/cksubscription" target="_blank" rel="external">CKSubscription</a>的APIs，比如zone-based subscriptions相关的方法和属性(用<code>CKRecordZoneSubscription</code>替代)</li>
<li><a href="NSPersistentStoreCoordinator">NSPersistentStoreCoordinator</a>相关的常量</li>
<li><a href="https://developer.apple.com/reference/uikit/uiviewcontroller" target="_blank" rel="external">UIViewController</a>中的<a href="https://developer.apple.com/reference/iad/adbannerview" target="_blank" rel="external">ADBannerView</a>和<a href="https://developer.apple.com/reference/iad/adinterstitialad" target="_blank" rel="external">ADInterstitialAd</a>类以及相关常量</li>
<li><a href="https://developer.apple.com/reference/spritekit/skuniform" target="_blank" rel="external">SKUniform</a>相关的浮点常量。可以在适当的情况下用<code>initWithName:vectorFloat2:</code>和<code>uniformWithName:matrixFloat2x2:</code>作为替代</li>
<li>UIkit相关的通知，诸如<a href="https://developer.apple.com/reference/uikit/uilocalnotification" target="_blank" rel="external">UILocalNotification</a>、<a href="https://developer.apple.com/reference/uikit/uimutableusernotificationaction" target="_blank" rel="external">UIMutableUserNotificationAction</a>、<a href="https://developer.apple.com/reference/uikit/uimutableusernotificationcategory" target="_blank" rel="external">UIMutableUserNotificationCategory</a>、<a href="https://developer.apple.com/reference/uikit/uiusernotificationaction" target="_blank" rel="external">UIUserNotificationAction</a>、<a href="https://developer.apple.com/reference/uikit/uiusernotificationcategory" target="_blank" rel="external">UIUserNotificationCategory</a>和<a href="https://developer.apple.com/reference/uikit/uiusernotificationsettings" target="_blank" rel="external">UIUserNotificationSettings</a>。请使用User Notifications框架作为替代(<a href="https://developer.apple.com/reference/usernotifications" target="_blank" rel="external">Notifications Framework Reference</a>)</li>
<li><a href="https://developer.apple.com/reference/watchkit/wkinterfacecontroller/1619516-handleactionwithidentifier" target="_blank" rel="external">handleActionWithIdentifier:forLocalNotification:</a>、<a href="https://developer.apple.com/reference/watchkit/wkinterfacecontroller/1619530-handleactionwithidentifier" target="_blank" rel="external">handleActionWithIdentifier:forRemoteNotification:</a>、<a href="https://developer.apple.com/reference/watchkit/wkusernotificationinterfacecontroller/1619534-didreceivelocalnotification" target="_blank" rel="external">didReceiveLocalNotification:withCompletion:</a>和 <a href="https://developer.apple.com/reference/watchkit/wkusernotificationinterfacecontroller/1619568-didreceiveremotenotification" target="_blank" rel="external">didReceiveRemoteNotification:withCompletion:</a>等方法。请使用<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate/1628138-handleactionwithidentifier" target="_blank" rel="external">handleActionWithIdentifier:forNotification:</a>和<a href="https://developer.apple.com/reference/watchkit/wkusernotificationinterfacecontroller/1648287-didreceive" target="_blank" rel="external">didReceiveNotification:withCompletion:</a>作为替代。<br>同样还有<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate" target="_blank" rel="external">WKExtensionDelegate</a>的通知处理方法，诸如<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate/1628170-didreceiveremotenotification" target="_blank" rel="external">didReceiveRemoteNotification:</a>和<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate/1628138-handleactionwithidentifier" target="_blank" rel="external">handleActionWithIdentifier:forRemoteNotification:</a>作为使用上述方法的替代方案，首先实例化一个遵循<a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenterdelegate" target="_blank" rel="external">UNUserNotificationCenterDelegate</a>协议的托对象并实现适当的方法，然后把这个实例对象赋值给<a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenter" target="_blank" rel="external">UNUserNotificationCenter</a>单例的<a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenter/1649522-delegate" target="_blank" rel="external">delegate</a>属性</li>
</ul>
<p>完整的API废弃列表请看<a href="https://developer.apple.com/library/content/releasenotes/General/iOS10APIDiffs/index.html" target="_blank" rel="external">iOS 10.0 API Diffs</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[项目中Cell自动计算行高的实践]]></title>
      <url>http://yoursite.com/2016/09/13/cell-height-calc-with-autolayout/</url>
      <content type="html"><![CDATA[<h1 id="项目中Cell自动计算行高的实践"><a href="#项目中Cell自动计算行高的实践" class="headerlink" title="项目中Cell自动计算行高的实践"></a>项目中Cell自动计算行高的实践</h1><h3 id="在前面总该说些什么"><a href="#在前面总该说些什么" class="headerlink" title="在前面总该说些什么"></a>在前面总该说些什么</h3><p>这篇文章是对团队最近关于使用Autolayout对Cell进行高度计算的总结。</p>
<hr>
<p>接下来你将会看到以下内容：</p>
<blockquote>
<ul>
<li>数据和UI分离式的Cell高度计算的弊端</li>
<li>Self-Sizing Cell的解决方案</li>
<li>UITableView+FDTemplateLayoutCell简介</li>
<li>UITableView+FDTemplateLayoutCell代码分析</li>
<li>UITableView+FDTemplateLayoutCell集成</li>
</ul>
</blockquote>
<h3 id="数据和UI分离式的Cell高度计算的弊端"><a href="#数据和UI分离式的Cell高度计算的弊端" class="headerlink" title="数据和UI分离式的Cell高度计算的弊端"></a>数据和UI分离式的Cell高度计算的弊端</h3><p>通过数据模型的方式计算行高，这样的方式已经从ios4延伸到ios9了，这种方式的核心是在cell或者model里面提供一个方法，传入数据，然后根据内容+各种Margin计算出cell的高度。但是这种方法有个巨大的缺陷就是数据和界面是割裂的，你不得不在调完了UI后还要去计算高度的方法里再改一通。阅读和维护这部分逻辑时也会比较麻烦</p>
<p>或许已经有人想到了把计算高度的方法放到cel里面，然后把那些Margin做成常量，然后把数据传入cell来计算高度，这样当你修改内部的Margin时，高度计算的方法会不用做任何修改。不错，这个办法已经部分解决了上面的部分问题。不过当你调整UI以后对应的高度计算方法肯定会需要根据UI重写一遍，上述的问题还是存在。那有没有什么更简单的方法呢</p>
<p>答案是肯定的。苹果在iOS8提出了Self-Sizing Cell的概念。只要你用Autolayout对cell进行约束布局，当约束足够清晰时，Cell就能自动计算出自己的高度。如果后续UI有变化，也仅仅只需要调整控件以及相关的约束就行。</p>
<h3 id="Self-Sizing-Cell的解决方案"><a href="#Self-Sizing-Cell的解决方案" class="headerlink" title="Self-Sizing Cell的解决方案"></a>Self-Sizing Cell的解决方案</h3><p>理想很丰满，现实很骨感。Self-Sizing Cell可以解决问题，但是它自身也有它自己的问题。</p>
<p>首先Self-Sizing Cell必须使用Autolayout布局，用Frame方式布局从iOS诞生就开始了，只要稍稍有点历史的项目，在维护中肯定会遇到用Frame布局的Cell。所以不能使用纯Autolayout布局的方案。</p>
<p>其次是Self-Sizing Cell本身的设计策略，导致它有一定的性能嫌疑。在iOS8之前，TableView会缓存下Cell的高度，反复滑动Cell不会重复计算；但是在iOS8以后，苹果认为Cell可能会随时改变大小（用户在设置里面调整字体什么的）所以不会做缓存了，这就导致了同一个Cell在反复滑动的时候会反复计算高度。</p>
<p>最后是iOS6、7、8三个版本中关于高度计算API不一致的问题：<br>在iOS6上，我们是在<code>tableView:heightForRowAtIndexPath:</code>方法里返回通过数据计算的高度；而在在iOS7中，出现了<code>estimatedRowHeight</code>相关的属性，苹果通过这个属性把计算的工作从TableView加载时延迟到了Cell出现时，提高了TableView的加载速度；在iOS8中只需要写<code>self.tableView.estimatedRowHeight = RowHeight</code>这样的一行代码就能自动计算出Cell的高度(前提是Cell使用Autolayout写的布局)。可以看到随着苹果对Cell高度计算的不断优化让代码越来越简单，但是越简单的API需要的iOS版本越高，如果App要兼容低版本，就不得不在工程里写很多冗余的兼容性代码。</p>
<p>那如何能解决上面的这些问题呢，答案就是<code>UITableView+FDTemplateLayoutCell</code>。</p>
<h3 id="UITableView-FDTemplateLayoutCell简介"><a href="#UITableView-FDTemplateLayoutCell简介" class="headerlink" title="UITableView+FDTemplateLayoutCell简介"></a><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">UITableView+FDTemplateLayoutCell</a>简介</h3><p>关于UITableView+FDTemplateLayoutCell我就直接把<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">作者</a>的原话扒过来。</p>
<blockquote>
<p>使用<code>UITableView+FDTemplateLayoutCell</code>无疑是解决算高问题的最佳实践之一，既有 iOS8<br>self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。 使用起来大概是这样： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">&gt;     return [tableView fd_heightForCellWithIdentifier:@&quot;identifer&quot; cacheByIndexPath:indexPath configuration:^(id cell) &#123;</div><div class="line">&gt;         // 配置 cell 的数据源，和 &quot;cellForRow&quot; 干的事一致，比如：</div><div class="line">&gt;         cell.entity = self.feedEntities[indexPath.row];</div><div class="line">&gt;     &#125;]; &#125; </div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>写完上面的代码后，你就已经使用到了：</p>
<ul>
<li>和每个 UITableViewCell ReuseID 一一对应的 template layout cell<br>这个 cell 只为了参加高度计算，不会真的显示到屏幕上；它通过 UITableView 的 <code>-dequeueCellForReuseIdentifier:</code> 方法 lazy 创建并保存，所以要求这个 ReuseID 必须已经被注册到了 UITableView 中，也就是说，要么是 Storyboard 中的原型 cell，要么就是使用了 UITableView 的 <code>-registerClass:forCellReuseIdentifier:</code> 或 <code>-registerNib:forCellReuseIdentifier:</code>其中之一的注册方法。</li>
<li>根据 autolayout 约束自动计算高度<br>使用了系统在 iOS6 就提供的 API：<code>-systemLayoutSizeFittingSize:</code></li>
<li>根据 index path 的一套高度缓存机制<br>计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了非常可观的多余计算。</li>
<li>自动的缓存失效机制<br>无须担心你数据源的变化引起的缓存失效，当调用如<code>-reloadData</code>，<code>-deleteRowsAtIndexPaths:withRowAnimation:</code>等任何一个触发 UITableView 刷新机制的方法时，已有的高度缓存将以最小的代价执行失效。如删除一个 indexPath 为 [0:5] 的 cell 时，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。</li>
</ul>
</blockquote>
<h3 id="UITableView-FDTemplateLayoutCell代码分析"><a href="#UITableView-FDTemplateLayoutCell代码分析" class="headerlink" title="UITableView+FDTemplateLayoutCell代码分析"></a>UITableView+FDTemplateLayoutCell代码分析</h3><p>好了，上面说了<code>UITableView+FDTemplateLayoutCell</code>具有这么多功能，那这部分就来分析一下这些功能的实现方式。先说一下实现的方式路再上代码。</p>
<h4 id="高度计算"><a href="#高度计算" class="headerlink" title="高度计算"></a>高度计算</h4><p><code>UITableView+FDTemplateLayoutCell</code>在TableVie内部维护了一个模板Cell结构，它不会加入TableView中，模板Cell会自动调用Cell默认的方法实例化，然后根据传入的数据对这个模板进行填充，再计算高度。Cell的高度计算使用了两种方式，一种针对于Autolayout写的Cell调用<code>[cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize]</code>自动计算行高；另一种是对于Frame调用<code>[cell sizeThatFits:CGSizeMake(contentViewWidth, 0)]</code>手动计算行高。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>基于NSDictionary的缓存。如果调用的是带缓存的API，那在计算出高度后会缓存结果，下次再计算时会先查询缓存。这个框架已经把会引起TableView重新加载的方法都做了替换，在这些方法被调用时会先清空缓存再调用以前的方法。</p>
<p><code>- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration;</code></p>
<p>这个方法是高度计算的核心，API很简单，<code>identifier</code>是复用的标识，<code>configuration</code>主要用于你来用数据填充Cell<br>下面来看一下内部的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration &#123;</div><div class="line">    </div><div class="line">    UITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier];</div><div class="line">    </div><div class="line">    [templateLayoutCell prepareForReuse];</div><div class="line">    </div><div class="line">    if (configuration) &#123;</div><div class="line">        configuration(templateLayoutCell);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里为了突出主干逻辑，删掉了断言还有注释以及一部分非必要逻辑。从代码上看流程非常清晰，第一行获取到模板Cell，然后调用Cell的<code>prepareForReuse</code>方法来确保对Cell的调用行为和真实的一样(其实如果你所有的cell都没有在<code>prepareForReuse</code>方法里面写初始化代码的话，那这一行可有可无)。接着调用<code>configuration</code>来配置模板Cell，然后调用<code>[self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell]</code>来计算高度。</p>
<p>下面来深入<code>fd_systemFittingHeightForConfiguratedCell:</code>这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)fd_systemFittingHeightForConfiguratedCell:(UITableViewCell *)cell &#123;</div><div class="line">    CGFloat contentViewWidth = CGRectGetWidth(self.frame);</div><div class="line">    </div><div class="line"></div><div class="line">    if (cell.accessoryView) &#123;</div><div class="line">        contentViewWidth -= 16 + CGRectGetWidth(cell.accessoryView.frame);</div><div class="line">    &#125; else &#123;</div><div class="line">        static const CGFloat systemAccessoryWidths[] = &#123;</div><div class="line">            [UITableViewCellAccessoryNone] = 0,</div><div class="line">            [UITableViewCellAccessoryDisclosureIndicator] = 34,</div><div class="line">            [UITableViewCellAccessoryDetailDisclosureButton] = 68,</div><div class="line">            [UITableViewCellAccessoryCheckmark] = 40,</div><div class="line">            [UITableViewCellAccessoryDetailButton] = 48</div><div class="line">        &#125;;</div><div class="line">        contentViewWidth -= systemAccessoryWidths[cell.accessoryType];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    CGFloat fittingHeight = 0;</div><div class="line">    </div><div class="line">    if (!cell.fd_enforceFrameLayout &amp;&amp; contentViewWidth &gt; 0) &#123;</div><div class="line"></div><div class="line">        NSLayoutConstraint *widthFenceConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:contentViewWidth];</div><div class="line">        [cell.contentView addConstraint:widthFenceConstraint];</div><div class="line">        </div><div class="line">        fittingHeight = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;</div><div class="line">        [cell.contentView removeConstraint:widthFenceConstraint];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (fittingHeight == 0) &#123;</div><div class="line">        fittingHeight = [cell sizeThatFits:CGSizeMake(contentViewWidth, 0)].height;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    return fittingHeight;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法首先获取到Cell的宽度，得到宽度后根据是否有自定义的accessoryView来调整Cell的宽度。（这里关于关于静态数组systemAccessoryWidths的使用可能不太常见，这个是C的写法，就是静态不定长度的数组的初始化，这里面数组的长度等于花括号里面给出的最大索引值+1，其他没有给定明确初始值的都是0）然后调用 <code>[cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize]</code>来自动计算出Cell的高度，这里在计算之前临时添给Cell.contentView添加了一个和Cell等宽的约束是为了让内部View知道自己的父View的大小，减少因无法得知contentView的宽度而导致约束计算失败的情况。最后一步是判断Autolayout计算的结果是否正确，因为需要兼容使用Frame布局的Cell的情况，当Autolayout计算失败后再尝试着调用<code>[cell sizeThatFits:CGSizeMake(contentViewWidth, 0)]</code>来计算高度。</p>
<p>下面来看带缓存的方法:</p>
<p><code>- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration</code></p>
<p><code>- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id&lt;NSCopying&gt;)key configuration:(void (^)(id cell))configuration</code></p>
<p>这两个方法一个是按IndexPath做缓存一个是按Key做缓存。两者都是基于NSDictionary实现的，按Key缓存比较简单，内部实现基本上可以理解为cache[Key]=rowHeight这样的形式，具体的代码就不赘述。IndexPath缓存因为涉及IndexPath数组的增删改的操作而稍稍复杂一点，不过虽然比前者复杂但是本质也是在维护一个NSDictionary，这里就不再详细介绍，而是讲一下IndexPath缓存中实现的比较有意思的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)buildSectionsIfNeeded:(NSInteger)targetSection &#123;</div><div class="line">    [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123;</div><div class="line">        for (NSInteger section = 0; section &lt;= targetSection; ++section) &#123;</div><div class="line">            if (section &gt;= heightsBySection.count) &#123;</div><div class="line">                heightsBySection[section] = [NSMutableArray array];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法里面有意思的地方在于当你传入的Section如果大于当前的最大Section时，会自动创建后续的所有Section，比如现在Section数组有3个元素，然后你的入参为20，那这个循环会创建剩下的17个Section数组。这里作者用到了一个NSMutableArray的一个不太常用的语法，就是<code>NSMutableArray[最大索引值]=NewItem</code>，这个等价于<code>[NSMutableArray addObject:NewItem]</code>，使用不太常见的语法让代码更精炼的例子在这个框架里面还有几个，可见作者OC的基本功非常扎实。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)fd_deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation &#123;</div><div class="line">        [sections enumerateIndexesUsingBlock:^(NSUInteger section, BOOL *stop) &#123;</div><div class="line">            [self.fd_indexPathHeightCache buildSectionsIfNeeded:section];</div><div class="line">            [self.fd_indexPathHeightCache enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123;</div><div class="line">                [heightsBySection removeObjectAtIndex:section];</div><div class="line">            &#125;];</div><div class="line">        &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)fd_moveSection:(NSInteger)section toSection:(NSInteger)newSection &#123;</div><div class="line">        [self.fd_indexPathHeightCache buildSectionsIfNeeded:section];</div><div class="line">        [self.fd_indexPathHeightCache buildSectionsIfNeeded:newSection];</div><div class="line">        [self.fd_indexPathHeightCache enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123;</div><div class="line">            [heightsBySection exchangeObjectAtIndex:section withObjectAtIndex:newSection];</div><div class="line">        &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分代码有意思的地方是作者的编程的思路。删除或者移动索引的时候可能相应的索引可能并不存在，有的人会在这里先判断，然后根据不同情况做不同的处理，这样做肯定是没问题的。不过作者在这里的做法是统统调一遍<code>[self.fd_indexPathHeightCache buildSectionsIfNeeded:section]</code>保证索引肯定存在，避免了加一些冗长的判断语句，代码比显得较干净。这里把未知问题转换成已知问题的思路体现得淋漓尽致，而且特别能体现出程序设计的模块化设计与复用的美感。</p>
<p>好了，到这里<code>UITableView+FDTemplateLayoutCell</code>的分析就写完了，可能有的人会感觉怎么才这点东西。东西确实不多，因为这个框架本身很简单，全部代码加上注释才600多行代码。不过见微知著，寥寥几百行代码体现了作者良好的编程思维以及扎实的语言基本功。这也是我们需要学习的地方。</p>
<h3 id="UITableView-FDTemplateLayoutCell集成"><a href="#UITableView-FDTemplateLayoutCell集成" class="headerlink" title="UITableView+FDTemplateLayoutCell集成"></a>UITableView+FDTemplateLayoutCell集成</h3><p>其实最后一部分内容很少。主要是针对于老的使用Frame布局的Cell使用这个框架的实践。前面也说过如果用Autolayout的Cell是自动计算的，Frame布局的Cell是通过<code>[cell sizeThatFits:CGSizeMake(contentViewWidth, 0)]</code>来做，所以需要把Frame布局的Cell的<code>sizeThatFits</code>方法重载，因为<code>sizeThatFits</code>方法没有入参，所以需要让Cell持有数据Model，然后在<code>sizeThatFits</code>里调用以前计算高度的方法就行了。这里Cell持有数据Model可以用weak的属性来修饰，避免可能的引用循环问题。</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>他山之石，可以攻玉。这篇文章的核心就是基于<code>UITableView+FDTemplateLayoutCell</code>的工程实践，感谢作者sunnyxx的无私奉献。sunnyxx的博客中还有不少有深度的iOS技术分析。这里贴一下他的</p>
<p><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">博客地址：</a><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/</a></p>
<p><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">GitHub地址：</a><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS worst practice]]></title>
      <url>http://yoursite.com/2015/11/28/iOS-worst-practice/</url>
      <content type="html"><![CDATA[<h1 id="iOS-worst-practice"><a href="#iOS-worst-practice" class="headerlink" title="iOS worst practice"></a>iOS worst practice</h1><p>最近在重构公司的项目，随着对项目的逐渐深入（被坑的次数越来越多），被各路大牛的神迹所折服，以至于感觉这些人是不是我们竞争对手派来的卧底。这些坑可以算是iOS worst practice了，在这里总结一下。</p>
<h2 id="命名的问题"><a href="#命名的问题" class="headerlink" title="命名的问题"></a>命名的问题</h2><p>给变量或者类以及方法起名能从一个侧面反映出一个程序员的水平以及项目的管理情况。在这个项目中，方法名、变量名和类名都没有统一，而且相关业务命名也没有规定。比如用于引导页面就有<code>TechView</code>、<code>IntroduceView</code>、<code>guideView</code>等，而下面的这些命名真是让人看了直接让人凌乱：</p>
<p>方法：</p>
<p><code>-(void)preTeachView2KnowActionWithNoShow:(UIButton *)sender</code></p>
<p><code>-(void)setTableView_Up_Down_NoHidden</code></p>
<p>变量：</p>
<p><code>#define fuckvalue   -34</code></p>
<p><code>_info_tmp</code></p>
<p><code>NSString *fuck1;</code></p>
<p><code>NSString *fuck2;</code></p>
<p>类:</p>
<p><code>@interface New_AdPersonViewController : New_PersonDetailViewController</code></p>
<h2 id="代码复用性"><a href="#代码复用性" class="headerlink" title="代码复用性"></a>代码复用性</h2><p>不会Ctrl-C/Ctrl-V的程序员不是好程序员，不过有些人玩得太high了，看你的工程中到处都是下面这些代码的时候你是什么感觉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    UITableViewCell *cell;</div><div class="line">    if(indexPath.section == 0)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:0];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 1)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:1];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 2)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:2];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 3)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:3];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 4)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:4];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 5)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:5];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 6)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:6];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 7)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:7];</div><div class="line">    &#125;</div><div class="line">    else if(indexPath.section == 8)</div><div class="line">    &#123;</div><div class="line">        cell = [self setTableView:tableView CellForRowAtIndexPath:indexPath section:8];</div><div class="line">    &#125;</div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> NSString *sectionTitle = @&quot;&quot;;</div><div class="line">        if(indexPath.section == 0)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:0];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 1)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:1];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 2)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:2];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 3)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:3];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 4)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:4];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 5)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:5];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 6)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:6];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 7)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:7];</div><div class="line">        &#125;</div><div class="line">        else if(indexPath.section == 8)</div><div class="line">        &#123;</div><div class="line">            sectionTitle = [_arraySections objectAtIndex:8];</div><div class="line">         &#125;</div></pre></td></tr></table></figure>
<p>反正我看了第一感觉是，我x、原来以前公司发工资是按代码行数算钱的······</p>
<h2 id="没有面向对象思想"><a href="#没有面向对象思想" class="headerlink" title="没有面向对象思想"></a>没有面向对象思想</h2><ul>
<li>在ViewController基类中放一些特定的业务逻辑，然后所有的子类中都有一堆阴魂不散的代码</li>
<li>该封装的不封装，完成同样功能的函数在每个用到的地方都一个copy，一旦逻辑变动，改起来真心好爽</li>
<li>不该封装的乱封装，封装的暴露的方法完全不知道是干什么的，想要类运行还必须先设定某些它所依赖的全局变量</li>
</ul>
<h2 id="滥用单例、通知"><a href="#滥用单例、通知" class="headerlink" title="滥用单例、通知"></a>滥用单例、通知</h2><p>实际上工程里面单例就一个，不过单例对象把所有的活都干，所以可以理解为整个工程的架构，都是面向过程的，全部模块水乳交融、浑然一体。用户数据保存靠这个单例、具体页面数据设置靠靠这个单例、应用行为配置靠靠这个单例······然后大部分的ViewController想要正常工作都得提前把所需的数据在这个单例中配置好，想想都佩服那些大神的记忆力；对于滥用通知的后果和单例一样，当你见到一个控制器中有一二十条通知齐刷刷地写在初始化方法里的时候有什么感觉。想想都有点小激动，你确定不是在逗我？</p>
<h2 id="各种脑洞大开的实现"><a href="#各种脑洞大开的实现" class="headerlink" title="各种脑洞大开的实现"></a>各种脑洞大开的实现</h2><p>看见一个函数名叫做addRequestQueue的时候你会有什么反应，大部分人肯定想着肯定会是生成请求实例、有请求队列对它们进行管理······对此我只能说大神的想象力是无穷的，这个addRequestQueue是用<strong>递归的方式</strong>发送的请求，在网络请求成功或失败的闭包中会再次调用自己发送请求，这时候我终于明白这个队列是在哪儿了。</p>
<p>类似的例子还有很多，一次次的被大神的想象力所折服！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Autolayout笔记:自定义View]]></title>
      <url>http://yoursite.com/2015/07/25/Autolayout-%E8%87%AA%E5%AE%9A%E4%B9%89View/</url>
      <content type="html"><![CDATA[<h1 id="Autolayout笔记-自定义View"><a href="#Autolayout笔记-自定义View" class="headerlink" title="Autolayout笔记:自定义View"></a>Autolayout笔记:自定义View</h1><p>如果你想在自定义View里用Autolayout进行布局的话，有下面几个点需要注意：</p>
<ul>
<li>指定Intrinsic Content Size</li>
<li>区分frame和alignment rect</li>
<li>是否支持baseline-aligned布局</li>
<li>对子视图进行精确的布局控制</li>
</ul>
<p>下面将从这些方面逐步讲解。</p>
<h2 id="指定Intrinsic-Content-Size"><a href="#指定Intrinsic-Content-Size" class="headerlink" title="指定Intrinsic Content Size"></a>指定Intrinsic Content Size</h2><p>这部分的基本概念在上一篇文章已经讲过，这里不再赘述，主要注意三点：</p>
<ol>
<li>重写<code>intrinsicContentSize</code>方法。如果这个视图只有一个方向的尺寸设置了Intrinsic Size，那么为另一个方向的尺寸返回 <code>UIViewNoIntrinsicMetric</code>/<code>NSViewNoIntrinsicMetric</code>。</li>
<li>当view的某些属性的改变会影响到Intrinsic Content Size时，需要调用<code>invalidateIntrinsicContentSize</code>，例如当UILabel的text变化时，就需要重新计算Intrinsic Content Size。</li>
<li>当实现了<code>intrinsicContentSize</code>方法后，如果想进一步控制当View的实际大小和intrinsicContentSize`冲突时的行为，需要实现Compression Resistance和Content Hugging这方面的方法，具体做法请看<a href="http://blog.csdn.net/yongyinmg/article/details/39526207" title="yongyinmg的专栏" target="_blank" rel="external">这里</a></li>
</ol>
<h2 id="区分frame和alignment-rect"><a href="#区分frame和alignment-rect" class="headerlink" title="区分frame和alignment rect"></a>区分frame和alignment rect</h2><p>Autolayout系统的布局操作是基于alignment rect而非frame。绝大部分情况下它们是一样的，但是当你设置了<code>alignmentRectInsets</code>或者重写了<code>alignmentRectForFrame:</code>和<code>frameForAlignmentRect:</code>时就需要注意两者的差异。</p>
<p><img src="/images/Autolayout-2/pic_1-1.png" alt="img"></p>
<p>如图所示，Autolayout所有的约束（包括指定宽和高）都施加在alignment rect上，当你指定了<code>alignmentRectInsets</code>后View的frame是根据alignment rect和<code>alignmentRectInsets</code>计算出来的。上图里给view添加了left=80、top=100、width=100和height=100约束，使alignment rect上left为80、top为100、width为100、height为100，然后Autolayout系统根据alignmentRectInsets计算出view的frame，这里frame就是</p>
<p>{<br><code>alignmentRect.left-alignmentRectInsets.left</code>,<br><code>alignmentRect.top-alignmentRectInsets.top</code>,<br><code>alignmentRect.width+alignmentRectInsets.left+alignmentRectInsets.right</code>,<br><code>alignmentRect.height+alignmentRectInsets.top+alignmentRectInsets.bottom</code><br>}</p>
<p>即{<code>60</code>,<code>80</code>,<code>140</code>,<code>140</code>}</p>
<h2 id="是否支持baseline-aligned布局"><a href="#是否支持baseline-aligned布局" class="headerlink" title="是否支持baseline-aligned布局"></a>是否支持baseline-aligned布局</h2><p>如果需要支持baseline布局，就需要实现<code>viewForBaselineLayout</code>(iOS平台) ，系统默认实现只是简单地返回<code>self</code>。如果重写这个方法它返回的View的底边会作为baseline，而且这个View必须是你自定义View的子视图。在OS X中实现baseline布局需要重写<code>baselineOffsetFromBottom</code>返回一个从视图底部边缘开始的offset，默认返回0。</p>
<p>如果自定义View的frame和alignment rect不一样（设置了<code>alignmentRectInsets</code>或者重写了<code>alignmentRectForFrame:</code>和<code>frameForAlignmentRect:</code>）需要注意Autolayout布局是施加在alignment rect上的，自定义的view的最终位置是由<code>viewForBaselineLayout</code>和<code>alignmentRectInsets</code>共同决定的。</p>
<h2 id="如何对子视图进行精确的布局控制"><a href="#如何对子视图进行精确的布局控制" class="headerlink" title="如何对子视图进行精确的布局控制"></a>如何对子视图进行精确的布局控制</h2><p><strong>给子视图添加Constraints</strong> 官方建议的方法是在 <code>updateConstraints</code>里添加子视图的Constraints，而且要保证 <code>[super updateConstraints]</code>一定要在你自己的Constraints添加完之后再调用。而且在这个方法里不能<em>“invalidate any constraints”</em>如果Constraints失效时，需要移除对应的Constraints，并调用<code>setNeedsUpdateConstraints</code>来刷新。</p>
<p>如果是用添加Constraints的方式给子视图布局的话，这个自定义视图就仅仅在Autolayout环境下才能正常工作，因此可以重写<code>requiresConstraintBasedLayout</code>方法返回YES来告知系统必须使用Autolayout布局。</p>
<p><strong>子视图布局</strong> 回顾一下之前说起过的Autolayout布局的3个步骤，当Update constraints阶段结束后，就进入Layout view阶段，此时就会调用<code>layoutSubviews</code>方法来根据Constraints计算出来的结果来调整view的<code>bounds</code>和<code>center</code>。因此在<code>layoutSubviews</code>方法里可以对布局进行任意的调整。</p>
<p>最极端的情况是重写<code>layoutSubviews</code>/<code>layout</code>时不调用父类的实现。这就意味着系统虽然根据Constraints计算出视图树的位置，但你并没有应用计算的结果，换言之就是你在这个视图中完全放弃Autolayout布局，完全根据自己的意愿对子视图进行布局。</p>
<p>如果你仍然想使用Autolayout布局子视图，你可以先调用<code>[super layoutSubviews]</code>/<code>[super layout]</code>，然后对布局进行微调。这样可以创建一些通过Constraints无法实现的布局，比如，由到视图大小之间的关系或是视图之间间距的关系来定义的布局。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a style="text-decoration:none;color:#1D39DD" href="http://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/" target="_blank" rel="external"><br>《Advanced Auto Layout Toolbox》 - objc.io</a></li>
<li><a style="text-decoration:none;color:#1D39DD" href="http://blog.csdn.net/yongyinmg/article/details/39526207" target="_blank" rel="external">《AutoLayout中的Content Hugging 和 Content Compression Resistance》 - yongyinmg的专栏</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Autolayout笔记:基本概念]]></title>
      <url>http://yoursite.com/2015/07/18/AutoLayout-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h1 id="Autolayout笔记-基本概念"><a href="#Autolayout笔记-基本概念" class="headerlink" title="Autolayout笔记:基本概念"></a>Autolayout笔记:基本概念</h1><p>AutoLayout使用非常简单，Xcode的支持也非常直观。但是因为和之前的方式有很大的不同，学习曲线比较陡峭，所以给新手造成一些心理负担，下面我将通过一些列的文章来给大家简单的讲解一下Autolayout的基本用法。</p>
<p>AutoLayout是一个基于约束的布局系统。描述各种约束的行为，比如一个View 距离父View上边距多少，相邻之间的间隔多少，各个View之间的宽高关系等等。这一系列的条件就是为了最终确定之前提到的传统布局中需要的东西，这个View的大小、位置。所以，当我们设置的条件不足，或是条件冲突时，就会产生异常。</p>
<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>上面说了Autolayout是基于约束的，约束在iOS/OS X里面就是Constraint，让我们看看新建一个Constraint的API是怎样的：</p>
<pre><code>NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:item1
                                                                   attribute:NSLayoutAttributeLeft
                                                                   relatedBy:NSLayoutRelationEqual
                                                                      toItem:item2
                                                                   attribute:NSLayoutAttributeLeft
                                                                  multiplier:1
                                                                    constant:10];
</code></pre><p>这里的参数比较多，但仔细看可以发现它表述了这样一种关系：<br><strong>Item. Attribute relatedBy toItem. Attribute * multiplier + constant</strong>。用人话解释一遍就是一个view的某个属性在位置上和另外一个view的某个属性有一定关系。举个例子比如说我想表达view1的右边和view2的左边相互紧挨着，那应该这么写<br><strong>View1.右边 = view2.左边 * 1 + 0</strong><br>这里的<code>=</code>表示的是位置相同的意思，另外除了等于以外还有<code>≤</code>和<code>≥</code>同样它们都是表示位置上关系。完成一个constraint后需要把它添加到constraint所关联的iteam的共同superView上。</p>
<p><strong>需要注意的是constraints是累积的，它们之间是不能互相覆盖。</strong>如果你有一个constraints，你再添加一个同类型的constraints并不覆盖前一个。</p>
<h2 id="Intrinsic-Content-Size"><a href="#Intrinsic-Content-Size" class="headerlink" title="Intrinsic Content Size"></a>Intrinsic Content Size</h2><p>苹果在使用Autolayout的原则里有一条是<strong>“视图是趋于自治的”</strong>，因此苹果鼓励用户在自定义view时自己实现Intrinsic Content Size，让view自己决定自己的大小。</p>
<p>Intrinsic Content Size指的是view能显示内容的最佳尺寸。例如，UILabel的最佳高度取决于它的字体大小，它的最佳宽度取决于它的字体还有所显示的内容。一个UIProgressView的最佳高度取决于它的样式，而宽度则没有要求。一个空白的UIView则在宽度和高度上都没有要求。</p>
<p>如果一个自定义的view的大小和其所显示的内容有关的话，就需要实现Intrinsic Content Size相关的方法。在实现Intrinsic Content Size的相关方法时你需要做两件事情：</p>
<ol>
<li>重写intrinsicContentSize方法，根据view显示的内容返回合适的intrinsic content size；</li>
<li>在有些影响到Intrinsic Content Size的情况发生的时候调用<code>invalidateIntrinsicContentSize</code>例如当UILabel的文本内容变化的时候就需要调用上述的方法。如果view只有在某一个维度上有Intrinsic Content Size，那在另一个维度上返回<code>UIViewNoIntrinsicMetric</code>或者<code>NSViewNoIntrinsicMetric</code>就可以了。</li>
</ol>
<p><strong>需要注意的是intrinsic content size不能依赖view的frame。</strong>例如根据frame按比例返回intrinsic content size就是不可行的。</p>
<h2 id="Sprint-amp-struts-VS-Autolayout"><a href="#Sprint-amp-struts-VS-Autolayout" class="headerlink" title="Sprint&amp;struts VS. Autolayout"></a>Sprint&amp;struts VS. Autolayout</h2><p>在Autolayout出现之前，我们使用<code>autoresizingMask</code>来描述当父视图的尺寸变化时子视图的动作。现在autolayout里使用Compression Resistance 和 Content Hugging来替代它们。不过为了兼容<code>autoresizingMask</code>，UIView在iOS6之后添加了一个新属性<code>translatesAutoResizingMaskIntoConstraints</code>(默认为YES)来自动把<code>autoresizingMask</code>转换成Constraints。</p>
<p>在这里可能会有人问那在Autolayout环境下还能继续使用设置frame的方式进行布局吗。答案肯定是<strong>能</strong>，因为Autolayout系统仅仅是在frame布局的过程前面添加了一个计算约束的过程，最后计算好的结果还是通过frame来应用的。</p>
<p><strong>这里可能会有人有过在Autolayout环境下设置frame不生效的经历</strong>，这里简单说下为什么。如果<code>requiresConstraintBasedLayout</code>被设置为<code>YES</code>则只能使用Autolayout进行布局，<br>否则就看<code>translatesAutoresizingMaskIntoConstraints</code>的设置，如果是YES则Autolayout和frame都可以进行布局，如果为NO则需要继续看是否存在<code>intrinsicContentSize</code>，如果存在则只能用Autolayout布局、不存在则Autolayout和frame都可以进行布局。</p>
<p>你可以给view的每个维度(就是x方向和y方向)设置Compression Resistance、Content Hugging优先级。不过这个优先级仅仅对定义了intrinsic content size的view才会生效。</p>
<p>在iOS上可以用<code>setContentHuggingPriority:forAxis:</code> 和 <code>setContentCompressionResistancePriority:forAxis:</code> 分别设置优先级(如果是NSVIew则是<code>setContentHuggingPriority:forOrientation:</code> 和 <code>setContentCompressionResistancePriority:forAxis:</code>)优先级的默认值是<code>NSLayoutPriorityDefaultHigh</code>或 <code>NSLayoutPriorityDefaultLow</code>.</p>
<p>最后有一点需要注意，如果设定intrinsic content size和上述的优先级的话，系统把这些解释成一系列的constraint。例如一个label的intrinsic content size为{100,30}，x/y方向的compression resistance 优先级是750，Content Hugging优先级是250，这些条件会生成4个constraint：</p>
<pre><code>H:[label(&lt;=100@250)]
H:[label(&gt;=100@750)]
V:[label(&lt;=30@250)]
V:[label(&gt;=30@750)]
</code></pre><h2 id="Frame-VS-Alignment-Rect"><a href="#Frame-VS-Alignment-Rect" class="headerlink" title="Frame VS. Alignment Rect"></a>Frame VS. Alignment Rect</h2><p>Autolayout在布局的时候不是操作view的frame而是alignment rect。这两者有一些非常容易让人忽略的细小差异，在大部分情况下他们功能都一样，但在某些场合alignment rect的功能可能更强大。</p>
<p>大家可能都遇到过这样一种情况，一个button设置一个比较小的图片（或者图片周围有大面积的透明区）就会照成按钮看来很小，而且在布局的时候若以frame来做的话就会形成代码上是“对齐了”，但看起来就是“不整齐” 的情况，这是如果用alignment rect就会完美地解决这个问题。</p>
<p>用alignment rect可以很灵活地自定义用于layout的区域，大部分情况下仅仅需要重写alignmentRectInsets方法就行了，它会让你返回一个相对于frame的Inset。如果上面的方法还不能满足需求则可以重写<code>alignmentRectForFrame:</code>和<code>frameForAlignmentRect:</code>这两个方法，这两个方法可以让你更加灵活的根据frame来返回对应的alignment rect，需要注意的是这两个方法有互逆关系，你必须要保证frame和alignment rect能通过这两个方法互相转换。</p>
<p><img src="/images/Autolayout-1/pic_1-1.png" alt=""></p>
<h2 id="Baseline-alignment"><a href="#Baseline-alignment" class="headerlink" title="Baseline alignment"></a>Baseline alignment</h2><p>如果对自定义的view用<code>NSLayoutAttributeBaseline</code>的方式布局的话需要自己实现相关的方法。在iOS平台需要实现<code>viewForBaselineLayout</code>方法，方法返回的view的bottom edge将被用作baseline，系统默认实现是直接返回view本身。注意返回的view只能是此方法调用者本身或者子view。在OS X上你需要实现baselineOffsetFromBottom来返回基于view的bottom edge的一个offset，默认返回0。</p>
<h2 id="Phases-of-Display"><a href="#Phases-of-Display" class="headerlink" title="Phases of Display"></a>Phases of Display</h2><p>使用AutoLayout之后，把view显示到屏幕上面大体分成3步。</p>
<p><img src="/images/Autolayout-1/pic_1-2.png" alt=""></p>
<ol>
<li>Update constraints，就是更新约束，把所有的约束更新到最新状态；</li>
<li>Layout views，根据约束布局调整View之间的距离，大小；</li>
<li>Display，调用drawRect绘制view。</li>
</ol>
<p>下面来讲一下具体的工作流程。</p>
<p> <strong>Update constraints</strong> 这个过程是从底向上的(从<code>subview</code>到<code>supperview</code>)，你可以通过调用<code>setNeedsUpdateConstraints</code>来主动触发这个过程，你对constraint的任何更改都会导致系统自动调用这个方法。还可以重写<code>updateConstraints</code>方法来添加应用于自定义view内部的constraint。</p>
<p><strong>Layout view</strong> 这个过程是自顶向下的(从<code>super</code> view到<code>subview</code>)，这一步实际上是应用上一步的约束的结果的过程，根据约束调整view的<code>frame</code>(在OS X)，或者view的<code>center</code>和<code>bounds</code>(在iOS)。你可以调用<code>setNeedsLayout</code>方法来主动触发这个过程。</p>
<p><strong>Display</strong> 这个过程是也是自顶向下的，也可以调用<code>setNeedsDisplay</code>来主动触发这个过程，重写<code>drawRect:</code>来添加一些自定义的绘制代码这个相信大家都已经非常熟悉了。</p>
<p><strong>需要注意的是这3个步骤并不是严格按照顺序依次发生的。</strong>基于约束的布局是一个迭代的过程。layout的改变可以影响到生成上一次layout的constraint，当其他的layout改变后它能再次触发更新约束的过程。不过这个也存在死循环的风险，就是在其他的layout改变时调用你自己实现的<code>layoutSubviews</code>方法。</p>
<p><img src="/images/Autolayout-1/pic_1-3.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a style="text-decoration:none;color:#1D39DD" href="http://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/" target="_blank" rel="external"><br>《Advanced Auto Layout Toolbox》 - objc.io</a></li>
<li><a style="text-decoration:none;color:#1D39DD" href="http://studentdeng.github.io/blog/2014/06/13/auto-layout/" target="_blank" rel="external">《AutoLayout 相关概念介绍和动画demo》 - 不会开机的男孩</a></li>
<li><a style="text-decoration:none;color:#1D39DD" href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/Introduction/Introduction.html" target="_blank" rel="external">《Auto Layout Guide》 - Apple</a></li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
