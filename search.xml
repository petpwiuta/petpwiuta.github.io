<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Bochs调试常用命令]]></title>
      <url>http://petpwiuta.github.io/2020/05/09/Bochs%25E8%25B0%2583%25E8%25AF%2595%25E5%25B8%25B8%25E7%2594%25A8%25E5%2591%25BD%25E4%25BB%25A4/</url>
      <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>Bochs是做系统开发常用的虚拟机，调试系统内核很方便。</p>
<p>安装Bochs一般是从源码编译再安装，而调试器属于可选功能，所以在编译Bochs时需要使用<code>--enable-debugger</code>和<code>--enable-disasm</code>标志开启调试模块。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-debugger --enable-disasm #后面还有其他选项，此处省略</span><br></pre></td></tr></table></figure>
<p>需要注意调试功能在 <strong>2.5.4</strong> 版本以上才有，确保下载的代码是高于这个版本的。</p>
<h3 id="2-常见的几个使用场景"><a href="#2-常见的几个使用场景" class="headerlink" title="2 常见的几个使用场景"></a>2 常见的几个使用场景</h3><h4 id="2-1-查看寄存器"><a href="#2-1-查看寄存器" class="headerlink" title="2.1 查看寄存器"></a>2.1 查看寄存器</h4><p>汇编代码中，调试最常用的功能就是查看寄存器的内容。</p>
<ul>
<li><code>r</code>  查看通用寄存器</li>
<li><code>sreg</code>  查看段寄存器</li>
<li><code>creg</code>  查看控制寄存器</li>
<li><code>dreg</code>  查看调试寄存器</li>
<li><code>info cpu</code>  查看所有寄存器</li>
</ul>
<h4 id="2-2-查找和定位代码"><a href="#2-2-查找和定位代码" class="headerlink" title="2.2 查找和定位代码"></a>2.2 查找和定位代码</h4><p>次常用的肯定是控制代码执行流程，代码执行到想要仔细跟踪的那个部分。</p>
<ul>
<li><p><code>b 内存地址</code>  设置断点</p>
<p>如<code>b 0x7c00</code>，在线性地址0x7c00处设置断点。</p>
</li>
<li><p><code>info break</code>  查看设置过的断点</p>
</li>
<li><p><code>c</code>  继续执行代码</p>
<p>一般设置断点后，想让代码恢复执行，就使用这个命令。</p>
</li>
<li><p><code>s</code>  单步执行</p>
<p>单步执行一行代码，和高级语言调试器的step into按钮类似，遇到函数调用会跳转到函数内部执行。单步执行命令也可以带参数，指定执行的次数，如 <code>s 100</code> 就是单步执行100次。</p>
</li>
<li><p><code>n</code>  执行下一行</p>
<p>它和单步执行类似，单步执行遇到循环和函数时会跳转到内部，而n命令会执行完循环和函数，类似于step over，这样在遇到大量的循环或者较长的函数时，可以用n命令来执行到下一行。</p>
<p>n命令能跳转到下一行是因为loop或者call执行有明显的结束标记（前者通过cx寄存器，后者通ret指令），如果遇到用jmp语句写的循环这种情况，没有明显结束标记的，可以用下面的u命令反汇编代码的地址，找到循环的下一行指令的地址，然后给该地址加一个断点就能达到同样的效果。</p>
</li>
<li><p><code>u</code>  反汇编代码</p>
<p>直接使用u命令会反汇编当前执行的指令，它可以加参数， <code>u /反汇编数量 起始地址</code> ，如 <code>u /20 0x7c00</code> 就是从0x7c00处开始，反汇编20条指令，如果没有起始地址就是从当前地址开始。</p>
<p>它还可以反汇编一个范围的代码，<code>u 起始地址 结束地址</code> ，如<code>u 0x7c00 0x7cff</code> 就是反汇编0x7c00到0x7cff的代码。</p>
</li>
</ul>
<h4 id="2-3-查看内存"><a href="#2-3-查看内存" class="headerlink" title="2.3 查看内存"></a>2.3 查看内存</h4><ul>
<li><code>x /nuf 地址</code>  查看线性地址处的内存内容。</li>
<li><code>xp /nuf 地址</code>  查看物理地址处的内存内容。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n 指定要显示的内存单元的数量</span><br><span class="line">u 显示的内存单元的大小，如下参数之一</span><br><span class="line">	b 单个字节</span><br><span class="line">	h 半个字(2 字节)</span><br><span class="line">	w 一个字(4 字节)</span><br><span class="line">f 打印的格式。如下类型之一：</span><br><span class="line">	x 按照十六进制形式打印</span><br><span class="line">	d 按照十进制形式打印</span><br><span class="line">	u 以无符号的10进制打印</span><br><span class="line">	o 按照八进制形式打印</span><br><span class="line">	t 按照二进制行是打印</span><br></pre></td></tr></table></figure>
<h4 id="2-4-Tips"><a href="#2-4-Tips" class="headerlink" title="2.4 Tips"></a>2.4 Tips</h4><p>Bochs还有一个比较有用的设计就是，当你输入指令后，直接按回车键（Enter Key）会重复上一次的命令。比如上一个命令是单步执行<code>s</code>，此时直接按回车键就相当于<code>s</code>的功能。</p>
<h3 id="3-调试指令手册"><a href="#3-调试指令手册" class="headerlink" title="3 调试指令手册"></a>3 调试指令手册</h3><h4 id="3-1-执行控制"><a href="#3-1-执行控制" class="headerlink" title="3.1 执行控制"></a>3.1 执行控制</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>c</code> / <code>cont</code> / <code>continue</code></td>
<td style="text-align:left">继续执行</td>
</tr>
<tr>
<td style="text-align:left"><code>s</code> / <code>step</code> [count]</td>
<td style="text-align:left">执行count条指令，如果不指定参数，默认值为1</td>
</tr>
<tr>
<td style="text-align:left"><code>s</code> / <code>step</code> [cpu] [count]</td>
<td style="text-align:left">对于对称多处理器结构模拟，在cpu上执行count条指令，count的默认值为1</td>
</tr>
<tr>
<td style="text-align:left"><code>s</code> / <code>step</code> all [count]</td>
<td style="text-align:left">对于对称多处理器结构模拟，所有cpu上都执行count条指令，count的默认值为1</td>
</tr>
<tr>
<td style="text-align:left">Ctrl-C</td>
<td style="text-align:left">停止执行，返回到命令行提示符</td>
</tr>
<tr>
<td style="text-align:left">Ctrl-D</td>
<td style="text-align:left">如果在空行上执行，则退出调试器</td>
</tr>
<tr>
<td style="text-align:left"><code>q</code> / <code>quit</code> / <code>exit</code></td>
<td style="text-align:left">退出调试器，继续执行</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-2-断点操作"><a href="#3-2-断点操作" class="headerlink" title="3.2 断点操作"></a>3.2 断点操作</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">① <code>vbreak</code> / <code>vb</code> segment:offset</td>
<td style="text-align:left">设置虚拟地址指令断点，segment和offset指段地址和段内偏移量</td>
</tr>
<tr>
<td style="text-align:left">② <code>lbreak</code> / <code>lb</code> addr</td>
<td style="text-align:left">在线性地址指令上设置断点</td>
</tr>
<tr>
<td style="text-align:left">③ <code>pbreak</code> / <code>bp</code> [*] addr</td>
<td style="text-align:left">在物理地址上设置断点</td>
</tr>
<tr>
<td style="text-align:left">④ <code>break</code> / <code>b</code> [*] addr</td>
<td style="text-align:left">同上。  * 符号是兼容GDB命令，为可选参数</td>
</tr>
<tr>
<td style="text-align:left"><code>info break</code></td>
<td style="text-align:left">显示当前所有断点状态</td>
</tr>
<tr>
<td style="text-align:left"><code>bpe</code> n</td>
<td style="text-align:left">开启断点</td>
</tr>
<tr>
<td style="text-align:left"><code>bpd</code> n</td>
<td style="text-align:left">关闭断点</td>
</tr>
<tr>
<td style="text-align:left"><code>delete</code> / <code>del</code> / <code>d</code>  n</td>
<td style="text-align:left">删除断点</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意</strong>：① ② ③ ④ 的命令都可以设置条件，即都可以变成条件断点。具体做法是在命令之后添加<code>if condition</code> ，如<code>vbreak 0x008:0x001 if &quot;条件表达式&quot;</code></p>
<h4 id="3-3-内存观察点"><a href="#3-3-内存观察点" class="headerlink" title="3.3 内存观察点"></a>3.3 内存观察点</h4><p>内存观察点类似于内存的监听器，当指定地址的内存产生读取或者写入事件时，会产生中断。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>watch read/r</code> addr</td>
<td style="text-align:left">在物理地址addr上插入读观察点</td>
</tr>
<tr>
<td style="text-align:left"><code>watch write/w</code> addr</td>
<td style="text-align:left">在物理地址addr上插入一个写观察点</td>
</tr>
<tr>
<td style="text-align:left"><code>watch</code></td>
<td style="text-align:left">显示当前内存观察点的状态</td>
</tr>
<tr>
<td style="text-align:left"><code>watch stop</code></td>
<td style="text-align:left">当遇到观察点时，停止模拟执行（默认）</td>
</tr>
<tr>
<td style="text-align:left"><code>watch continue</code></td>
<td style="text-align:left">在遇到观察点时，不要停止模拟执行</td>
</tr>
<tr>
<td style="text-align:left"><code>unwatch</code> addr</td>
<td style="text-align:left">移除指定物理地址上的观察点</td>
</tr>
<tr>
<td style="text-align:left"><code>unwatch</code></td>
<td style="text-align:left">移除所有的观察点</td>
</tr>
<tr>
<td style="text-align:left"><code>trace-mem on/off</code></td>
<td style="text-align:left">开启/关闭 内存访问追踪</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-4-内存操作"><a href="#3-4-内存操作" class="headerlink" title="3.4 内存操作"></a>3.4 内存操作</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>x</code> /nuf addr</td>
<td style="text-align:left">在线性地址addr处检查内存内容，nuf的解释在前面列出</td>
</tr>
<tr>
<td style="text-align:left"><code>xp</code> /nuf addr</td>
<td style="text-align:left">在物理地址 addr处查看内存内容，nuf的解释在前面列出</td>
</tr>
<tr>
<td style="text-align:left"><code>setpmem</code> addr datasize value</td>
<td style="text-align:left">在内存位置addr处设置datasize大小内存，值为 value</td>
</tr>
<tr>
<td style="text-align:left"><code>writemem</code> filepath addr datasize</td>
<td style="text-align:left">从线性地addr处dump出datasize个字节到文件filepath中</td>
</tr>
<tr>
<td style="text-align:left"><code>crc</code> addr1 addr2</td>
<td style="text-align:left">显示物理地址范围 addr1到addr2之间内容的 CRC值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-5-查看信息"><a href="#3-5-查看信息" class="headerlink" title="3.5 查看信息"></a>3.5 查看信息</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>r</code> / <code>reg</code> / <code>regs</code> / <code>registers</code></td>
<td style="text-align:left">查看通用寄存器内容</td>
</tr>
<tr>
<td style="text-align:left"><code>fp</code> / <code>fpu</code></td>
<td style="text-align:left">查看FPU寄存器内容</td>
</tr>
<tr>
<td style="text-align:left"><code>mmx</code></td>
<td style="text-align:left">查看MMX寄存器内容</td>
</tr>
<tr>
<td style="text-align:left"><code>sse</code> / <code>xmm</code></td>
<td style="text-align:left">查看SSE寄存器内容</td>
</tr>
<tr>
<td style="text-align:left"><code>ymm</code></td>
<td style="text-align:left">查看AVX寄存器内容</td>
</tr>
<tr>
<td style="text-align:left"><code>sreg</code> / <code>dreg</code> / <code>creg</code></td>
<td style="text-align:left">查看 段 / 调试 / 控制 寄存器内容</td>
</tr>
<tr>
<td style="text-align:left"><code>info</code> cpu</td>
<td style="text-align:left">查看所有寄存器内容</td>
</tr>
<tr>
<td style="text-align:left"><code>info</code> eflags</td>
<td style="text-align:left">查看标志寄存器内容</td>
</tr>
<tr>
<td style="text-align:left"><code>info</code> break</td>
<td style="text-align:left">显示当前所有断点状态</td>
</tr>
<tr>
<td style="text-align:left"><code>info</code> tab</td>
<td style="text-align:left">显示分页地址转换</td>
</tr>
<tr>
<td style="text-align:left"><code>info</code> device</td>
<td style="text-align:left">显示指定设备的状态</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-6-寄存器操作"><a href="#3-6-寄存器操作" class="headerlink" title="3.6 寄存器操作"></a>3.6 寄存器操作</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>set</code> reg = expr</td>
<td style="text-align:left">修改reg寄存器值为expr</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意</strong>：只能修改通用寄存器和指令寄存器。不能够修改标志寄存器，段寄存器，浮点寄存器和SIMD寄存器。</p>
<h4 id="3-7-反汇编"><a href="#3-7-反汇编" class="headerlink" title="3.7 反汇编"></a>3.7 反汇编</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>u</code> addr1 addr2</td>
<td style="text-align:left">在给定的线性地址范围内反汇编指令，包含start处指令，不包含end处指令</td>
</tr>
<tr>
<td style="text-align:left"><code>u</code> switch-mode</td>
<td style="text-align:left">在Intel和 AT&amp;T两种汇编风格之间切换</td>
</tr>
<tr>
<td style="text-align:left"><code>u</code> size = n</td>
<td style="text-align:left">设定反汇编命令的位数，使用0，16，32。值0意思是使用当前的CS段寄存器，默认值是0</td>
</tr>
<tr>
<td style="text-align:left"><code>set u on</code></td>
<td style="text-align:left">每次停止执行时就自动反汇编当前的指令</td>
</tr>
<tr>
<td style="text-align:left"><code>set u off</code></td>
<td style="text-align:left">和上一条相反，不自动反汇编</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-8-指令跟踪"><a href="#3-8-指令跟踪" class="headerlink" title="3.8 指令跟踪"></a>3.8 指令跟踪</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>trace on</code></td>
<td style="text-align:left">反汇编每一条执行的指令。引起异常的指令都没有真正执行，因此也不会被跟踪</td>
</tr>
<tr>
<td style="text-align:left"><code>trace off</code></td>
<td style="text-align:left">关闭指令跟踪功能</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-9-指令编程环境"><a href="#3-9-指令编程环境" class="headerlink" title="3.9 指令编程环境"></a>3.9 指令编程环境</h4><p>Bochs的instrument功能，提供了运行时的各种钩子函数。它也是可选功能，在编译安装时需要开启<code>--enable-instrumentation</code>选项指定。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure [...] --enable-instrumentation</span><br><span class="line">./configure [...] --enable-instrumentation="instrument/stubs"</span><br></pre></td></tr></table></figure>
<p>自定义的代码要创建一个独立的目录，例如”instrument/myinstrument”，将”instrument/stubs”目录拷贝进去，然后使用如下的指令设定：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure [...] --enable-instrumentation="instrument/myinstrument"</span><br></pre></td></tr></table></figure>
<p>指令命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instrument [command]    用[command]调用BX_INSTR_DEBUG_CMD指令回调</span><br></pre></td></tr></table></figure>
<h4 id="3-10-show指令"><a href="#3-10-show指令" class="headerlink" title="3.10 show指令"></a>3.10 show指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>show</code></td>
<td style="text-align:left">打印当前的符号信息显示模式</td>
</tr>
<tr>
<td style="text-align:left"><code>show</code> mode</td>
<td style="text-align:left">当处理器切换模式时打印</td>
</tr>
<tr>
<td style="text-align:left"><code>show</code> int</td>
<td style="text-align:left">当产生中断时打印</td>
</tr>
<tr>
<td style="text-align:left"><code>show</code> call</td>
<td style="text-align:left">当产生调用时打印</td>
</tr>
<tr>
<td style="text-align:left"><code>show</code> ret</td>
<td style="text-align:left">当函数返回时打印</td>
</tr>
<tr>
<td style="text-align:left"><code>show</code> off</td>
<td style="text-align:left">关闭打印</td>
</tr>
<tr>
<td style="text-align:left"><code>show</code> dbg-all</td>
<td style="text-align:left">开启所有显示标志</td>
</tr>
<tr>
<td style="text-align:left"><code>show</code> dbg-none</td>
<td style="text-align:left">关闭所有显示标志</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-11-其他命令"><a href="#3-11-其他命令" class="headerlink" title="3.11 其他命令"></a>3.11 其他命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ptime</code></td>
<td style="text-align:left">打印当前的时间（从开始模拟到现在的ticks）</td>
</tr>
<tr>
<td style="text-align:left"><code>sb</code> delta</td>
<td style="text-align:left">在未来执行中插入一个时间断点delta。delta是一个64位的整数，跟着字母”L”，例如1000L</td>
</tr>
<tr>
<td style="text-align:left"><code>sba</code> time</td>
<td style="text-align:left">在时间time处插入一个时间断点 。time 同上面的delta</td>
</tr>
<tr>
<td style="text-align:left"><code>print-stack</code> [num]</td>
<td style="text-align:left">打印栈顶端的num个字</td>
</tr>
<tr>
<td style="text-align:left"><code>modebp</code></td>
<td style="text-align:left">触发CPU模式转换断点</td>
</tr>
<tr>
<td style="text-align:left"><code>ldsym</code> [global] filename [offset]</td>
<td style="text-align:left">从文件filename加载符号。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h3><ul>
<li><a href="http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html#AEN4220" target="_blank" rel="noopener">8.14. Using Bochs internal debugger</a></li>
<li><a href="http://bochs.sourceforge.net/cgi-bin/lxr/source/instrument/instrumentation.txt" target="_blank" rel="noopener">bochs/instrument</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> CS基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[进入32位保护模式（四）：中断和进程]]></title>
      <url>http://petpwiuta.github.io/2020/05/09/%25E8%25BF%259B%25E5%2585%25A532%25E4%25BD%258D%25E4%25BF%259D%25E6%258A%25A4%25E6%25A8%25A1%25E5%25BC%258F%25EF%25BC%2588%25E5%259B%259B%25EF%25BC%2589%25EF%25BC%259A%25E4%25B8%25AD%25E6%2596%25AD%25E5%2592%258C%25E8%25BF%259B%25E7%25A8%258B/</url>
      <content type="html"><![CDATA[<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断就是打断处理器当前的执行流程，去执行另外一些和当前工作不相干的指令，执行完之后，还可以返回到原来的程序流程继续执行。中断是处理器必备的机制，下面就来简单说一下中断的发生以及处理过程。</p>
<h4 id="外部硬件中断"><a href="#外部硬件中断" class="headerlink" title="外部硬件中断"></a>外部硬件中断</h4><p>从处理器外部产生的中断叫外部中断。事有轻重缓急，中断也分为两种，一种是必须要马上处理的，叫做非屏蔽中断（Non Maskable Interrupt，NMI）。另外一种可以允许延迟处理，叫可屏蔽中断（Interrupt，INTER）。这两种中断是各通过一条信号线引入处理器内部，所以总共有两条中断信号线接入处理器。</p>
<p>当中断发生时，处理器通过中断引脚NMI和INTR得到通知。此外它还应当知道发生了什么事，以便采取适当的处理措施。每种类型的中断都被统一编号，这称为中断类型号、中断向量或者中断号。</p>
<p><img src="/images/进入32位保护模式（四）：中断和进程/32Model_4_1.png" alt="32Model_4_1" style="zoom:50%;" /></p>
<h5 id="非屏蔽中断"><a href="#非屏蔽中断" class="headerlink" title="非屏蔽中断"></a>非屏蔽中断</h5><p>由于不可屏蔽中断的特殊性——几乎所有触发NMI的事件对处理器来说都是致命的，也不可恢复。所以这种情况下，就没有抢救的必要了。所以在实时模式下NMI中断的中断号统一都是2，不再区分更详细的情况。</p>
<h5 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h5><p>可屏蔽中断通过INTR引脚进入处理器，处理器每次只能处理一个中断。而且多个设备同时发出中断请求的几率也是很高的，所以需要一个中断代理来处理多设备以及并发仲裁的问题。在个人计算机中，用得最多的中断代理就是8259芯片，即中断控制器，从8086处理器开始，它就一直提供着这种服务。即使是现在，在绝大多数单处理器的计算机中，也依然有它的存在。</p>
<p>Intel处理器允许256个中断，中断号的范围是0~255，8259负责提供其中的15个，但中断号并不固定，允许软件根据自己的需要灵活设置中断号，以防止发生冲突。该中断控制器芯片有自己的端口号，可以像访问其他外部设备一样用in和out指令来改变它的状态，包括各引脚的中断号。所以它又叫可编程中断控制器。</p>
<p>每片8259只有8个中断输入引脚，而在个人计算机上使用它，需要两块。如图所示，第一块8259芯片的代理输出INT直接送到处理器的INTR引脚，这是主片（Master）；第二块8259芯片的INT输出送到第一块的引脚2上，是从片（Slave），两块芯片之间形成级联（Cascade）关系。</p>
<p><img src="/images/进入32位保护模式（四）：中断和进程/32Model_4_2.png" alt="32Model_4_2" style="zoom:50%;" /></p>
<p>如此一来，两块8259芯片可以向处理器提供15个中断信号。当时，接在8259上的15个设备都是相当重要的，如PS2键盘和鼠标、串行口、并行口、软磁盘驱动器、IDE硬盘等。现在，这些设备很多都已淘汰或者正在淘汰中，根据需要，这些中断引脚可以被其他设备使用。</p>
<p>如图所示，8259的主片引脚 0（IR0）接的是系统定时器/计数器芯片；从片的引脚 0（IR0）接的是实时时钟芯片RTC。在8259芯片内部，有中断屏蔽寄存器（Interrupt Mask Register，IMR），这是个8位寄存器，对应着该芯片的8个中断输入引脚，对应的位是0还是1，决定了从该引脚来的中断信号是否能够通过8259送往处理器（0表示允许，1表示阻断，和一般的逻辑是反过来的）。当外部设备通过某个引脚送来一个中断请求信号时，如果它没有被IMR阻断，那就可以被送往处理器。8259的主片的端口号是0x20和0x21，从片的端口号是0xa0和0xa1，可以通过这些端口访问8259芯片，设置它的工作方式，包括IMR的内容。</p>
<p>中断能否被处理，除了看8259芯片外，还取决于处理器。在处理器内部，标志寄存器有一个标志位IF，这就是中断标志（Interrupt Flag）。当为0时，所有从处理器INTR引脚来的中断信号都被忽略掉；当其为1时，处理器可以接受和响应中断。IF标志位可以通过两条指令 cli / sti 来关闭 / 开启中断。</p>
<h5 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h5><p>中断处理程序本质就是处理器要执行一段与该中断有关的程序。处理器可以识别256个中断，那么理论上就需要256段程序。这些程序的入口点组成一个数组，放在一个指定的位置。这个由入口点组成的数组就叫中断向量表。在实模式下，中断向量表从物理地址0x00000开始，到0x003结束，共IKB的空间。在保护模式下，IDT寄存器保存了中断向量表的起始地址。</p>
<h4 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h4><p>内部中断发生在处理器内部，是由执行的指令引起的。比如，当处理器检测到div或者idiv指令的除数为零时，或者除法的结果溢出时，将产生中断 0（0号中断），这就是除法错中断。</p>
<p>再比如，当处理器遇到非法指令时，将产生中断6。非法指令是指指令的操作码没有定义，或者指令超过了规定的长度。操作码没有定义通常意味着那不是一条指令，而是普通的数。</p>
<p>内部中断不受标志寄存器IF位的影响，也不需要中断识别总线周期，它们的中断类型是固定的，可以立即转入相应的处理过程。</p>
<h4 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h4><p>软中断是由int指令引起的中断处理。这类中断也不需要中断识别总线周期，中断号在指令中给出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int3</span><br><span class="line">int imm8</span><br><span class="line">into</span><br></pre></td></tr></table></figure>
<p><code>int3</code>是断点中断指令，机器指令码为CC。这条指令在调试程序的时候很有用。指令都是连续存放的，所谓的断点，就是某条指令的起始地址。int3是单字节指令，这是有意设计的。当需要设置断点时，可以将断点处那条指令的第1字节改成0xc，原字节予以保存。当处理器执行到int3时，即发生3号中断，转去执行相应的中断处理程序。</p>
<p>注意，<code>int3</code>和<code>int</code> 3不是一回事。前者的机器码为CC，后者则是CD03，这就是通常所说的int n，其操作码为0xCD，第2字节的操作数给出了中断号。</p>
<p>into是溢出中断指令，机器码为0xCE。处理器执行这条指令时，如果标志寄存器OF位是1，将会产生4号中断。反之这条指令什么也不做。</p>
<h5 id="BIOS中断"><a href="#BIOS中断" class="headerlink" title="BIOS中断"></a>BIOS中断</h5><p>调用中断处理程序比较方便，知道中断号以及参数传递规则就行了。事实上操作系统加载完自己之后，以中断处理程序的形式提供了很多基础功能，如硬盘读写功能，并把该例程的地址填写到中断向量表中。这样，无论在什么时候，用户程序需要该功能时，直接发出一个软中断即可。</p>
<p>在以软中断形式提供的功能中，最有名的是BOS中断，之所以称为BOS中断，是因为这些中断功能是在计算机加电之后，BIOS程序执行期间建立起来的。换句话说，这些中断功能在加载和执行主引导扇区之前，就已经可以使用了。</p>
<p>BIOS可能会为一些简单的外围设备提供初始化代码和功能调用代码，并填写中断向量表，但也有一些BIOS中断是由外部设备接口自己建立的。</p>
<p>首先，每个外部设备接口，包括各种板卡，如网卡、显卡、键盘接口电路、硬件控制器等，都有自己的只读存储器（Read Only Memory，ROM），类似于BIOS芯片，这些ROM中提供了它自己的功能调用例程，以及本设备的初始化代码。按照规范，前两个单元的内容是0x55和0xAA，第三个单元是本ROM中以512字节为单位的代码长度；从第四个单元开始，就是实际的ROM代码。</p>
<p>其次，我们知道，从内存物理地址A0000开始，到FFFF结束，有相当一部分空间是留给外围设备的。如果设备存在，那么，它自带的ROM会映射到分配给它的地址范围内。</p>
<p>在计算机启动期间，BIOS程序会以2KB为单位搜索内存地址C0000~E0000之间的区域。当它发现某个区域的头两个字节是0x55和0xAA时，那意味着该区域有ROM代码存在，是有效的。接着，它对该区域做累加和检査，看结果是否和第三个单元相符。如果相符，就从第四个单元进入。这时，处理器执行的是硬件自带的程序指令，这些指令初始化外部设备的相关寄存器和工作状态，最后，填写相关的中断向量表，使它们指向自带的中断处理过程。</p>
<h4 id="保护模式下中断向量的处理"><a href="#保护模式下中断向量的处理" class="headerlink" title="保护模式下中断向量的处理"></a>保护模式下中断向量的处理</h4><p>中断是随机产生的，不可预测。但是它发生时，当前处理器当前总会有个任务在执行。这个任务可能是在内核空间执行也可能在用户空间执行。如果中断处理代码的特权等级比当前任务的级别高，比如中断是ring0级别的，当前任务是ring3，则会切换栈。否则会直接使用当前任务的栈。</p>
<p>中断的处理过程如下：</p>
<ul>
<li>栈切换<ul>
<li>如果中断处理代码的特权等级比当前任务的级别高，则需要从TSS中选择合适的新栈，然后把SS和SP的值压入新栈。如图1.4（b）</li>
<li>如果级别相同，就没有栈的切换，直接使用当前栈。如图1.4（a）所示</li>
</ul>
</li>
<li>处理器把EFLAGS、CS和EIP的当前状态压入新栈</li>
<li>对于有错误代码的异常，处理器还要把错误代码压入新栈，紧挨着EIP之后，</li>
</ul>
<p><img src="/images/进入32位保护模式（四）：中断和进程/32Model_4_3.png" alt="1.4-a" style="zoom:50%;" /></p>
<p><img src="/images/进入32位保护模式（四）：中断和进程/32Model_4_4.png" alt="1.4-b" style="zoom:50%;" /></p>
<p>从中断中返回的过程如下：</p>
<ul>
<li>在执行完中断处理程序以后，如果有错误代码，需要先把错误代码出栈</li>
<li>从栈中依次弹出EIP和CS以及EFLAGS寄存器的值</li>
<li>栈恢复<ul>
<li>判断当前的特权级别和弹出的CS选择子的特权级别，如果不同，说明之前有过栈切换。从栈中再弹出ESP和SS寄存器的值</li>
<li>如果相同，则继续使用当前栈</li>
</ul>
</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h4><p>英特尔提供了保护模式下切换任务的方法，就是任务门。任务门类似于中断，需要先注册再使用。不过英特尔的设计不够灵活，工业界并没有按照英特尔的思路来使用任务门。所以在现代操作系统中已经很少使用任务门来进行进程切换了。</p>
<p>现代的系统普遍采用的是分时多任务处理，普遍都是用定时器中断来进行任务切换。</p>
<h4 id="用中断实现任务切换"><a href="#用中断实现任务切换" class="headerlink" title="用中断实现任务切换"></a>用中断实现任务切换</h4><p>现代的操作系统绝大部分都是使用分时多任务，所以往往使用时钟中断来进行进程调度。时钟中断也是中断的一种，所以上面说的中断的一系列步骤在任务切换时都会发生。不过既然是任务切换，那肯定有现场保存以及恢复现场的逻辑。任务切换就是在中断的基础上增加了现场的保存和恢复。</p>
<h4 id="sysenter和sysexit指令"><a href="#sysenter和sysexit指令" class="headerlink" title="sysenter和sysexit指令"></a>sysenter和sysexit指令</h4><p>使用中断进行任务切换时，会有一系列的特权级别校验、上下文寄存器压栈等操作。本来这个作为普通的中断来说是可以忍受的，因为系统中的外部中断没有那么频繁。但是当中断用来进行内核态和用户态切换，大量使用后，带来的性能问题逐渐明显。</p>
<p>所以英特尔专门设计量<code>sysenter</code>和<code>sysexit</code> 这两个指令来实现内核态和用户态的切换。这两个指令没有中断的校验和压栈动作，性能要好得多。（校验和压栈的操作已经用其他设计来替代了）。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.ibm.com/developerworks/cn/linux/kernel/l-k26ncpu/index.html" target="_blank" rel="noopener">Linux 2.6 对新型 CPU 快速系统调用的支持</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> CS基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[进入32位保护模式（三）：分页式内存管理]]></title>
      <url>http://petpwiuta.github.io/2020/05/09/%25E8%25BF%259B%25E5%2585%25A532%25E4%25BD%258D%25E4%25BF%259D%25E6%258A%25A4%25E6%25A8%25A1%25E5%25BC%258F%25EF%25BC%2588%25E4%25B8%2589%25EF%25BC%2589%25EF%25BC%259A%25E5%2588%2586%25E9%25A1%25B5%25E5%25BC%258F%25E5%2586%2585%25E5%25AD%2598%25E7%25AE%25A1%25E7%2590%2586/</url>
      <content type="html"><![CDATA[<h3 id="分页式内存管理"><a href="#分页式内存管理" class="headerlink" title="分页式内存管理"></a>分页式内存管理</h3><p>以前的段式内存管理在分配内存时，随着系统长时间运行，内存会变得碎片化，空闲的区域可能会小于需要的大小，或者空闲区域又远大于需要的大小。为了解决这个问题，英特尔从80386开始，引入了分页式内存管理。</p>
<p>分页式内存管理的主要思路就是把内存分解成固定大小的页，以前需要多少字节的需求现在转化成请求 “字节数/页面大小(当然，有小数时会向上取整)” 个页面。页面的最小单位是4KB，也就是4096字节，用十六进制表示就是0x1000，因此第1个页面的物理地址是0x00000000，第2个是0x00001000，第3个是0x00002000，以此类推。最终可以把4GB的内存划分成1048576个页，很显然，所有物理页面的地址最低12位始终是0。</p>
<p>在分页模式下，操作系统可以创建一个为所有任务共用的4GB虚拟内存空间，也可以为每一个任务创建独立的4GB虚拟内存空间。当一个程序加载时，操作系统既在要左边的虚拟内存中分配段空间，又要在右边的物理内存中分配相应的页面。因此，第一个步骤是寻找空闲的段空间，该段空间既没有被其他程序使用，也没有被同一程序内的其他段使用。</p>
<p><img src="/images/进入32位保护模式（三）：分页式内存管理/32Model_3_1.png" alt="32Model_3_1" style="zoom:50%;" /></p>
<p>如图所示，假设己经成功找到并分配了一个段空间，基地址为0x00200000，长度为8200字节。 页的最小尺寸是4KB，也就是4096字节。因此，8200字节的段，需要占用3个页面，其中最后一个页面只用了8个字节，其余都浪费着，但这无关紧要，如果允许页共享，多个段或多个程序可以用同一个页来存放各自的数据。 </p>
<p>在分段之后，操作系统的任务是把段拆开，并分别映射到物理页。注意，段必须是连续的，但不要求所分配的页都是连续的。在实际中，内存页会频繁分配和回收，空闲页会零零散散地分布在物理内存中，一般不会是连续的。分配页面时，操作系统会搜索那些空闲的页，并分配给程序使用，所分配页面的总长度要大于等于段长度。 </p>
<p>作为一个具体的例子，操作系统为程序分配了一个段，段是在虚拟内存中分配的，起始地址为0x00200000。该段有8200字节，需要分配3个页面。为此，操作系统在物理内存中搜索可用的空闲页，这二个页面的物理地址分别是0x00002000、0x00004000 和 0x00007000。接下来，要建立线性地址和页之间的对应关系，在图中，0x00200000～0x00200FFF 对应着物理地址为 0x00002000 的页，0x00201000～0x00201FFF 对应着物理地址为 0x00004000 的页， 0x00202000～0x00202007 对应着物理地址为 0x00007000 的页。当然，这里只是示例，线性地址区间和页的对应关系可以随意。 </p>
<p>4GB虚拟内存空间不可能用来保存任何数据，因为它是虚拟的，它只是用来指示内存的使用情况。当操作系统加载一个程序并创建为任务时，操作系统在虚拟内存空间寻找空闲的段，并映射到空闲的页。然后，到真正开始加载程序时，再把原本属于段的数据按页的尺寸拆开，分开写入对应的页中。 从段部件输出的是线性地址，或者叫虚拟地址。为了根据线性地址找到页的物理地址，操作系统必须维护一张表，把线性地址转换成物理地址，这是一个反过程。 如图16-4所示，因为有 1048576 个页，所以转换表也有 1048576 项。这是个一维表格，每个表项占4字节，内容为页的物理地址。这个表格的用法是这样的：因为页的尺寸是4KB，故线性地址的低12位可用于访问页内偏移，高20位可用于指定一个物理页。因此，把线性地址的高 20位当成索引，乘以4，作为表内偏移量，从表中取出一个双字，那就是该线性地址所对应的页的物理地址。</p>
<p> <img src="/images/进入32位保护模式（三）：分页式内存管理/32Model_3_2.png" alt="32Model_3_2" style="zoom:50%;" /></p>
<p>如图所示，如果执行指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx,[0x2002]</span><br></pre></td></tr></table></figure>
<p>那么，段部件用段地址 0x00200000 加上指令中给出的偏移量 0x2002，得到线性地址 0x00202002。线性地址的高20位是表格索引，即0x00202。将索引乘以4，得到0x00808，这就是表内偏移。看图，从该单元可以取出一个双字0x00007000，这就是页物理地址。 </p>
<p>线性地址的低12位是页内偏移量，用页物理地址加上页内偏移量，就是最终的物理内存地址。0x00007000加上0x002，得到0x00007002，这就是实际要访问的物理内存地址。</p>
<p>当程序加载时，操作系统会首先在虚拟内存中分配段。然后，根据段需要分成多少页，来搜索空闲页面。当段较大时，要按页的尺寸分成好几个地址区段，操作系统用每个区段的首地址，取高20位，乘以4，作为偏移量访问表格，并将分配给该区段的页的物理地址写入该表项。最后，把原本需要写入每个区段的程序数据，写到对应的页中。 </p>
<p>在页式内存管理中很重要的一点是，页面的管理和分配是独立的，和分段以及段地址没有关系。操作系统所要做的，就是寻找空闲页面，把它分配给需要的段，并将页的物理地址填写到映射表内。很显然，线性地址，包括线性地址空间，和页面分配机制也没有关系。 </p>
<p>基于以上特点，一般来说，每个任务都可以拥有 4GB的虚拟内存空间；同时，每个任务都有自己的页映射表，如图所示。</p>
<p><img src="/images/进入32位保护模式（三）：分页式内存管理/32Model_3_3.png" alt="32Model_3_3" style="zoom:50%;" /></p>
<p>尽管有很多任务，而且每个任务都有自己的4GB虚拟内存空间，但在整个系统中，物理页面是统一调配的。考虑这样一种情景：任务A有一个段，段基地址为 0x00050000，段长度为3000字节，操作系统为它分配了一个物理地址为0x08001000的页。过了 一会儿，另一个任务B加载了，它也有个段，段基地址也是0x00050000，段长度为4096字节。此时，操作系统则分配另个不同的、物理地址为0x00700000的页。在这种情况下，在任务 A内访问线性地址0x00050006，访问的其实是物理地址0x08001006；在任务B内访问同样的线性 地址时，访问的其实是物理地址0x00700006。</p>
<h3 id="页目录和页表"><a href="#页目录和页表" class="headerlink" title="页目录和页表"></a>页目录和页表</h3><p>为了完成从虚拟地址（线性地址）到物理地址的转换，操作系统应当为每个任务准备一张页映射表。因为任务的虚拟地址空间为4GB，可以分出1048576个页，所以，映射表需 要1048576个表项，用于存放页的物理地址。又因为每个表项占4字节，所以，映射表的总大小为4MB。 不过如果每个任务都要有一个4MB的映射表，那很浪费空间，而且也不是所有的任务都需要访问所有的内存。所以这个设计在实际中有变通，就是层次化的分页结构。 </p>
<p>分页结构层次化的主要手段是不采用单一的映射表，取而代之的是页目录表和页表。如图16-6 所示，首先，因为4GB的虚拟内存空间对应着1048576个4KB的页，可以随机地抽取这些页，将 它们组织在1024个页表内，每个页表可以容纳1024个页。页表内的每个项目叫做页表项，占4字节，存放的是页的物理地址，故每个页表的大小是4KB，正好是一个标准页的长度。 </p>
<p>注意，页在页表内的分布是随机的，哪个页位于哪个页表中，这是没有规律的。在一个真实的系统中，老任务不断被关闭，新任务不断被创建并投入运行，页面的回收和再分配没有什么规律可言。 </p>
<p>由于页表中存放的是页的物理地址，故每个页表项占4字节，这样，每个页表占4096字节， 正好是个物理页的大小，可以很方便地用个物理页来定义每个页表。 </p>
<p>如图所示，在将1048576个页归拢到1024个页表之后，接着，再用一个表来指向1024 个页表，这就是页目录表（Page Directory Table, PDT)，和页表一样，页目录项的长度为4字节，填写的是页表的物理地址，共指向1024个表页，所以页目录表的大小是4KB，正好是一个标准页的长度。 </p>
<p><img src="/images/进入32位保护模式（三）：分页式内存管理/32Model_3_4.png" alt="32Model_3_4" style="zoom:50%;" /></p>
<p>这样的层次化分页结构是每个任务都拥有的，或者说，每个任务都有自己的页目录和页表。 如图16-7所示，在处理器内部，有一个控制寄存器CR3，存放着当前任务页目录的物理地址，故又叫做页目录基址寄存器（Page Directory Base Register, PDBR)。</p>
<p> 每个任务都有自己的任务状态段（TSS)，它是任务的标志性结构，存放了和任务相关的各种数据，其中就包括了CR3寄存器域，存放了任务自己的页目录物理地址。当任务切换时，处理器切换到新任务开始执行，而CR3寄存器的内容也被更新，以指向新任务的页目录位置。相应地， 页目录又指向一个个的页表，这就使得每个任务都只在自己的地址空间内运行。 从图16-7中还可以看出，页目录和页表也是普通的页，混迹于全部的物理页中。它们和普通 页的不同之处仅仅在于功能不一样。当任务撤销之后，它们和任务所占用的普通页一样会被回收，并分配给其他任务。</p>
<h3 id="逻辑地址到物理地址"><a href="#逻辑地址到物理地址" class="headerlink" title="逻辑地址到物理地址"></a>逻辑地址到物理地址</h3><p>对于英特尔处理器来说，有关分页，最简单和最基本的机制就是这些：CR3寄存器给出了页目录的物理基地址；页目录给出了所有页表的物理地址而每个页表给出了它所包含的页的物理地址。那如何用这种层次性的分页结构把线性地址转换成物理地址？  这里举个例子。</p>
<p>假如某个任务加载后，操作系统根据它的实际情况，在其4GB虚拟地址空间里创建了一个 段，段的起始地址为0x00800000，段界限值为0x5000，字节粒度。当该任务执行时，段寄存器 DS指向该段。又假设执行了下面一条指令： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx [0x1050]</span><br></pre></td></tr></table></figure>
<p>此时，段部件会输出线性地址0x00801050。在没有开启分页机制时，这就是要访问的物理内存地址，但现在开启了分页机制，所以，这是一个虚拟地址，要经过页部件的转换，才能得到物理地址。 </p>
<p><img src="/images/进入32位保护模式（三）：分页式内存管理/32Model_3_5.png" alt="32Model_3_5" style="zoom:50%;" /></p>
<p>如图所示，处理器的页部件专门负责线性地址到物理地址的转换工作。它首先将段部件送来的32位线性地址截成3段，分别是高10位、中间的10位和低12位。高10位是页目录的索引，中间10位是页表的索引，低12位则作为页内偏移来用。 </p>
<p>当前任务页目录的物理地址在处理器的CR3寄存器中，假设它的内容为0x00005000。段管理部件输出的线性地址是0x00801050，其二进制的形式为0000 0000 1000 0000 0001 0000 0101 0000。高10位为 0000000010，也就是十六进制的0x002，它是页目录表内的索引，处理器将它乘以4（因为每个目录项为4字节），作为偏移量访问页目录。最终，处理器从物理地址00005008 处取得页表的物理地址 0x08001000。</p>
<p>线性地址的中间10位为二进制的0000000001，即0x001，处理器要用它作为页表内的索引来取得页的物理地址。处理器将该索引值乘以4，作为偏移量访问页表。最终，处理器又从物理地址 08001004处取得页的物理地址，这就是我们一直努力寻找的那个页。 </p>
<p>页的物理地址是0x0000C000，而线性地址的低12位是数据所在的页内偏移量。故处理器将它们相加，得到物理地址0x0000C050，这就是线性地址0x00801050所对应的物理地址，要访问的数据就在这里。 </p>
<p>当任务加载时，操作系统先创建虚拟的段，并根据段地址的高20位决定它要用到哪些页目录项和页表项。然后，寻找空闲的页，将原本应该写入段中的数据写到一个或者多个页中，并将页的物理地址填写到相应的页表项中。只有这样做了，当程序运行的时候，才能以相反的顺序进行地址变换，并找到正确的数据。</p>
]]></content>
      
        <categories>
            
            <category> CS基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[进入32位保护模式（二）：任务和特权级别]]></title>
      <url>http://petpwiuta.github.io/2020/05/09/%25E8%25BF%259B%25E5%2585%25A532%25E4%25BD%258D%25E4%25BF%259D%25E6%258A%25A4%25E6%25A8%25A1%25E5%25BC%258F%25EF%25BC%2588%25E4%25BA%258C%25EF%25BC%2589%25EF%25BC%259A%25E4%25BB%25BB%25E5%258A%25A1%25E5%2592%258C%25E7%2589%25B9%25E6%259D%2583%25E7%25BA%25A7%25E5%2588%25AB/</url>
      <content type="html"><![CDATA[<h3 id="任务以及任务的LDT和TSS"><a href="#任务以及任务的LDT和TSS" class="headerlink" title="任务以及任务的LDT和TSS"></a>任务以及任务的LDT和TSS</h3><p>现代CPU支持多任务执行，这个支持在硬件上也有对应的表现。最重要的就是LDTR和TR这两个寄存器。LDTR和GDTR类似，不过LDTR所指向的是表示的是每个任务自己私有的内存段（Local Descriptor Table）。而TR指向的是保存任务执行状态的内存段（Task State Segment）。</p>
<p>每个任务都会有自己的LDT和TSS来保存任务的内存以及执行状态，当操作系统运行多个任务时，会有多个LDT&amp;TSS对。当要切换到哪个任务时，CPU会把将要切换的任务的LDT和TSS加载到LDTR和TR寄存器，并开始执行。</p>
<p>因为LDT的出现使得任务能访问的内存区域分成了两部分，即全局空间和局部空间。全局空间包含了操作系统的段，以及常用的代码库。而局部空间则包含了程序自己的数据和代码。当任务调用了操作系统提供的服务时，处理器会转入全局空间执行，结束后会回落到任务自己的局部空间。</p>
<p><img src="/images/进入32位保护模式（二）：任务和特权级别/32Model_2_1.png" alt="32Model_2_1" style="zoom:50%;" /></p>
<h3 id="特权级别"><a href="#特权级别" class="headerlink" title="特权级别"></a>特权级别</h3><p>特权级别是在段描述符以及段选择子中的一个数值，用于表示控制访问权限，称之为DPL（Descriptor Privilege Level）。Intel的CPU规定了DPL有4个级别，从大到小分别是0/1/2/3，最高级别是0，最低级别是3。一般给操作系统的代码和数据的级别是0，操作系统提供的服务是1或者2，而应用程序级别一般是最低的3。</p>
<p>在保护模式下所有的内存访问都需要通过GDT来进行，GDT表项中有DPL字段，它规定了每个内存段的特权级别。对于数据段来说，它规定了访问自己所应当具备的最低特权级别，如果一个数据段的DPL是2，那就只有0/1/2这3个级别能访问。</p>
<p>当处理器正在一个代码段中取指令和执行指令时，那个代码段的特权级别就叫CPL（Current Privil Level），正在执行的这个代码段，其选择子位于段寄存器CS中，其最低两位就是当前特权等级的数值。</p>
<h3 id="依从段和调用门"><a href="#依从段和调用门" class="headerlink" title="依从段和调用门"></a>依从段和调用门</h3><p>代码的DPL级别检查很严格，一般来说控制转移只允许发生在两个特权级别相同的代码段之间。如当前特权级别为2，则不允许转移到DPL为0、1、2的代码上执行。不过，为了让特权级别低的程序可以调用高特权级别的操作系统函数，处理器也提供了对应的办法：它们是依从段和调用门。</p>
<p>第一种办法是把一个段定义成可以依从的。就是在GDT中注册内存段时，把TYPE中的C位设置为1，这样的代码段成为依从代码，可以从特权级别比它低的程序调用。反之如果C位是0，则只能被同级别的调用。</p>
<p>调用依从段的代码也有一定条件，就是当前CPL不能高于依从段，即在数值上CPL ⩾ 目标代码的段DPL。如果一个依从段DPL是1，则只能1，2，3级别的程序才能调用，0级别的是不能调用的。这里可能会有点疑问，为什么高级别的代码反而不能调用低级别的代码了？这是因为操作系统等高可靠的代码不允许使用可靠性不如它的代码，所以不允许将控制流程从较高的特权级别转移到较低级别。</p>
<p>而且依从段的代码不是在它的DPL特权级别上运行，而是在发起调用者的特权级别上运行，即当控制流转移到依从段时，CS寄存器的CPL不发生变化，被调用过程的特权等级依从于调用者，这也就是它为什么叫做“依从”段的原因。</p>
<p>第二种办法是使用调用门。调用门是一种描述符，叫做门描述符。和段描述符不同，段描述符用于描述内存段，门描述符则用于描述可执行代码。不过虽然和段描述符类型不同，但它本质上也是描述符，所以它也是要在GDT或者LDT中定义后才能使用。</p>
<p><img src="/images/进入32位保护模式（二）：任务和特权级别/32Model_2_2.png" alt="32Model_2_2" style="zoom:50%;" /></p>
<p>调用门描述符定义了目标代码所在的代码段的选择子，以及段内偏移，上图的TYPE为1100表示调用门。</p>
<p>想要使用调用门，可以用<code>jmp far</code>或者<code>call far</code>指令，并把调用门描述符的选择子作为参数。</p>
<p>使用<code>jmp far</code>指令，CPU会跳转到调用门所定义的代码中执行，但当前特权级别不会改变。但如果是用<code>call far</code>的话，当前特权级别会提升到目标代码段的特权级别。因为call指令用到了栈，栈段的特权级别必须同当前特权级别一致。因此，还要切换栈，即从低特权级的栈切换到高特权级的栈。如一个特权级为3的程序必须使用3级别的栈，而它通过调用门进入0特权级别时，特权级别从3变成0，因此栈也要跟着切换，从3级别的栈切换到0级别的栈。这主要是为了防止栈数据交叉引用以及栈空间不足。</p>
<p>为了切换栈，每个任务除了自己固有的栈外，还需要额外定义几套栈，数量取决于自己的特权级别，如果是0则不需要定义，如果是1则需要定义一套1级别的栈，如果是3则需要定义0、1、2这三套栈。这些额外创建的栈，其描述符位于自己的LDT中，同时还需要在TSS中登记。因为在切换任务时，这些栈会由处理器自动加载。</p>
<p>调用门描述符中的DPL和目标代码段描述符的DPL用于决定哪些特权级别的程序可以调用此门。具体的规则时必须同时符合以下两个条件才行：</p>
<ul>
<li>当前特权级别CPL和请求特权级别RPL高于或等于调用门描述符的DPL。即在数值上<ul>
<li>CPL ⩽ 调用门描述符DPL</li>
<li>RPL ⩽ 调用门描述符DPL</li>
</ul>
</li>
<li>当前特权级别CPL低于或等于目标代码描述符的DPL。即在数值上<ul>
<li>CPL ⩾ 目标代码段描述符DPL</li>
</ul>
</li>
</ul>
<p>综合起来就是一个不等式，即在数值上：调用门描述符的DPL ⩽ 调用者的CPL和RPL ⩽ 目标代码段描述符DPL</p>
<h3 id="TSS段"><a href="#TSS段" class="headerlink" title="TSS段"></a>TSS段</h3><p>TSS段是CPU进行任务切换的具体实体，它和之前讲的普通内存段类似，也是一块内存区域，着块内存区域也需要等级到GDT中，不过它的类型位是二进制的1001，表示它是一个TSS段，当中断或跳转指令遇到TSS段时，就会切换到TSS段所指向的任务。</p>
<p><img src="/images/进入32位保护模式（二）：任务和特权级别/32Model_2_3.png" alt="32Model_2_3" style="zoom:50%;" /></p>
<p>TSS段的结构如图所示：</p>
<p>TSS段的0偏移处是用来跟踪嵌套任务的指针，用来指向上一个任务的地址。</p>
<p>SS0、SS1和SS2分别是0、1、2特权级别的栈段选择子，ESP0、ESP1、ESP2是对应的栈顶指针。</p>
<p>CR3寄存器和分页有关。</p>
<p>剩下的32～92是用来存储CPU寄存器的部分，用来在进行任务切换时保存现场。TSS对应的任务第一次执行时，CPU从这里加载初始化执行环境，并从CS:IP处开始执行任务的第一条指令。此后该区域的内容就由CPU负责更新。</p>
<p>LDT段选择子用来记录任务对应私有内存段。</p>
<p>偏移量100处有个T标志位，在多任务切换时，如果发现TSS的T位是1，会引发一次调试异常中断。</p>
<p>IO映射基地址用来存储一块IO端口权限表的起始地址。有些IO指令（如IN/OUT）由于性能原因需要开放给低权限的程序，但是为了不让低权限的程序不随意读写硬件，在EFLAG寄存器的IOPL位上设置了IO权限级别，当任务的CPL高于或等于IOPL位的权限时（数值上CPL ⩽ IOPL），所有的IO请求都没问题。但如果前面的条件不成立时，并不意味着所有的IO请求都不能通过，事实上处理器的意思时总体上不允许，但是个别端口除外，这个别端口是哪些就需要到IO映射区去查找。</p>
<p>IO端口权限表是一个比特序列，最多有65536位（8KB），从第1比特开始每一个表示一个端口的权限，第1位表示0号端口，第2位表示1号端口，以此类推。当端口位为1时表示禁止访问，0为允许访问。不过实际中基本不会为每个端口都设置权限，也就是说这个比特序列可以小于65536位，对于未指定权限的端口，默认是禁止访问。</p>
<p>IO端口权限表的起始地址是从TSS的起始处算起，因此，如果该地址大于等于TSS的段界限（段界限在TSS描述符中），则表示没有IO权限表，此时计算任务的IO权限就仅仅依据EFLAG寄存器的IOPL位来进行。</p>
<p>IO端口权限表最后还要以固定的一个全部为1的字节结尾。这是因为IO端口被设计成每次操作斤用来读写一个字节的数据，当用字或者双字来访问时，实际上是连续访问2个和4个端口。因此当CPU执行一个字或双字指令时，会检查权限表的2个或4个连续位，而且需要它们都是0。不过这些位可能是跨字节的，有时候刚好检查的位处于最后一个字节里，如果是两个字节的IO操作，就会越界，所以规定权限表最后一定要以一个额外的全是1的字节结尾。</p>
<h3 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h3><ol>
<li><p>中断。中断向量指向的是一个任务门，而导致任务切换，需要用到TSS选择子</p>
</li>
<li><p>call等跳转指令，参数也是TSS段选择子</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> CS基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[进入32位保护模式（一）：加载GDTR]]></title>
      <url>http://petpwiuta.github.io/2020/05/09/%25E8%25BF%259B%25E5%2585%25A532%25E4%25BD%258D%25E4%25BF%259D%25E6%258A%25A4%25E6%25A8%25A1%25E5%25BC%258F%25EF%25BC%2588%25E4%25B8%2580%25EF%25BC%2589%25EF%25BC%259A%25E5%258A%25A0%25E8%25BD%25BDGDTR/</url>
      <content type="html"><![CDATA[<p>实时模式下运行中的程序能访问所有内存，随着计算机上运行的程序越来越多，这个设计的风险也越来越大。保护模式在这个背景下应运而生。保护模式的主要思路就是把内存划分成若干个段，操作系统给这些段表明权限以及相关属性，在访问时就会根据权限和属性给予放行或拦截。</p>
<h3 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h3><p>上面说了保护模式的思路就是把内存分段，这个分段的列表就是GDT（global descriptor table）全局描述符表。这个表中每个表项长度为8个字节，所以，表长度=表项数*8，这个表的起始地址存放在cpu的一个专用寄存器上，称之为GDTR（global descriptor table register）全局描述符表寄存器。</p>
<p>GDTR有48位，其中32位用来存放在内存中的起始地址，16位用来存放表的长度（其实严谨的来说是长度偏移量，因为在数值上总是等于表的大小减一，和c语言中的数组下标类似）。</p>
<p><img src="/images/进入32位保护模式（一）：加载GDTR/32Mode_1_1.png" alt="32Mode_1_1" style="zoom:50%;" /></p>
<p>上面已经提到了，表项的大小是固定的8个字节，所以要想访问任何一项，只需要用GDTR中保存的基地址+表项*8就得到该项的地址，和通过下标对数组进行随机访问一样。</p>
<p>下面就来介绍GDT表项结构。</p>
<p>GDT表项的主要由3部分组成：内存区域的起始地址、内存区域的大小、内存区域的属性。</p>
<p><img src="/images/进入32位保护模式（一）：加载GDTR/32Mode_1_2.png" alt="32Mode_1_2" style="zoom:50%;" /></p>
<p>由图可见GDT表项中的段基地址，段界限，还有属性等位置并不是连续分布的，这主要是考虑和前代CPU兼容性而妥协的设计。下面简单介绍以下各个部分的结构：</p>
<ul>
<li>段基地址：就是该描述符所定义的段的起始地址，总共由32位组成</li>
<li>段长度（界限）：段的长度，数值等于长度的大小减一，总共由20位组成</li>
<li>G（Granularity）：粒度位，用于解释段长度的单位。当为0时，长度单位就是字节，当为1时，长度单位就是4KB，这时，一个段的最大长度能达到4GB</li>
<li>D / B：用来做16位保护模式兼容的位，现在使用的非常少了。如果不做16位兼容，设置成1就行</li>
<li>L：64位代码段标志</li>
<li>AVL（Available）：通常给操作系统使用，处理器很少使用</li>
<li>P（Presence）：用来保存段是否存在于内存中的标志，有时候没有内存时，操作系统会把部分不常用的段换入磁盘中，此位就会置为0。反过来如果从磁盘换入内存，此位就会置为1。</li>
<li>DPL（Descriptor Privilege Level）：用来表示段的特权级别，从大到小分别是，0，1，2，3</li>
<li>S：用来表示段的类型，0为系统段，1为代码/数据段</li>
<li>TYPE：用来表述段的子权限，有点类似于Linux用RWX位来表文件的读写执行权限。对于数据段4位分别是XEWA，表示执行/扩展/写/访问权限，对于代码段4位分别是XCRA，表示执行/特权依从/可读/访问权限</li>
</ul>
<h3 id="GDT的加载"><a href="#GDT的加载" class="headerlink" title="GDT的加载"></a>GDT的加载</h3><p>根据上述的规格设置好GDT的数据后，就需要把GDT表的地址和长度加载到系统的GDTR寄存器中，这个步骤有一个专用的指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt m48  ;该指令的操作数是一个48位的内存区域</span><br></pre></td></tr></table></figure>
<p>指令的参数的48位对应的是GDT表的位置和长度，前（低）16位是长度，后面（高）32位是GDT的地址。</p>
<p>设置好GDT以后，需要进入保护模式才会生效，x86 cpu是通过设置CR0寄存器的PE位为1来进入保护模式。PE（Protection Enable）位在CR0的第1位（位0）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax,cr0   ;读取cr0</span><br><span class="line">or eax,1      ;把第0位置为1</span><br><span class="line">mov cr0,eax   ;设置cr0</span><br><span class="line"></span><br><span class="line">jmp dword 0x0008:flush  ;进入32位模式后，要用jmp指令清空流水线(流水线里残留着16位的指令，会有问题)</span><br></pre></td></tr></table></figure>
<h3 id="保护模式下的段访问"><a href="#保护模式下的段访问" class="headerlink" title="保护模式下的段访问"></a>保护模式下的段访问</h3><h4 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h4><p>保护模式下访问内存地址还是需要通过段寄存器来进行，不过此时段寄存器的内容由以前的段地址变成了段选择子。所谓的段选择子最主要的就是要访问的段在GDT表中的序号。</p>
<p><img src="/images/进入32位保护模式（一）：加载GDTR/32Model_1_3.png" alt="32Model_1_3" style="zoom:50%;" /></p>
<p>段选择子的最主要的信息就是描述符索引，也就是段在段表内的序号。还有就是TI（table indicator）位，用来表示段在哪个表中，TI=0时，表示在GDT表中，TI=1时，表示在LDT（Local Descriptor Table）中。以及RPL（Require Privilege Level）位，请求特权级别，用来表示给出当前选择子的程序的特权级别。</p>
<h4 id="选择子检查"><a href="#选择子检查" class="headerlink" title="选择子检查"></a>选择子检查</h4><p>进入保护模式以后，用段选择子设置段寄存器时，段寄存器会缓存这个选择子，下次再用同样的选择子访问时，就会直接用缓存的数据。而且在访问的过程中也同时对选择子的权限，以及访问范围进行检查，如果权限不够或者超出范围就会产生异常。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="第21条地址线A20"><a href="#第21条地址线A20" class="headerlink" title="第21条地址线A20"></a>第21条地址线A20</h4><p>8086时代都是20条地址线，最大地址为0xFFFFF，再加一就会变成0x100000。但因为只有20位，所以最高位被丢弃，此时又会回到最低位地址0x00000。当年很多特性都依赖于这个特性，后来在80286后地址线扩展到24位，这个特性就不管用了。为了兼容以前的旧代码，IBM在键盘控制器的x60端口放置了一个控制门，后来因为太繁琐在80486以后直接添加了A20M#引脚。</p>
<p>A20m#引脚通过0x92端口控制，它的第7～2位没有使用，第0位是INIT_NOW，它从0变成1时，会重启CPU。而第1位就是用来控制A20的开关，当它为1时会启动第21条地址线。在INIT_NOW被从0设置成1时，会自动把A20位设置成1，所以现在一般不用手动来设置。这个历史遗留问题还是挺有趣的，理解x86的各种历史包袱的过程也不啻于看一部计算机发展史啊。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p><a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table" target="_blank" rel="noopener">GDT wiki</a></p>
</li>
<li><p>《x86汇编语言-从实时模式到保护模式》，page 189</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> CS基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[汇编语言笔记]]></title>
      <url>http://petpwiuta.github.io/2020/05/09/%25E6%25B1%2587%25E7%25BC%2596%25E8%25AF%25AD%25E8%25A8%2580%25E7%25AC%2594%25E8%25AE%25B0/</url>
      <content type="html"><![CDATA[<h4 id="第-1-章-基础知识"><a href="#第-1-章-基础知识" class="headerlink" title="第 1 章 基础知识"></a>第 1 章 基础知识</h4><p>汇编语言发展至今，有3类指令组成：</p>
<ul>
<li>汇编指令：机器码的助记符，有对应的机器码</li>
<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li>
<li>其他符号：如<code>+</code> <code>-</code> <code>*</code> <code>/</code>等，由编译器识别，没有对应的机器码</li>
</ul>
<p>汇编语言的核心是汇编指令，它决定了汇编语言的特性。</p>
<p><strong><span style="color:red">记住！所谓的汇编地址，其实就是相对偏移量，要么是相对段的偏移量，要么是相对程序开始的偏移量。</span></strong>只有程序加载到内存中，段地址确定以后，汇编地址才会随之确定下来，这时候就变成了物理地址。</p>
<h4 id="第-2-章-寄存器"><a href="#第-2-章-寄存器" class="headerlink" title="第 2 章 寄存器"></a>第 2 章 寄存器</h4><h5 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h5><p>通用寄存器 <code>AX</code>, <code>BX</code>, <code>CX</code>, <code>DX</code>。同时为了和上一代保持兼容，这4个寄存器每个又可以分成2个8位寄存器。如<code>AX</code>可以分成<code>AH</code>,<code>AL</code></p>
<h5 id="2-3-几条汇编指令"><a href="#2-3-几条汇编指令" class="headerlink" title="2.3 几条汇编指令"></a>2.3 几条汇编指令</h5><p><code>mov</code> ax,62627</p>
<p><code>add</code> ax, ax</p>
<p><code>sub ax,1</code></p>
<p><code>mul</code></p>
<p><code>div 除数</code>       </p>
<ul>
<li>16位除以8位，被除数放在AX中，除数可以由8位寄存器或者内存单元提供，结果的商放在AL中，余数放在AH中</li>
<li>32位除以16位，被除数的高16位放在DX中，低16位放在AX中，结果的商放在AX中，余数放在DX中</li>
</ul>
<h5 id="2-5-16位结构的CPU"><a href="#2-5-16位结构的CPU" class="headerlink" title="2.5 16位结构的CPU"></a>2.5 16位结构的CPU</h5><p>16、32位或者64位等x位的CPU具有以下几方面特性：</p>
<ul>
<li>运算器一次最多可以处理x位的数据</li>
<li>寄存器的最大宽度位x位</li>
<li>寄存器和运算器之间的数据通路位x位</li>
</ul>
<h5 id="2-6-8086CPU-给出物理地址的方法"><a href="#2-6-8086CPU-给出物理地址的方法" class="headerlink" title="2.6 8086CPU 给出物理地址的方法"></a>2.6 8086CPU 给出物理地址的方法</h5><p>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理，传输，暂存的地址位16位。如果将地址从内部简单地发出，那么它只能送出16位地址，表现出寻址能力只有64KB。8086CPU采取在内部用两个16位地址合成的方法来形成一个20位的物理地址。</p>
<h5 id="2-7-“段地址x16-偏移地址-物理地址”的本质含义"><a href="#2-7-“段地址x16-偏移地址-物理地址”的本质含义" class="headerlink" title="2.7 “段地址x16+偏移地址=物理地址”的本质含义"></a>2.7 “段地址x16+偏移地址=物理地址”的本质含义</h5><p>CPU访问内存时，用一个基础地址（段地址x16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</p>
<h5 id="2-9-段寄存器"><a href="#2-9-段寄存器" class="headerlink" title="2.9 段寄存器"></a>2.9 段寄存器</h5><p>8086CPU有4个段寄存器：</p>
<p><code>CS</code>  Code Segment，用来和IP配合，实现执行流跳转</p>
<p><code>DS</code> Data Segment，用来进行数据操作</p>
<p><code>SS</code> Stack Segment，用来进行栈操作</p>
<p><code>ES</code></p>
<p>段寄存器不支持直接赋值（硬件电路设计如此），如<code>mov CS,100h</code>之类的指令是不行的，只能从其他寄存器赋值过来，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,100h</span><br><span class="line">mov cs,ax</span><br></pre></td></tr></table></figure>
<h5 id="2-10-CS-和-IP"><a href="#2-10-CS-和-IP" class="headerlink" title="2.10 CS 和 IP"></a>2.10 CS 和 IP</h5><p>CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器，从名称上我们可以看出它们和指令的关系。在8086PC机中，任意时刻，设CS中的内容为M，IP中的内容为N，8086CPU将从内存的Mx16+N单元开始，读取一条指令并执行。</p>
<p>在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置成CS=FFFF，IP=0000，即在8086PC机刚启动时，CPU从内存FFFF0单元中读取指令执行，FFFF0单元中的指令时8086PC机开机后执行的第一条指令。</p>
<h5 id="2-11-修改CS-和-IP-的指令"><a href="#2-11-修改CS-和-IP-的指令" class="headerlink" title="2.11 修改CS 和 IP 的指令"></a>2.11 修改CS 和 IP 的指令</h5><p>要修改寄存器的内容，可以用mov指令，但是CS/IP的值不能用mov直接设置。8086CPU为CS/IP提供了另外的指令来改变它们的值。能够改变CS/IP的内容的指令被统称为转移指令。</p>
<p><code>JMP 段地址:偏移地址</code>指令可以用来修改CS/IP。如<code>jmp 2AE3:3</code>执行后，CS=2AE3，IP=0003，CPU将从2AE33处读取指令</p>
<p><code>JMP 合法寄存器</code> 指令可以用来单独IP的内容。如<code>jmp AX</code> 执行前AX=1000，CS=2000，IP=003。执行后AX=1000，CS=2000，IP=1000</p>
<h4 id="第-3-章-寄存器内存访问"><a href="#第-3-章-寄存器内存访问" class="headerlink" title="第 3 章 寄存器内存访问"></a>第 3 章 寄存器内存访问</h4><h5 id="3-2-DS-和-address"><a href="#3-2-DS-和-address" class="headerlink" title="3.2 DS 和 [address]"></a>3.2 DS 和 [address]</h5><p>8086CPU中，内存地址由段地址和偏移地址组成。段地址通常用DS寄存器保存，比如要读取10000单元的内容，可以用如下程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000h</span><br><span class="line">mov ds,bx</span><br><span class="line">mov al,[0]   ;把10000(1000:0)中的数据读到al中，对于内存寻址的语法是用&#96;[...]&#96;表示</span><br></pre></td></tr></table></figure>
<h5 id="3-7-CPU的栈机制"><a href="#3-7-CPU的栈机制" class="headerlink" title="3.7 CPU的栈机制"></a>3.7 CPU的栈机制</h5><p>现在的CPU都有栈机制，8086也不例外。</p>
<p><code>PUSH</code> ax 表示把ax的内容放到栈中</p>
<p><code>POP</code> ax 表示把栈顶元素放到ax中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push ax的执行，由以下两步完成：</span><br><span class="line">1 sp &#x3D; sp - 2，ss:sp指向当前栈前面的单元，以当前栈顶前面的单元为新的栈顶</span><br><span class="line">2 将ax中的内容送入ss:sp指向的内存单元处，ss:sp此时指向新栈顶</span><br><span class="line"></span><br><span class="line">pop ax的执行和上面的相反：</span><br><span class="line">1 将ss:sp指向的内存单元处的数据送入ax</span><br><span class="line">2 sp &#x3D; sp + 2，ss:sp指向当前栈顶下面的单元，以当前栈顶下面的单元为心的栈顶</span><br></pre></td></tr></table></figure>
<p>CPU的<code>SS</code>寄存器保存着栈顶地址，<code>SP</code>保存着偏移地址。入栈时，栈顶从高地址向低地址方向增长。</p>
<p>8086CPU并不会保证栈越界，这个需要编译器或者业务逻辑来实现。</p>
<h4 id="第-4-章-第一个程序"><a href="#第-4-章-第一个程序" class="headerlink" title="第 4 章 第一个程序"></a>第 4 章 第一个程序</h4><h5 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">	</span><br><span class="line">st:	mov ax,0123h</span><br><span class="line">	mov bx,0456h</span><br><span class="line">	add ax,bx</span><br><span class="line">	add ax,ax</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end st</span><br><span class="line"></span><br><span class="line">;   end命令除了通知编译器程序结束外，还可以通知编译器程序入口在什么地方。</span><br><span class="line">;   如上述的 end st，st就是一个入口说明符</span><br></pre></td></tr></table></figure>
<ol>
<li><p>伪指令</p>
<ul>
<li><code>segment</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx segment</span><br><span class="line">	;code ...</span><br><span class="line">xxx ends</span><br></pre></td></tr></table></figure>
<p><code>segment</code>和<code>ends</code>是一对伪指令关键字，用来定义一个段。</p>
<p>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据、或者当作栈空间来使用。一个有意义的汇编程序至少要有一个段，用来存放代码。</p>
<ul>
<li><p><code>end</code> 汇编语言的结束标记。在编译过程中，如果遇到end指令，就结束编译</p>
</li>
<li><p><code>assume</code> 用来将特定用途的段和相关寄存器关联起来</p>
</li>
</ul>
</li>
<li><p>程序结构</p>
<p>汇编程序的几个基本要素和简单框架如下：</p>
<ol>
<li><p>首先是要定义一个段，如abc。并在段中写入指令和数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">	; code ...</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure>
</li>
<li><p>用end关键词来指定结束位置</p>
</li>
<li><p>将段和指定的段寄存器绑定起来</p>
</li>
</ol>
</li>
</ol>
<h4 id="第-5-章-BX-和loop指令"><a href="#第-5-章-BX-和loop指令" class="headerlink" title="第 5 章 [BX]和loop指令"></a>第 5 章 [BX]和loop指令</h4><h5 id="5-2-loop指令"><a href="#5-2-loop指令" class="headerlink" title="5.2 loop指令"></a>5.2 loop指令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">		mov cx, loop_count</span><br><span class="line">tag_name: </span><br><span class="line">		; code ...</span><br><span class="line">		loop tag_name</span><br></pre></td></tr></table></figure>
<p>loop指令的格式是：loop 标号，CPU执行loop指令的时候，要进行两部操作：1. cx = cx - 1 ; 2. 判断cx中的值，不为0则转至标号处执行程序，如果为0则向下执行。</p>
<p>cx的值影响loop指令的执行状态，通常（一般是这样，也有例外）我们用loop实现循环时，cx就是用来存放循环次数的地方。</p>
<h5 id="5-6-段前缀"><a href="#5-6-段前缀" class="headerlink" title="5.6 段前缀"></a>5.6 段前缀</h5><p>在进行内存访问时，如指令<code>mov ax,[bx]</code>内存单元的偏移地址由bx给出，而段地址默认在ds中。我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。如：<code>mov ax,ds:[bx]</code> 。这样显式地指明内存单元段地址的叫做段前缀。</p>
<h4 id="第-6-章-包含多个段的程序"><a href="#第-6-章-包含多个段的程序" class="headerlink" title="第 6 章 包含多个段的程序"></a>第 6 章 包含多个段的程序</h4><h5 id="6-3-将数据、代码、栈放入不同的段"><a href="#6-3-将数据、代码、栈放入不同的段" class="headerlink" title="6.3 将数据、代码、栈放入不同的段"></a>6.3 将数据、代码、栈放入不同的段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line"></span><br><span class="line">data segment vstart &#x3D; 0</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,20h   ;设置栈顶ss:sp指向stack:20</span><br><span class="line">		</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax    ;ds指向data段</span><br><span class="line">		</span><br><span class="line">		mov bx,0     ;ds:bx 指向data段中地第一个单元</span><br><span class="line">		</span><br><span class="line">		mov cx,8</span><br><span class="line"></span><br><span class="line">s:		push [bx]</span><br><span class="line">		add bx,2</span><br><span class="line">		loop s       ;以上将data段中的0～15单元中的8个字型数据依次入栈</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		</span><br><span class="line">		mov cx,8</span><br><span class="line">s0:		pop [bx]</span><br><span class="line">		add bx,2</span><br><span class="line">		loop s0       ;以上依次出栈8个字型数据到data段地0～15单元中</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>所有的segment的地址都是从程序开始（也就是从0开始）处计算的，在nasm编译器里面可以用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">section.段名称.start  ;来表示段的地址</span><br></pre></td></tr></table></figure>
<p>不过segment内的地址会有点不一样。如果segment声明处有vstart=xx，则段内地址是从xx开始计算，如vstart=0x7c00，则第一条指令地址就是0x7c00，如果vstart=0，则第一条指令地址就是0。如果没有则是从整个程序头部开始计算。</p>
<h4 id="第-7-章-更灵活的定位内存地址的方法"><a href="#第-7-章-更灵活的定位内存地址的方法" class="headerlink" title="第 7 章 更灵活的定位内存地址的方法"></a>第 7 章 更灵活的定位内存地址的方法</h4><p>常用的寄存器除了前面提到的以外，还有<code>si</code>和<code>di</code>，这两个寄存器不能被分成两个独立8位寄存器的。从名字上来看应该是source index和destination index，主要用来做数据转移时记录index偏移</p>
<h5 id="7-10-不同的寻址方式的灵活应用"><a href="#7-10-不同的寻址方式的灵活应用" class="headerlink" title="7.10 不同的寻址方式的灵活应用"></a>7.10 不同的寻址方式的灵活应用</h5><ul>
<li>[常量] 用一个常量来表示地址，可用于直接定位一个内存单元</li>
<li>[bx] 用一个变量表示内存地址，可用于间接定位一个内存单元</li>
<li>[bx+常量] 用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元</li>
<li>[bx+si] 用两个变量表示地址</li>
<li>[bx+si+常量] 用两个变量和一个常量表示地址</li>
</ul>
<h4 id="第-8-章-数据处理的两个基本问题"><a href="#第-8-章-数据处理的两个基本问题" class="headerlink" title="第 8 章 数据处理的两个基本问题"></a>第 8 章 数据处理的两个基本问题</h4><h5 id="8-5-指令要处理的数据有多长"><a href="#8-5-指令要处理的数据有多长" class="headerlink" title="8.5 指令要处理的数据有多长"></a>8.5 指令要处理的数据有多长</h5><p>8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明时子操作还是字节操作。</p>
<ol>
<li><p>通过寄存器名字指明要处理的数据尺寸。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;下面的指令中，寄存器指明了指令进行的是字操作</span><br><span class="line">mov ax,1</span><br><span class="line">mov bx,ds:[0]</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">inc ax</span><br><span class="line">add ax,1000</span><br><span class="line">;下面的指令中，寄存器指明了指令进行的是字节操作</span><br><span class="line">mov al,1</span><br><span class="line">mov al,bl</span><br><span class="line">mov al,ds:[0]</span><br><span class="line">mov ds:[0],al</span><br><span class="line">inc al</span><br><span class="line">add dl,100</span><br></pre></td></tr></table></figure>
<p>来源和目的地的寄存器长度需要一样，不然会报错。如果有数据源是内存地址或者常量，会根据寄存器的宽度来扩展。如果常量的长度超过寄存器宽度，也会报错。</p>
</li>
<li><p>在没有寄存器名字的情况下，可以用操作符x ptr指明内存单元的长度，x可以是word或byte。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1  ;字操作</span><br><span class="line">mov byte ptr ds:[0],1  ;字节操作</span><br></pre></td></tr></table></figure>
</li>
<li><p>如push/pop等操作默认就是按字来进行的。</p>
</li>
</ol>
<h4 id="第-9-章-转移指令的原理"><a href="#第-9-章-转移指令的原理" class="headerlink" title="第 9 章 转移指令的原理"></a>第 9 章 转移指令的原理</h4><p>可以修改IP，或者同时修改CS和IP的指令统称为转移指令。换句话说转移指令就是可以控制CPU执行内存某处代码的指令。</p>
<h5 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h5><p>offset操作符在汇编语言中时由编译器处理的符号，它的功能是取得标号地偏移地址。如下面的程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">	start:	mov ax,offset start      ;想当于mov ax,0</span><br><span class="line">	s:		mov ax,offset s          ;相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h5 id="9-2-依据位移进行转移的jmp指令"><a href="#9-2-依据位移进行转移的jmp指令" class="headerlink" title="9.2 依据位移进行转移的jmp指令"></a>9.2 依据位移进行转移的jmp指令</h5><p><code>jmp short 标号</code> 转移到标号处执行指令。这种格式的jmp是段内短转移。j不会带上目的地址，仅仅指示记录了相对于当前IP的偏移量。</p>
<p><code>jmp far ptr 标号</code> 实现的是段间转移，又称为远转移。会带上CS:IP的地址</p>
<h5 id="9-7-jcxz指令"><a href="#9-7-jcxz指令" class="headerlink" title="9.7 jcxz指令"></a>9.7 jcxz指令</h5><p><code>jcxz 标号(如果cx寄存器的值位0，就转移到标号所在处执行)</code> 指令是有条件转移指令，所有的有条件转移指令都是短转移，机器码中包含的是ip的位移而不是目的地址。</p>
<h4 id="第-10-章-CALL-和-RET-指令"><a href="#第-10-章-CALL-和-RET-指令" class="headerlink" title="第 10 章 CALL 和 RET 指令"></a>第 10 章 CALL 和 RET 指令</h4><p>call 和 ret指令都是转移指令，它们都修改IP或者同时修改CS和IP。它们经常被一起用来实现子程序的设计。</p>
<h5 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h5><p>ret指令执行时，cpu进行2步操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. ip &#x3D; ss * 16 + sp</span><br><span class="line">2. sp &#x3D; sp + 2</span><br></pre></td></tr></table></figure>
<p>retf指令执行时，cpu进行4步操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. ip &#x3D; ss * 16 + sp</span><br><span class="line">2. sp &#x3D; sp + 2</span><br><span class="line">3. cs &#x3D; ss * 16 + sp</span><br><span class="line">4. sp &#x3D; sp + 2</span><br></pre></td></tr></table></figure>
<p>可以看出，ret相当于汇编指令的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br></pre></td></tr></table></figure>
<p>retf相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br></pre></td></tr></table></figure>
<h5 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h5><p><code>call 标号</code> 进行两部操作：</p>
<ol>
<li>将当前IP或CS和IP压入栈中</li>
<li>转移</li>
</ol>
<p>call指令不能实现短转移，除此之外，call和jmp基本上差不多。</p>
<h5 id="10-4-转移地目的地地址在指令中的call指令"><a href="#10-4-转移地目的地地址在指令中的call指令" class="headerlink" title="10.4 转移地目的地地址在指令中的call指令"></a>10.4 转移地目的地地址在指令中的call指令</h5><p><code>call far ptr 标号</code> 实现段间转移</p>
<h4 id="第-11-章-标志寄存器"><a href="#第-11-章-标志寄存器" class="headerlink" title="第 11 章 标志寄存器"></a>第 11 章 标志寄存器</h4><p>8086CUP中的flag寄存器用来当作标志寄存器，大部分算数或者逻辑运算指令(<code>add</code>/<code>sub</code>/<code>mul</code>/<code>div</code>/<code>inc</code>/<code>dec</code>/<code>or</code>/<code>and</code>)会对标志寄存器有影响。而<code>push</code>/<code>pop</code>等传送指令则没有影响。而且有些指令的执行会影响多个标志位，比如指令<code>sub al,al</code>执行后，ZF、PF、SF等都会受影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00</span><br><span class="line">                OF  DF  IF  TF  SF  ZF      AF      PF      CF</span><br></pre></td></tr></table></figure>
<h5 id="11-1-ZF位"><a href="#11-1-ZF位" class="headerlink" title="11.1 ZF位"></a>11.1 ZF位</h5><p>flag的第6位是ZF(Zero Flag)零标志位，记录相关指令执行以后，其结果是否位0，如果是0则位1</p>
<h5 id="11-2-PF位"><a href="#11-2-PF位" class="headerlink" title="11.2 PF位"></a>11.2 PF位</h5><p>flag的第2位是PF(Parity Flag)奇偶标志位，记录相关指令执行以后，其结果的所有bit中1的个数是否位偶数个。如果是偶数就是1，否则就是0</p>
<h5 id="11-3-SF位"><a href="#11-3-SF位" class="headerlink" title="11.3 SF位"></a>11.3 SF位</h5><p>flag的第7位是SF(Symbol Flag)符号标志位，记录相关指令执行以后，其结果是否位负。如果是负则为1，否则就是0</p>
<p>计算机中，有有符号数和无符号数，不过计算机都是统一用补码处理。所以同一个数据可以有两种解释，这里SF位就是表示如果数据按照有符号数运算时，结果是否位负数。</p>
<h5 id="11-4-CF位"><a href="#11-4-CF位" class="headerlink" title="11.4 CF位"></a>11.4 CF位</h5><p>flag的第0位是CF(Carry Flag)进位标志位。一般情况下，无符号数运算时，它记录了运算结果的最高有效位向更高位的进位值，或从更高的借位值。</p>
<h5 id="11-5-OF位"><a href="#11-5-OF位" class="headerlink" title="11.5 OF位"></a>11.5 OF位</h5><p>flag的第11位是OF(Over Flag)溢出标志位。有符号数运算时，它记录了运算结果是否有溢出。</p>
<h5 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a>11.6 adc指令</h5><p>adc是带进位加法的指令，它利用了CF位上记录的进位值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc obj1,obj2   ;obj1 &#x3D; obj1+obj2+CF</span><br></pre></td></tr></table></figure>
<p>主要用于对大于当前CPU字长的数据进行分步求和</p>
<h5 id="11-7-sbb指令"><a href="#11-7-sbb指令" class="headerlink" title="11.7 sbb指令"></a>11.7 sbb指令</h5><p>和adc类似，在计算时会减去CF位上的值</p>
<h5 id="11-8-cmp指令"><a href="#11-8-cmp指令" class="headerlink" title="11.8 cmp指令"></a>11.8 cmp指令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp obj1,obj2   ; 实际上是执行的 obj1-obj2，结果放在ZF里</span><br></pre></td></tr></table></figure>
<p>cmp指令相当于减法指令，只不过没有保存结果。如果两个数一样，则ZF为1，否则为0。如果obj1&lt;obj2则在计算过程中会产生借位，此时CF=1，否则CF=0。cmp指令的结果可能会影响多个标志位</p>
<h5 id="11-9-检测比较结果的条件转移指令"><a href="#11-9-检测比较结果的条件转移指令" class="headerlink" title="11.9 检测比较结果的条件转移指令"></a>11.9 检测比较结果的条件转移指令</h5><p>和高级语言的条件判断类似，这类指令会根据特定条件来执行跳转，执行不同的代码。如之前用过的jcxz，就是jump cx zero的缩写，如果cx是0的话就执行跳转。</p>
<p>除了jcxz外，还有很多常用的跳转指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">je     ;jump equal， zf&#x3D;1</span><br><span class="line">jne    ;jump not equal, zf&#x3D;0</span><br><span class="line">jb     ;jump below, cf&#x3D;1</span><br><span class="line">jnb    ;jump not below, cf&#x3D;0</span><br><span class="line">ja     ;jump above, cf&#x3D;0 且 zf&#x3D;0</span><br><span class="line">jna    ;jump not above, cf&#x3D;1 或 zf&#x3D;1</span><br></pre></td></tr></table></figure>
<h5 id="11-10-DF标志和串传送指令"><a href="#11-10-DF标志和串传送指令" class="headerlink" title="11.10 DF标志和串传送指令"></a>11.10 DF标志和串传送指令</h5><p>flag的第10位是DF(Direction Flag)方向标志位。控制si/di的增加或者减小。DF=0，si/di递增，DF=1，si/di递减。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movsb  ;相当于mov es:[di], byte ptr ds:[si]</span><br><span class="line">movsw  ;相当于mov es:[di], word ptr ds:[si]</span><br></pre></td></tr></table></figure>
<p>这两个命令常用来进行数据拷贝，通常搭配rep命令一起使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx, 3</span><br><span class="line">cld         ;表示clear director，用于把DF变成0</span><br><span class="line">            ;对应的有std(set director)，用于把DF变成1  </span><br><span class="line">rep movsb   ;rep 命令表示重复movsb，重复的次数放在cx寄存器中</span><br></pre></td></tr></table></figure>
<h5 id="11-11-pushf和popf"><a href="#11-11-pushf和popf" class="headerlink" title="11.11 pushf和popf"></a>11.11 pushf和popf</h5><p><code>pushf</code>把标志寄存器压栈，<code>popf</code>是把寄存器弹出</p>
<h4 id="常用指令列表"><a href="#常用指令列表" class="headerlink" title="常用指令列表"></a>常用指令列表</h4><ul>
<li>shr 右移</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shr al,1</span><br></pre></td></tr></table></figure>
<p>将一个寄存器或内存单元中的数据向右移位。将最右侧移出的一位写入CF中。最左侧用0补充。如果移动位数大于1，需要把移动位数放入cl中。这个指令不会进行符号位扩展，具有符号位扩展的指令是sar</p>
<ul>
<li>shl 左移</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shl al,1</span><br></pre></td></tr></table></figure>
<p>将一个寄存器或内存单元中的数据向左移位。将最左移出的一位写入CF中。最右侧用0补充。如果移动位数大于1，需要把移动位数放入cl中。</p>
<ul>
<li>repe movsw 表示在CX不为0时，且ZF＝1重复执行后面的串处理指令。</li>
<li>MOVSW 移动一个字，如果DF=0，所以每次搬运完 SI、DI 会增加 2，而 CX 减少一</li>
<li>add / adc   add是加法，adc是带进位加法，会将CF位的值一起加到目标操作数中</li>
<li>pusha / pushad 把所有通用寄存器压栈，d表示double word</li>
<li>bswap 表示byte swap，专用于大小尾变换的指令。如eax=00112233h，则变换后eax=33221100h</li>
<li>MOVZX 指令（进行全零扩展并传送）将源操作数复制到目的操作数，并把目的操作数 0 扩展到 16 位或 32 位。这条指令只用于无符号整数</li>
<li><p>MOVSX 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，并把目的操作数符号扩展到 16 位或 32 位。这条指令只用于有符号整数</p>
</li>
<li><p>跳转相关</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">JB   ;无符号小于则跳转</span><br><span class="line">JNB  ;无符号不小于则跳转</span><br><span class="line">JBE  ;无符号小于等于则跳转		同JNA</span><br><span class="line">JNBE ;无符号不小于等于则跳转	同JA</span><br><span class="line"></span><br><span class="line">JG   ;有符号大于则跳转</span><br><span class="line">JNG  ;有符号不大于则跳转</span><br><span class="line">JGE  ;有符号大于等于则跳转		同JNL</span><br><span class="line">JNGE ;有符号不大于等于则跳转	同JL</span><br><span class="line"></span><br><span class="line">JL   ;有符号小于则跳转</span><br><span class="line">JNL  ;有符号不小于则跳转</span><br><span class="line">JLE  ;有符号小于等于则跳转		同JNG</span><br><span class="line">JNLE ;有符号不小于等于则跳转	同JG</span><br><span class="line"></span><br><span class="line">JZ   ;为零则跳转</span><br><span class="line">JNZ  ;不为零则跳转</span><br><span class="line"></span><br><span class="line">JS   ;为负则跳转</span><br><span class="line">JNS  ;不为负则跳转</span><br><span class="line"></span><br><span class="line">JC   ;进位则跳转</span><br><span class="line">JNC  ;不进位则跳转</span><br><span class="line"></span><br><span class="line">JO   ;溢出则跳转</span><br><span class="line">JNO  ;不溢出则跳转</span><br><span class="line"></span><br><span class="line">JP;为偶则跳转</span><br><span class="line">JNP  ;不为偶则跳转</span><br><span class="line"></span><br><span class="line">JPE  ;奇偶位置位则跳转		同JP</span><br><span class="line">JPO  ;奇偶位复位则跳转		同JNP</span><br><span class="line"></span><br><span class="line">;https:&#x2F;&#x2F;blog.csdn.net&#x2F;zmmycsdn&#x2F;article&#x2F;details&#x2F;78511948</span><br></pre></td></tr></table></figure>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul>
<li><a href="https://www.cnblogs.com/ToBeExpert/p/9768546.html" target="_blank" rel="noopener">Intel的CPU通用寄存器</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> CS基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[程序员的自我修养：库与运行库]]></title>
      <url>http://petpwiuta.github.io/2020/05/09/%25E7%25A8%258B%25E5%25BA%258F%25E5%2591%2598%25E7%259A%2584%25E8%2587%25AA%25E6%2588%2591%25E4%25BF%25AE%25E5%2585%25BB%25EF%25BC%259A%25E5%25BA%2593%25E4%25B8%258E%25E8%25BF%2590%25E8%25A1%258C%25E5%25BA%2593/</url>
      <content type="html"><![CDATA[<h2 id="10-内存"><a href="#10-内存" class="headerlink" title="10 内存"></a>10 内存</h2><h3 id="10-1-程序和内存空间"><a href="#10-1-程序和内存空间" class="headerlink" title="10.1 程序和内存空间"></a>10.1 程序和内存空间</h3><p>现代的程序都使用的是虚拟内存空间，它的大小仅仅和CPU地址线宽度相关。虚拟内存空间和物理内存通过页目录和页表来实现映射。</p>
<p>在虚拟空间中内存并不是所有的地方都可以随意使用，它被划分为了内核空间和用户空间。内核空间仅供操作系统使用，用户空间才是用户程序所使用的内存区域。在用户空间中，内存被分为了几个默认的区域：</p>
<ul>
<li>栈：用户维护函数调用时上下文参数，如参数和返回地址</li>
<li>堆：用来提供给程序进行动态内存分配，像malloc函数分配的内存空间就在堆上</li>
<li>可执行文件镜像：存储编译出来的可执行文件</li>
<li>保留区：一部分不能被访问的空间区域的总称</li>
<li>动态链接映射：如果程序是动态链接的，所需要的动态链接库会被映射到虚拟内存空间中</li>
</ul>
<p><img src="/images/程序员的自我修养：库与运行库/10.1-1.png" alt="10.1-1" style="zoom:50%;" /></p>
<h3 id="10-2-栈和调用惯例"><a href="#10-2-栈和调用惯例" class="headerlink" title="10.2 栈和调用惯例"></a>10.2 栈和调用惯例</h3><h4 id="10-2-1-栈的结构"><a href="#10-2-1-栈的结构" class="headerlink" title="10.2.1 栈的结构"></a>10.2.1 栈的结构</h4><p>栈是一种后进先出的数据结构，它在编程语言中重要的作用之一就是跟踪函数的调用状态。函数可以层层嵌套调用，然后再一一返回，中间不会回到其他函数，也不会跳过中间的部分直接回到顶部函数，这都依赖于栈的存在。</p>
<p>函数栈中保存了函数调用和返回所需要的信息，主要有以下几个部分：</p>
<ul>
<li>函数的返回地址和参数</li>
<li>函数中声明的临时变量</li>
<li>保存的上下文环境</li>
</ul>
<p>在i386处理器中，使用ebp和esp这两个寄存器来跟踪一个函数调用，esp始终指向栈顶部，也就是说同时指向了当前调用的函数的最顶部，ebp始终指向当前调用的函数的最底部。</p>
<p><img src="/images/程序员的自我修养：库与运行库/10.2-1.png" alt="10.2-1" style="zoom:50%;" /></p>
<p>函数调用后会在函数栈中建立起对应的栈帧，一个完整的函数调用帧是由调用者和被调用者双方建立起来的，具体步骤如下：</p>
<ol>
<li><p>调用者把所有或者部分参数压入栈中，如果有其他参数没有入栈，就用特定的寄存器传递参数</p>
</li>
<li><p>把当前指令的下一条指令压入栈中，作为返回地址</p>
</li>
<li><p>跳转到被调用的函数体执行具体逻辑 （2 和 3 这两个步骤是由汇编指令<code>call</code>来完成的，是一个原子操作）</p>
<hr>
</li>
<li><p>被调用函数执行 <code>push ebp</code>把ebp压入栈中</p>
</li>
<li><p>被调用函数再执行<code>mov ebp,esp</code>把esp保存到ebp中</p>
</li>
</ol>
<p>翻译成对应的汇编代码应该类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int func(int arg) &#123;</span><br><span class="line">    push   ebp            ;这两行代码是每个函数体中都有的标准代码</span><br><span class="line">    mov    ebp,esp        ;用来维护栈帧结构，所有的函数默认应该都有前面着两行代码</span><br><span class="line"></span><br><span class="line">    sub    esp,局部变量所占空间  ;可选，用来保存函数的局部变量</span><br><span class="line">    push   xxx                ;可选，保存指定的寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">               ;调用其他函数的一般方法             ;;</span><br><span class="line">                                               ;;</span><br><span class="line">    ;如果函数中要调用其他函数，一般是                ;;</span><br><span class="line">    mov 寄存器,参数  ;如果是用寄存器传递参数         ;;</span><br><span class="line">    push           ;如果参数较多就用栈传递参数      ;;</span><br><span class="line">    call 函数名     ;call指令会保存下一条指令再跳转  ;;</span><br><span class="line">    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">    mov eax,0   ;通过寄存器返回函数结果 即 return 0;   </span><br><span class="line">                ;太大的对象需要通过更复杂的方式来返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-2-2-调用惯例"><a href="#10-2-2-调用惯例" class="headerlink" title="10.2.2 调用惯例"></a>10.2.2 调用惯例</h4><p>一个完整的栈帧需要调用者和被调用者共同构建，所以两者之间的协议就很重要了。调用者和被调用者之间的协议叫调用惯例，一般会规定下面几个方面的内容：</p>
<ul>
<li><p>函数参数的传递顺序和方式</p>
<p>参数较少时可以通过寄存器来传递（寄存器速度快，效率也更高）; 但是参数较多时就要用栈，用栈传递时就要约定好参数时从左到右还是从右到左入栈，然后另一方再从栈中获取参数</p>
</li>
<li><p>栈的维护方式</p>
<p>参数入栈以后，调用函数，函数完成以后参数已经不再需要，此时需要把参数从栈中弹出释放空间，这个步骤调用者或者被调用者都可以做，所以也需要约定好</p>
</li>
<li><p>名字修饰的算法</p>
<p>从函数名到对应的符号名，这个算法由很多固定的约定，比如c语言的cdecl，就规定了把函数名前面添加一个下划线作为符号名。如foo函数，对应的符号名就是_foo</p>
</li>
</ul>
<p>下面是几个典型的调用惯例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">调用惯例</th>
<th style="text-align:center">参数出栈方</th>
<th style="text-align:center">参数传递</th>
<th style="text-align:center">名字修饰</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cdecl</td>
<td style="text-align:center">函数调用方</td>
<td style="text-align:center">从右到左压栈</td>
<td style="text-align:center">下划线+函数名</td>
</tr>
<tr>
<td style="text-align:left">stdcall</td>
<td style="text-align:center">函数本身</td>
<td style="text-align:center">从右到左压栈</td>
<td style="text-align:center">下划线+函数名+@+参数字节数</td>
</tr>
<tr>
<td style="text-align:left">fastcall</td>
<td style="text-align:center">函数本身</td>
<td style="text-align:center">头两个dword(4字节)用寄存器，其他用栈</td>
<td style="text-align:center">@+函数名+@+参数字节数</td>
</tr>
</tbody>
</table>
</div>
<h4 id="10-2-3-函数返回值传递"><a href="#10-2-3-函数返回值传递" class="headerlink" title="10.2.3 函数返回值传递"></a>10.2.3 函数返回值传递</h4><p>对于返回5～8字节的对象来说，几乎所有的调用惯例都是采用eax和edx联合返回的方式，在64位平台上可能会用更多的寄存器。但是如果返回对象过于庞大，则会用下面的方法来传递参数（用C语言作为例子，其他语言可能细节不一样）：</p>
<ul>
<li>调用方在栈上开辟了一片空间，把这片空间作为返回对象的临时存放区域，这里称为temp</li>
<li>把temp的地址作为隐藏参数传递给被调用函数</li>
<li>被调用函数完成功能以后，把结果拷贝到temp空间中，并把temp空间的地址作为返回值返回（一般用eax寄存器来返回结果）</li>
<li>回到主调函数后，主调函数再把eax寄存器指向的内容拷贝到真正的目的地内存中</li>
</ul>
<p>可以看到temp的空间被拷贝了两次，所以在c语言中，一般不会直接返回大字节数的对象，而是事先用malloc申请一块内存，然后再把内存指针传入函数中。这样就避免了多次内存读写。</p>
<h3 id="10-3-堆与内存管理"><a href="#10-3-堆与内存管理" class="headerlink" title="10.3 堆与内存管理"></a>10.3 堆与内存管理</h3><h4 id="10-3-1-堆的结构"><a href="#10-3-1-堆的结构" class="headerlink" title="10.3.1 堆的结构"></a>10.3.1 堆的结构</h4><p>堆内存是应用程序中比较大的一块内存空间，也是使用起来最自由的内存空间（当然，也最容易出内存泄露的bug）。一般来讲，内存是操作系统管理的，可以用系统调用来直接申请内存，不过这样会频繁进行用户态/内核态的切换。</p>
<p>所以一般语言的runtime在申请堆内存时，会向操作系统“批发”一大块内存，然后再“零售”给程序。当内存用完时会再向系统“进货”。c语言的runtime对内存管理就是基于上述的机制，而且runtime本身也会严格管理内存的分配，不会把同一块内存空间分配两次。这个强大高效的算法就是堆的分配算法。</p>
<h4 id="10-3-2-Linux进程堆管理"><a href="#10-3-2-Linux进程堆管理" class="headerlink" title="10.3.2 Linux进程堆管理"></a>10.3.2 Linux进程堆管理</h4><p>Linux提供了两个系统调用来管理堆空间：一个是<code>brk()</code>，一个是<code>mmap()</code>。</p>
<p>brk调用的实际作用起始是设置进程数据段的结束地址，可以扩大或者缩小。如果向高地址空间扩展，扩展出来的空间就可以用来做堆空间。</p>
<p>mmap是用来向操作系统申请一段虚拟地址空间，这个空间可以映射到文件，也可以不映射。不映射到文件时，就称为匿名空间。匿名空间就可以拿来当堆空间。</p>
<h4 id="10-3-4-堆分配算法"><a href="#10-3-4-堆分配算法" class="headerlink" title="10.3.4 堆分配算法"></a>10.3.4 堆分配算法</h4><ul>
<li><p>空闲链表</p>
<p>把堆上的空间块按照链表的方式穿起来。使用时，遍历链表查找满足条件的块</p>
</li>
<li><p>位图</p>
<p>把堆空间分割成固定大小的块，然后用一个位图来记录分配情况</p>
</li>
<li><p>对像池</p>
<p>如果分配对象的大小是固定的几个值，可以用对像池的办法来管理</p>
</li>
<li><p>多种算法结合</p>
<p>实际环境中，分配算法一般是根据多种算法复合而成。对于glibc来说，小于64字节的是采用类似于对像池的方法; 而对于大于512字节的空间申请采用的是最佳适配算法; 对于64字节和512字节之间的，会采取上述方法中的最佳折中策略; 对于大于128KB的申请，它会使用mmap机制直接向操作系统申请空间</p>
</li>
</ul>
<h2 id="11-运行库"><a href="#11-运行库" class="headerlink" title="11 运行库"></a>11 运行库</h2><h3 id="11-1-入口函数和程序初始化"><a href="#11-1-入口函数和程序初始化" class="headerlink" title="11.1 入口函数和程序初始化"></a>11.1 入口函数和程序初始化</h3><h4 id="11-1-1-程序从main开始吗"><a href="#11-1-1-程序从main开始吗" class="headerlink" title="11.1.1 程序从main开始吗"></a>11.1.1 程序从main开始吗</h4><p>操作系统装载C语言编写的程序以后，最先运行的并不是main函数，而是要进行一系列准备工作后才会调用main函数。</p>
<p>执行这些准备工作的函数称为入口函数，它一般是运行库的一部分，一个典型的准备工作大致有下面几个方面：</p>
<ul>
<li>操作系统创建进程，把控制权交给程序的入口，这个入口一般是程序语言对应的运行库中的入口函数</li>
<li>入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量构造等等</li>
<li>入口函数初始化完成后，调用main函数，正式开始执行程序主体部分</li>
<li>main函数执行完毕之后，返回到入口函数。入口函数进行收尾的清理工作，包括全局变量析构、堆销毁、关闭I/O等等。然后调用执行系统调用结束进程</li>
</ul>
<h4 id="11-1-2-入口函数如何实现"><a href="#11-1-2-入口函数如何实现" class="headerlink" title="11.1.2 入口函数如何实现"></a>11.1.2 入口函数如何实现</h4><h5 id="GLIBC入口函数"><a href="#GLIBC入口函数" class="headerlink" title="GLIBC入口函数"></a>GLIBC入口函数</h5><p>在Linux中glibc是C语言的运行库，它的程序入口为_start。它的大致逻辑用伪代码来表示类似于下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _start()</span><br><span class="line">&#123;</span><br><span class="line">  %ebp = <span class="number">0</span>;   <span class="comment">//ebp寄存器设置为0</span></span><br><span class="line">  <span class="keyword">int</span> argc = pop from <span class="built_in">stack</span></span><br><span class="line">  <span class="keyword">char</span>** argv = top of <span class="built_in">stack</span></span><br><span class="line">  __libc_start_main(main, argc, __libc_csu_init, __libc_csu_fini, edx, top of <span class="built_in">stack</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_start函数主要是准备各种参数，再调用<code>__libc_start_main</code>函数来完成工作，它的函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __libc_start_main (</span><br><span class="line">  <span class="keyword">int</span> (*main) (<span class="keyword">int</span>, <span class="keyword">char</span> **, <span class="keyword">char</span> **),    <span class="comment">//main函数</span></span><br><span class="line">  <span class="keyword">int</span> argc,                               <span class="comment">//参数个数</span></span><br><span class="line">  <span class="keyword">char</span> * __unbounded *__unbounded ubp_av, <span class="comment">//参数列表和环境变量</span></span><br><span class="line">  __typeof (main) init,                   <span class="comment">//在main之前执行的逻辑</span></span><br><span class="line">  <span class="keyword">void</span> (*fini) (<span class="keyword">void</span>),                    <span class="comment">//在main之后执行的逻辑</span></span><br><span class="line">  <span class="keyword">void</span> (rtld_fini) (<span class="keyword">void</span>),                <span class="comment">//runtime loader fini，动态加载相关的收尾逻辑</span></span><br><span class="line">  <span class="keyword">void</span> * __unbounded stack_end            <span class="comment">//栈的最高地址</span></span><br><span class="line">) </span><br><span class="line">  </span><br><span class="line">&#123;<span class="comment">//函数主体</span></span><br><span class="line">  <span class="comment">// .........其他逻辑.........</span></span><br><span class="line">  __environ = ubp_ev;</span><br><span class="line">  __pthread_initialize_minimal();</span><br><span class="line">  __cxa_atexit(rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  __libc_init_first(argc, argv, __environ);</span><br><span class="line">  __cxa_atexit(fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  (*init)(argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .........其他逻辑.........</span></span><br><span class="line">  </span><br><span class="line">  result = main(argc, argv, __environ);</span><br><span class="line">  <span class="built_in">exit</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见在进行系列的初始化后，最终调用了main函数。</p>
<h4 id="11-1-3-运行库与I-O"><a href="#11-1-3-运行库与I-O" class="headerlink" title="11.1.3 运行库与I/O"></a>11.1.3 运行库与I/O</h4><p>I/O是程序中非常重要的部分，包括文件、管道、网络、命令行、信号等都属于I/O的范围。而文件则是实际使用最多的I/O实体。</p>
<p>在Linux里，文件操作是通过文件描述符（File Descriptor）进行的。设置文件描述符的原因是防止用户随意读写操作系统内核的文件对象。无论是Linux还是Windows，文件描述符总是和内核的文件对象相关联的，内核可以通过文件描述符来计算出内核的文件对象的地址，但这个能力并不对普通用户开放。</p>
<p>在Linux中，值为0、1、2的fd分别代表标准输入、标准输出和标准错误输出。在程序中打开文件得到的fd从3开始增长。fd具体是什么呢？在内核中，每一个进程都有一个私有的“打开文件表”，这个表是一个指针数组，每一个元素都指向一个内核的打开文件对象。而fd就是这个表的下标。当用户打开一个文件时，内核会在内部生成一个打开文件对象，并在这个表里找到一个空项，让这一项指向生成的打开文件对象，并返回这一项的下标作为fd。由于这个表处于内核，并且用户无法访问到，因此用户即使拥有fd，也无法得到打开文件对象的地址，只能够通过系统提供的函数来操作。 </p>
<h3 id="11-2-C-C-运行库"><a href="#11-2-C-C-运行库" class="headerlink" title="11.2 C/C++运行库"></a>11.2 C/C++运行库</h3><h5 id="11-2-1-C语言运行库"><a href="#11-2-1-C语言运行库" class="headerlink" title="11.2.1 C语言运行库"></a>11.2.1 C语言运行库</h5><p>任何一个C语言程序，它背后都有一套庞大的代码来进行支撑，以使得该程序能够正常运行。这套代码至少包括入口函数，以及所依赖的函数所构成的函数集合。以及各种标准库函数的实现。这样的代码集合称为运行时库（Runtime Library）。</p>
<p>一个C语言运行库大致包含了如下功能：</p>
<ul>
<li>启动与退出：包括入口函数及入口函数所依赖的其他函数等</li>
<li>标准函数：由C语言标准规定的C语言标准库所拥有的函数实现</li>
<li>堆：堆的封装和实现</li>
<li>语言实现：语言中一些特殊功能的实现</li>
<li>调试：实现调试功能</li>
</ul>
<h5 id="11-2-2-C语言标准库"><a href="#11-2-2-C语言标准库" class="headerlink" title="11.2.2 C语言标准库"></a>11.2.2 C语言标准库</h5><p>C语言现在有了统一的标准，即ANSI C，它的标准库由24个C头文件组成，例举几个常见的：</p>
<ul>
<li>标准输入输出、文件操作：stdio.h </li>
<li>字符操作：ctype.h</li>
<li>字符串操作：string.h</li>
<li>数学函数：math.h</li>
<li>资源管理、格式转换：stdlib.h</li>
<li>时间/日期：time.h</li>
<li>断言：assert.h</li>
<li>常数定义：limits.h / float.h</li>
<li>变长参数：stdarg.h</li>
<li>非局部跳转：setjmp.h</li>
</ul>
<h6 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h6><p>变长参数是C语言的特殊参数形式。如下面的函数声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>printf函数除了第一个参数类型为const char*外，后面可以追加任意数量和类型的参数。这主要得益于C语言默认的cdecl调用约定，即由函数调用者负责参数的压栈和出栈。</p>
<h6 id="非局部跳转"><a href="#非局部跳转" class="headerlink" title="非局部跳转"></a>非局部跳转</h6><p>C语言中有goto语句，不过goto只能在函数内跳转，想要跳转到其他函数内部执行就不行了。不过C语言提供了setjmp.h库，来提供非局部跳转的能力。</p>
<h5 id="11-2-3-glibc与MSVC-CRT"><a href="#11-2-3-glibc与MSVC-CRT" class="headerlink" title="11.2.3 glibc与MSVC CRT"></a>11.2.3 glibc与MSVC CRT</h5><p>glibc的标准静态库位于<code>/usr/lib/libc.a</code> 除了标准库外，它还有几个辅助程序运行的运行库，它们是<code>/usr/lib/crt1.o</code> 、 <code>/usr/lib/crti.o</code> 、 <code>/usr/lib/crtn.o</code> 这几个文件在程序加载中有着关键的作用。</p>
<p><code>crt1.o</code> 里面包含的就是程序的入口函数<code>_start</code>，由它负责调用<code>__libc_start_main</code> 初始化libc并且调用main函数进入真正的程序主体。</p>
<p>由于C++的出现和ELF文件的改进，出现了必须在main函数之前执行的全局/静态对象构造和必须在main之后执行的全局/静态对象析构，为了满足这一要求，运行库在每个目标文件中引入两个与初始化相关的段<code>.init</code>和<code>.finit</code> ，运行库会保证所有位于这两个段中的代码会先于/后于main函数执行。</p>
<p>为了方便运行库调用，最终输出文件中的<code>.init</code>和 <code>.finit</code>两个段实际上分别包含的是<code>_init()</code>和 <code>_finit()</code>这两个函数。<code>crti.o</code>和 <code>crtn.o</code> 这两个目标文件中包含的代码实际上是<code>_init()</code>和 <code>_finit()</code>这两个函数的开始和结束部分，当这两个文件和其他目标文件按照顺序链接起来后，刚好形成两个完整的函数<code>_init()</code>和 <code>_finit()</code>。</p>
<p>在最终链接完成之后，输出的目标文件中的<code>.init</code> 段只包含了一个函数<code>_init()</code>，这个函数的开始部分来自于<code>crti.o</code> 的<code>.init</code> 段，结束部分来自于<code>crtn.o</code> 的<code>.init</code> 段。为了保证最终输出文件中<code>.init</code> 和<code>.finit</code> 的正确顺序，我们必须保证在链接时，<code>crti. o</code> 必须在用户目标文件和系统库之前，而<code>crtn.o</code> 必须在用户目标文件和系统库之后。所以链接器的输入文件顺序一般是:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ld crt1.o crti.o [user_objects] [system_libraries] crtn.o</span></span><br></pre></td></tr></table></figure>
<p>由于<code>crt1.o</code> 不包含<code>.init</code> 段和<code>.finit</code> 段，所以不会影响最终生成<code>.init</code> 和<code>.fnit</code> 段时的顺序。输出文件中的<code>.init</code> 段看上去应该如图所示（对于<code>.finit</code> 来说也是一样）：</p>
<p><img src="/images/程序员的自我修养：库与运行库/11.2.3-1.png" alt="10.1-1" style="zoom:50%;" /></p>
<blockquote>
<p>在默认情况下，链接器会将<code>libc</code>、<code>crt1.o</code>等这些CRT和启动文件与程序的模块链接起来。但是有些时候我们可能不需要这些文件，或者希望使用自己的<code>libc</code>和<code>crt1.o</code>等启动文件，以替代系统默认的文件，这种情况在嵌入式系统或操作系统內核编译的时候很常见。GCC提高了两个参数<code>-nostartfile</code>和<code>-nostdlib</code>，分别用来取消默认的启动文件和C语言运行库。</p>
</blockquote>
<p>由于<code>.init</code>和 <code>.finit</code>段的特殊性（在main之前/后，执行），所以除了用来进行全局对象构造和析构外。一些监控用户程序性能或者调试工具经常用它来进行一些初始化和反初始化的工作。不过这些代码不能使用普通函数，因为函数的返回指令会使<code>_init()</code>函数提前返回，所以必须使用汇编代码，不能让编译器产生<code>ret</code>指令。</p>
<h2 id="12-系统调用与API"><a href="#12-系统调用与API" class="headerlink" title="12 系统调用与API"></a>12 系统调用与API</h2><h3 id="12-1-系统调用介绍"><a href="#12-1-系统调用介绍" class="headerlink" title="12.1 系统调用介绍"></a>12.1 系统调用介绍</h3><h4 id="12-1-1-什么是系统调用"><a href="#12-1-1-什么是系统调用" class="headerlink" title="12.1.1 什么是系统调用"></a>12.1.1 什么是系统调用</h4><p>操作系统的主要功能就是把硬件资源抽象化，抽象化以后的硬件资源通过特定的接口给应用程序使用，而最基础的接口就是系统调用。系统调用最主要的特点就是调用以后系统会切换到内核态执行固定的内核代码，这个过程主要是通过中断来实现的。在Linux中使用0x80号中断作为系统调用入口，而在Windows里系统调用中断号是0x2E 。</p>
<p>系统调用涵盖的功能很广，有程序运行所必需的支持，例如创建/退出进程和线程、进程内存管理，也有对系统资源的访问，例如文件、网络、进程间通信、硬件设备的访问，也可能有对图形界面的操作支持，例如 Windows下的GUI机制。</p>
<p>不过对于Windows来说，系统调用实际上不是它和程序最低层的接口，它的最底层接口是API。设计API层的目的是为了消除不同硬件和内核版本的差异，这也造就了Windows恐怖的兼容性。</p>
<h4 id="12-1-2-Linux系统调用"><a href="#12-1-2-Linux系统调用" class="headerlink" title="12.1.2 Linux系统调用"></a>12.1.2 Linux系统调用</h4><p>在x86系列的CPU中，系统调用由0x80中断完成，参数通过寄存器传递。EAX寄存器用于表示系统调用的接口号，比如EAX=1表示退出进程(exit); EAX=2表示创建进程(fork); EAX=3表示读取文件或IO(read); EAX=4表示写文件或lO( write)等，每个系统调用都对应于内核源代码中的一个函数。它们都是以“sys_”开头的，比如exit调用对应内核中的sys_exit函数。当系统调用返回时，EAX又作为调用结果的返回值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">EAX</th>
<th style="text-align:center">名字</th>
<th style="text-align:left">C语言定义</th>
<th style="text-align:center">含义</th>
<th style="text-align:left">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">exit</td>
<td style="text-align:left">void _exit(int status);</td>
<td style="text-align:center">退出进程</td>
<td style="text-align:left">EBX：退出码</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">fork</td>
<td style="text-align:left">pid_ fork(void);</td>
<td style="text-align:center">复制进程</td>
<td style="text-align:left">EBX：复制参数</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">read</td>
<td style="text-align:left">ssize_t read(int fd, void *buf, size_t count);</td>
<td style="text-align:center">读文件</td>
<td style="text-align:left">EBX：文件handler</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">write</td>
<td style="text-align:left">ssize_t write(int fd, const void *buf, size_t count);</td>
<td style="text-align:center">写文件</td>
<td style="text-align:left">EBX：文件handler</td>
</tr>
</tbody>
</table>
</div>
<p>这些系统调用可以直接用汇编代码根据中断定义来直接调用，也可以用C语言封装的接口来调用。不过直接虽然可以直接使用系统调用，但系统调用的功能太过原始。如直接用open()、read()、close()，来处理文件的话，需要自己处理缓冲、按行读取等功能，所以不如直接用glibc提供的fopen()、fread()、fclose()等现成的功能。</p>
<h4 id="12-1-3-系统调用的弊端"><a href="#12-1-3-系统调用的弊端" class="headerlink" title="12.1.3 系统调用的弊端"></a>12.1.3 系统调用的弊端</h4><p>系统调用的弊端是太过于底层，使用不方便。另外一点就是和系统实现相关，移植性不好。</p>
<p>所以人们在系统调用之上增加了跨平台的语言运行库，如C语言的运行库。使用C语言的fread函数时，在不同的系统中可能调用底层系统调用是不一样的，但向语言层面提供统一的接口，这样就可以只写一份代码然后运行在不同的系统上。</p>
<h3 id="12-2-系统调用原理"><a href="#12-2-系统调用原理" class="headerlink" title="12.2 系统调用原理"></a>12.2 系统调用原理</h3><h4 id="12-2-1-特权级与中断"><a href="#12-2-1-特权级与中断" class="headerlink" title="12.2.1 特权级与中断"></a>12.2.1 特权级与中断</h4><p>在x86系列的CPU上，系统代码和应用代码具有不同的特权等级。系统代码在最高级别运行，可以操作所有的硬件。应用代码在进行硬件操作时，就会使用中断来调用系统提供的功能来间接使用硬件。</p>
<p>中断是类似于高级语言中的回调方法，操作系统内核在启动后会注册一系列的中断处理方法，当应用程序调用中断时，会传入对应的终端号，来指明使用哪一个中断方法。</p>
<h4 id="12-2-2-基于int的Linux的经典系统调用实现"><a href="#12-2-2-基于int的Linux的经典系统调用实现" class="headerlink" title="12.2.2 基于int的Linux的经典系统调用实现"></a>12.2.2 基于int的Linux的经典系统调用实现</h4><h5 id="触发中断"><a href="#触发中断" class="headerlink" title="触发中断"></a>触发中断</h5><p>汇编指令<code>int</code>会触发CPU去查找事先准备好的中断表，用约定好的寄存器参数来调用中断处理函数。</p>
<h5 id="切换堆栈"><a href="#切换堆栈" class="headerlink" title="切换堆栈"></a>切换堆栈</h5><p>当实际执行中断表中的函数前，CPU必须先保存现场，以便完成任务后继续执行用户程序。这里保存现场主要就是保存栈寄存器（ESP、EBP等），以及当前的执行代码用到的寄存器（CS、EIP、EFLAG 等等）。保存好现场后，就会切换到内核态，所谓的切换起始就是向这些寄存器写入新的值，这些新值指向内核代码和内核内存区域。最后再执行中断处理函数。</p>
<h5 id="中断处理函数"><a href="#中断处理函数" class="headerlink" title="中断处理函数"></a>中断处理函数</h5><p>中断处理函数是操作系统内核预先设定好的，如任务切换，CPU执行异常处理等，它们在执行固定的逻辑后，把用户程序的执行环境恢复。最后再执行<code>iret</code>指令把执行流返回到之前发生中断的地方。</p>
<h4 id="12-2-3-Linux的新型系统调用机制"><a href="#12-2-3-Linux的新型系统调用机制" class="headerlink" title="12.2.3 Linux的新型系统调用机制"></a>12.2.3 Linux的新型系统调用机制</h4><p>Linux2.5版本后开始支持新的系统调用指令，即<code>sysenter</code>和<code>sysexit</code>，这两个指令和<code>int</code> 功能类似，但是把<code>int</code>执行的绝大部分逻辑都用硬件电路来实现了，这样性能要比<code>int</code>指令更好（int是一个通用的中断机制，并不是仅仅只能做内核/用户态的切换）。</p>
]]></content>
      
        <categories>
            
            <category> CS基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[程序员的自我修养：装载与动态链接]]></title>
      <url>http://petpwiuta.github.io/2020/05/09/%25E7%25A8%258B%25E5%25BA%258F%25E5%2591%2598%25E7%259A%2584%25E8%2587%25AA%25E6%2588%2591%25E4%25BF%25AE%25E5%2585%25BB%25EF%25BC%259A%25E8%25A3%2585%25E8%25BD%25BD%25E4%25B8%258E%25E5%258A%25A8%25E6%2580%2581%25E9%2593%25BE%25E6%258E%25A5/</url>
      <content type="html"><![CDATA[<h2 id="6-可执行文件的装载与进程"><a href="#6-可执行文件的装载与进程" class="headerlink" title="6 可执行文件的装载与进程"></a>6 可执行文件的装载与进程</h2><h3 id="6-1-进程虚拟地址空间"><a href="#6-1-进程虚拟地址空间" class="headerlink" title="6.1 进程虚拟地址空间"></a>6.1 进程虚拟地址空间</h3><p>程序被运行起来以后，它将拥有自己独立的虚拟地址空间（Virtual Address Space），这个虚拟地址空间的大小由CPU的位数决定的。硬件决定了地址空间的最大理论上限，比如32位的硬件平台决定了虚拟地址空间的大小是$ 2^{32}$也就是我们常说的4GB虚拟空间大小；而64位的硬件平台具有64位寻址能力，它的虚拟地址空间达到了$2^{64}$，即16384PB大小。</p>
<p>在程序实际运行的过程中，虚拟地址空间也不是全部被程序所使用。如Linux下，操作系统会占据一部分高地址空间，剩下的部分才是分配给应用程序的。</p>
<h3 id="6-2-装载的方式"><a href="#6-2-装载的方式" class="headerlink" title="6.2 装载的方式"></a>6.2 装载的方式</h3><p>现在的操作系统装载可执行文件都是使用分页式加载，即把虚拟内存空间分割成固定大小的页面，当实际有代码或数据使用的内存空间时，才会把虚拟的内存空间映射到物理内存中。</p>
<h3 id="6-3-从操作系统角度看可执行文件的装载"><a href="#6-3-从操作系统角度看可执行文件的装载" class="headerlink" title="6.3 从操作系统角度看可执行文件的装载"></a>6.3 从操作系统角度看可执行文件的装载</h3><h4 id="6-3-1-进程的建立"><a href="#6-3-1-进程的建立" class="headerlink" title="6.3.1 进程的建立"></a>6.3.1 进程的建立</h4><p>从操作系统的角度来看，一个进程最关键的特征是它拥有独立的虚拟地址空间，这使得它有别于其他进程。很多时候一个程序被执行同时都伴随着一个新的进程的创建 ，那么我们就来看看这种最通常的情形；创建一个进程，然后装载相应的可执行文件并且执行。在有虚拟存储的情况下，上述过程最开始只需要做三件事情：</p>
<ul>
<li>创建一个独立的虚拟地址空间</li>
<li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</li>
<li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</li>
</ul>
<h5 id="创建虚拟地址空间"><a href="#创建虚拟地址空间" class="headerlink" title="创建虚拟地址空间"></a>创建虚拟地址空间</h5><p>一个虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间，那么创建一个虚拟空间实际上并不是创建空间而是创建映射函数所需要的相应的数据结构，在x86的Linux下，创建虚拟地址空间实际上只是分配一个页目录（Page Directory）就可以了，甚至不设置页映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置都行。</p>
<h5 id="映射可执行文件到虚拟内存空间"><a href="#映射可执行文件到虚拟内存空间" class="headerlink" title="映射可执行文件到虚拟内存空间"></a>映射可执行文件到虚拟内存空间</h5><p>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。上一步的页映射关系函数是虚拟空间到物理内存的映射关系，这一步所做的是虚拟空间与可执行文件的映射关系。我们知道，当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。当操作系统捕获到缺页错误时，它应知道程序当前所需要的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系。从某种角度来看，这一步是整个装载过程中最重要的一步，也是传统意义上“装载”的过程。</p>
<h5 id="跳转到可执行文件入口，运行可执行文件"><a href="#跳转到可执行文件入口，运行可执行文件" class="headerlink" title="跳转到可执行文件入口，运行可执行文件"></a>跳转到可执行文件入口，运行可执行文件</h5><p>操作系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行。这一步看似简单，实际上在操作系统层面上比较复杂，它涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换。不过从进程的角度看这一步可以简单地认为操作系统执行了一条跳转指令直接跳转到可执行文件的入口地址。ELF文件头中保存有入口地址，CPU也就是从这个地址开始执行代码。</p>
<h4 id="6-3-2-页错误"><a href="#6-3-2-页错误" class="headerlink" title="6.3.2 页错误"></a>6.3.2 页错误</h4><p>上面的步骤执行完以后，其实可执行文件的真正指令和数据都没有被装入到内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系。当CPU开始打算执行入口地址的指令时，发现内存所属页面是个空页面，于是它就认为这是一个页错误（Page Fault）。CPU将控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况。</p>
<p>这时候前面提到的虚拟空间与可执行文件的映射关系结构起到了很关键的作用，操作系统将查询这个数据结构，找到空页面所在的段，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还回给进程，进程从刚才页错误的位置重新开始执行。</p>
<p>随着进程的执行，页错误也会不断地产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求。有时进程所需内存会超过实际可用的内存，这时候系统会把不常用的内存数据转移到磁盘中，来提升内存使用效率。</p>
<p><img src="/images/程序员的自我修养：装载与动态链接/6.3.2-1.png" alt="6.3.2-1" style="zoom:50%;" /></p>
<h3 id="6-4-进程虚拟内存空间分布"><a href="#6-4-进程虚拟内存空间分布" class="headerlink" title="6.4 进程虚拟内存空间分布"></a>6.4 进程虚拟内存空间分布</h3><h4 id="6-4-1-ELF文件链接视图和执行视图"><a href="#6-4-1-ELF文件链接视图和执行视图" class="headerlink" title="6.4.1 ELF文件链接视图和执行视图"></a>6.4.1 ELF文件链接视图和执行视图</h4><p>在ELF文件中，一般会有很多段，在把段加载到内存中时，会分配单独的内存页来控制段的内存权限。不过很多段都很小，这样单独分配一个内存页太浪费空间。所以处于节省内存的考虑，就在ELF文件中新增了Segment的概念，即把内存属性相似的段合在一起，形成Segment。</p>
<p>Segment的概念实际上是从装载的角度重新划分了ELF的各个分段。在将目标文件链接成可执行文件的时候，链接器会尽可能把相同权限属性的段分配在同一空间。</p>
<p>这样本来以前可能有几十个段，现在合并内存权限相似的同类项，最后只形成几个Segment。这样系统在加载时只用进行有限的几种内存权限控制就行了。</p>
<p>所以总的来说，“Segment”和“Section”是从不同的角度来划分同一个EF文件。这个在ELF中被称为不同的视图（View），从“Section”的角度来看ELF文件就是链接视图（Linking view），从“Segment”的角度来看就是执行视图（Execution view）。当我们在谈到ELF装载时，“段”专门指“Segment”；而在其他的情况下，“段”指是“Section”</p>
<p>ELF文件保存“Segment”信息的数据结构叫做程序头表（Program Header Table）。因为ELF目标文件不需要被装载，所以它没有程序头表；而经过静态/动态链接的ELF的可执行文件以及共享库文件都有。</p>
<p>和段表结构一样，程序头表也是一个数组结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word p_type;</span><br><span class="line">    Elf32_Off  p_offset;</span><br><span class="line">    Elf32_Addr p_vaddr;</span><br><span class="line">    Elf32_Addr p_paddr;</span><br><span class="line">    Elf32_Word p_filesz;</span><br><span class="line">    Elf32_Word p_memsz;</span><br><span class="line">    Elf32_Word p_flags;</span><br><span class="line">    Elf32_Word p_align;</span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure>
<p>具体的字段解释如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>p_type</td>
<td>这里主要关注“LOAD”类型。它的常量为1。还有“DYNAMIC”等类型（动态链接用）</td>
</tr>
<tr>
<td>p_offset</td>
<td>在ELF文件中的偏移量</td>
</tr>
<tr>
<td>p_vaddr</td>
<td>在进程虚拟内存空间中的起始位置。整个程序头表中，所有“LOAD”类型的元素按照p_addr从小到大排列</td>
</tr>
<tr>
<td>p_paddr</td>
<td>物理装载地址。一般和p_vaddr一样</td>
</tr>
<tr>
<td>p_filesz</td>
<td>在ELF文件中所占字节数</td>
</tr>
<tr>
<td>p_memse</td>
<td>在进程虚拟内存空间中所占字节数。可能大于p_filesz</td>
</tr>
<tr>
<td>p_flags</td>
<td>权限属性，如可写、可读、可执行</td>
</tr>
<tr>
<td>p_align</td>
<td>对齐属性。对齐字节数等于$ 2^{align}$。如p_align=10，那对齐字节数就是2的10次方，即1024</td>
</tr>
</tbody>
</table>
</div>
<p>对于“LOAD”类型的“Segment”来说，p_memse的值不可以小于p_files。但可以大于p_files。当大于p_files就表示该“Segment”在内存中所分配的空间大小超过文件中实际的大小。这部分“多余”的内存全部填充为“0”。这样做的好处是在构造ELF可执行文件时不需要再额外设立BSS的“Segment”了，可以把数据“Segment”的p_mems扩大，那些额外的部分就是BSS。</p>
<h4 id="6-4-2-堆和栈"><a href="#6-4-2-堆和栈" class="headerlink" title="6.4.2 堆和栈"></a>6.4.2 堆和栈</h4><p>Linux把进程虚拟空间中的一个段叫做虚拟内存区域（VMA，Virtual Memory Area）。之前说的Segment都会映射的VMA里。操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间。应用程序使用的栈和堆也是通过VMA来进行管理的。一个常见的进程虚拟空间如下图所示：</p>
<p><img src="/images/程序员的自我修养：装载与动态链接/6.4.2-1.png" alt="6.4.2-1" style="zoom:50%;" /></p>
<h2 id="7-动态链接"><a href="#7-动态链接" class="headerlink" title="7 动态链接"></a>7 动态链接</h2><h3 id="7-1-为什么要动态链接"><a href="#7-1-为什么要动态链接" class="headerlink" title="7.1 为什么要动态链接"></a>7.1 为什么要动态链接</h3><p>静态链接使得程序可以模块化开发和测试大幅提高开发效率。不过随着程序规模越来越大静态链接的诸多缺点也逐步暴露出来：</p>
<ul>
<li><p>内存和磁盘空间浪费</p>
<p>比如有个流行的库文件LibA，很多软件产品都使用，这些软件产品的最终可执行文件中都会包含LibA。某个用户电脑上安装多个软件产品后，电脑中就会存在多分LibA的副本。而且运行多个程序时，内存中也会存在多个LibA的副本。</p>
</li>
<li><p>程序开发和发布比较麻烦</p>
<p>如果LibA有bug，厂商发布了补丁以后，必须重新链接。用户需要重新下载整个可执行文件， 但是除了LibA意外，其他的都没有必要再下载一次。</p>
</li>
</ul>
<p>解决空间浪费和更新困难的办法就是把程序的模块相互分割开来，形成独立的文件，当程序要运行时再进行链接。这样库LibA是以独立的文件存在，多个程序可以共享，避免内存和磁盘的浪费；也能独立地发布和更新，提高软件产品的生产效率。上面这种按模块分割、到运行的时候再链接就是动态链接（Dynamic Linking）。</p>
<h3 id="7-3-地址无关代码"><a href="#7-3-地址无关代码" class="headerlink" title="7.3 地址无关代码"></a>7.3 地址无关代码</h3><h4 id="7-3-1-固定装载地址的困扰"><a href="#7-3-1-固定装载地址的困扰" class="headerlink" title="7.3.1 固定装载地址的困扰"></a>7.3.1 固定装载地址的困扰</h4><p>因为动态链接的库可能被多个程序使用，会被不同的程序加载到不同的位置。所以动态链接文件在编译时不能假设自己在进程的虚拟内存空间中的位置。</p>
<h4 id="7-3-2-装载时重定位"><a href="#7-3-2-装载时重定位" class="headerlink" title="7.3.2 装载时重定位"></a>7.3.2 装载时重定位</h4><p>在静态链接时说起过，符号要在编译时进行解析和重定位。这里也可以用同样的做法，即程序在运行时把动态链接库像静态库一样进行解析和重定位，这时的重定位叫做装载时重定位（Load Time Relocation），之前提到的重定位叫链接时重定位（Link Time Relocation）。</p>
<p>装载时重定位技术对于动态链接库的指令部分和数据部分有不同的影响。</p>
<p>对于数据部分来说。每个进程的数据都需要独立存在，所以动态链接库的数据部分在每个进程中都需要一个副本。</p>
<p>对于指令部分来说，从同一个可执行文件运行的进程，其指令部分必然是一样的。所以同一份动态链接库在内存中有多个副本是没有必要的。但是动态链接模块在装载时要进行重定位，需要修改指令引用的地址，A进程重定位后的动态链接库内指令引用的地址已经被修改，以适应A的进程空间里。这时，动态链接库肯定不能用到B上，所以B只能再把动态链接库重新制作一份副本，再进行一次装载时重定位。所以就造成在内存中存在同一份动态库的多个副本。</p>
<h4 id="7-3-3-地址无关代码"><a href="#7-3-3-地址无关代码" class="headerlink" title="7.3.3 地址无关代码"></a>7.3.3 地址无关代码</h4><p>要解决动态库指令部分重复的办法关键在于指令的地址。程序模块中共享的指令部分在装载时不要因为装载地址的改变而改变。</p>
<p>解决方案的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为地址无关代码（PC，Position-independent Code）的技术。</p>
<p>因为模块内的引用可以用模块内的相对地址偏移来实现，比较简单，所以地址无关的代码重点放在模块间的数据和指令的引用。</p>
<h5 id="模块间的数据访问"><a href="#模块间的数据访问" class="headerlink" title="模块间的数据访问"></a>模块间的数据访问</h5><p>之前提到，要使得代码地址无关，基本的思想就是把跟地址相关的部分放到数据段里面。很显然，这些其他模块的全局变量的地址是跟模块装载地址有关的。ELF的做法是在数据段里面建立一个指向这些变量的指针数组，也被称为全局偏移表（GOT，Global Offset Table），当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用。</p>
<p>当指令中需要访问某个模块外的全局变量时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4个字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。</p>
<h5 id="模块间的函数跳转"><a href="#模块间的函数跳转" class="headerlink" title="模块间的函数跳转"></a>模块间的函数跳转</h5><p>对于模块间的函数跳转也可以用GOT的方法，即在GOT表项中保存目标函数地址，当模块要调用函数时，通过GOT间接跳转。</p>
<h4 id="7-3-4-共享模块的全部变量问题"><a href="#7-3-4-共享模块的全部变量问题" class="headerlink" title="7.3.4 共享模块的全部变量问题"></a>7.3.4 共享模块的全部变量问题</h4><p>有一种很特殊的情况是，当一个模块引用了一个定义在共享对象的全局变量的时候，比如一个共享对象定义了一个全局变量global，而模块module.c中是这么引用的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> global;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    global = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当编译器编译module.c时，它无法根据这个上下文判断global是定义在同一个模块的的其他目标文件还是定义在另外一个共享对象之中，即无法判断是否为跨模块间的调用。</p>
<p>假设module.c是程序可执行文件的一部分，那么在这种情况下，由于程序主模块的代码并不是地址无关代码。由于可执行文件在运行时并不进行代码重定位，所以变量的地址必须在链接过程中确定下来。为了能够使得链接过程正常进行，链接器会在创建可执行文件时，在它的“.bss”段创建一个global变量的副本。那么问题就很明显了，现在global变量定义在原先的共享对象中，而在可执行文件的“.bss”段还有一个副本。如果同一个变量同时存在于多个位置中，这在程序实际运行过程中肯定是不可行的。</p>
<p>解决的办法只有一个，那就是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。ELF共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量，通过GOT来实现变量的访问。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把GOT中的相应地址指向该副本，这样该变量在运行时实际上最终就只有一个实例。如果变量在共享模块中被初始化，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本里；如果该全局变量在程序主模块中没有副本，那么GOT中的相应地址就指向模块内部的该变量副本。</p>
<h4 id="7-3-5-数据段地址无关性"><a href="#7-3-5-数据段地址无关性" class="headerlink" title="7.3.5 数据段地址无关性"></a>7.3.5 数据段地址无关性</h4><p>通过上面的方法，我们能够保证共享对象中的代码部分地址无关，其实数据部分也有绝对地址引用的问题。不过对于数据段来说，它在每个进程都有一份独立的副本，所以并不担心被进程改变。从这点来看，我们可以选择装载时重定位的方法来解决数据段中绝对地址引用问题。</p>
<p>对于共享对象来说，如果数据段中有绝对地址引用，那么编译器和链接器就会产生一个重定位表，用于解决上述问题。当动态链接器装载共享对象时，如果发现该共享对象有这样的重定位入口，那么动态链接器就会对该共享对象进行重定位。</p>
<p>实际上，我们甚至可以让代码段也使用这种装载时重定位的方法，而不使用地址无关代码。不过如果代码不是地址无关的，它就不能被多个进程之间共享，于是也就失去了节省内存的优点。但是装载时重定位的共享对象的运行速度要比使用地址无关代码的共享对象快，因为它省去了地址无关代码中每次访问全局数据和函数时需要做一次计算当前地址以及间接地址寻址的过程。</p>
<h3 id="7-4-延迟绑定（PLT）"><a href="#7-4-延迟绑定（PLT）" class="headerlink" title="7.4 延迟绑定（PLT）"></a>7.4 延迟绑定（PLT）</h3><p>动态链接比静态链接灵活，但是这是以牺牲一部分性能为代价的。动态链接比静态链接慢的主要原因是动态链接下要进行复杂的GOT定位以及间接寻址。另外一个原因是动态链接的链接工作在程序启动前完成，在启动前动态链接器会寻找并装载所需要的共享对象，进行符号査找地址重定位等工作，这一套流程下来势会必减慢程序的启动速度。下面就来介绍下优化动态链接性能的一些方法。</p>
<h5 id="延迟绑定实现"><a href="#延迟绑定实现" class="headerlink" title="延迟绑定实现"></a>延迟绑定实现</h5><p>在动态链接下，程序模块之间包含了大量的函数引用（全局变量往往比较少，因为大量的全局变量会导致模块之间耦合度变大），所以在程序开始执行前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号査找以及重定位，这也是我们上面提到的减慢动态链接性能的第二个原因。</p>
<p>不过在一个程序运行过程中，可能很多冷门模块的函数在程序执行完时都不会被用到。所以没必要一开始就把所有函数都链接好。因此ELF采用了一种叫做延迟绑定（Lazy Binding）的做法，就是当函数第一次被用到时才进行绑定（符号查找、重定位等），如果没有用到则不进行绑定。所以可以大大加快程序的启动速度</p>
<p>ELF使用PLT（Procedure Linkage Table）的方法来实现。PLT为了实现延迟绑定，在GOT间接跳转这个过程中间又增加了一层间接跳转。所有外部函数在PLT中都有一个对应项，调用函数时，会先调用PLT对应项的处理函数，它会先检查GOT中函数指针是否已经绑定，如果没有绑定会进行绑定，把正确的函数地址填入GOT表中，然后再调用GOT中的函数。</p>
<h3 id="7-5-动态链接相关结构"><a href="#7-5-动态链接相关结构" class="headerlink" title="7.5 动态链接相关结构"></a>7.5 动态链接相关结构</h3><h4 id="7-5-1-“-interp”段"><a href="#7-5-1-“-interp”段" class="headerlink" title="7.5.1 “.interp”段"></a>7.5.1 “.interp”段</h4><p>在Linux下，动态链接器ld.so实际上也是一个共亨对象，操作系统同样通过映射的方式将它加载到进程的地址空间中。操作系统在加载完动态链接器之后，就将控制权交给动态链接器的入口地址（与可执行文件一样，共享对象也有入口地址）。当动态链接器得到控制权之后，它开始执行一系列自身的初始化操作，然后根据当前的环境参数，开始对可执行文件进行动态链接工作。当所有动态链接工作完成以后，动态链接器会将控制权转交到可执行文件的入口地址，程序开始正式执行。</p>
<p>在ELF文件中，有个叫“.interp”的段，专门用来保存可执行文件所需要的动态链接器的路径。</p>
<h4 id="7-5-2-“-dynamic”段"><a href="#7-5-2-“-dynamic”段" class="headerlink" title="7.5.2 “.dynamic”段"></a>7.5.2 “.dynamic”段</h4><p>动态链接ELF中最重要的结构就是“.dynamic”段，这个段里面保存了动态链接器所需要的基本信息，比如依赖哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。它的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>
<p>EI32Dyn结构由一个类型值加上一个附加的数值或指针，对于不同的类型，后面附加的数值或者指针有着不同的含义。这里列举几个比较常见的类型值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>d_tag类型</th>
<th>d_un含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>DT_SYMTAB</td>
<td>动态链接符号表地址，d_ptr表示“.dynamic”的地址</td>
</tr>
<tr>
<td>DT_STRTAB</td>
<td>动态链接字符串表地址，d_ptr表示“.dynstr”的地址</td>
</tr>
<tr>
<td>DT_STRSZ</td>
<td>动态链接字符串表大小，d_val表示大小</td>
</tr>
<tr>
<td>DT_HASH</td>
<td>动态链接哈希表地址，d_val表示“.hash”的地址</td>
</tr>
<tr>
<td>DT_SONAME</td>
<td>本共享对象的“SO-NAME”</td>
</tr>
<tr>
<td>DT_RPATH</td>
<td>动态链接共享对象搜索路径</td>
</tr>
<tr>
<td>DT_INIT</td>
<td>初始化代码地址</td>
</tr>
<tr>
<td>DT_FINIT</td>
<td>反初始化代码地址</td>
</tr>
<tr>
<td>DT_NEED</td>
<td>依赖的其他共享对象文件，d_ptr表示所依赖的共享对象文件名</td>
</tr>
<tr>
<td>DT_REL / DT_RELA</td>
<td>动态链接重定位表地址</td>
</tr>
<tr>
<td>DT_RELENT / DT_RELAENT</td>
<td>动态重定位表入口数量</td>
</tr>
</tbody>
</table>
</div>
<h4 id="7-5-3-动态符号表"><a href="#7-5-3-动态符号表" class="headerlink" title="7.5.3 动态符号表"></a>7.5.3 动态符号表</h4><p>在静态链接中，有一个专门的段叫做符号表“symtab”（Symbol Table），里面保存了所有关于该目标文件的符号的定义和引用。动态链接的符号表跟它十分相似，叫做动态符号表（Dynamic Symbol Table），用来保存模块间的符号导入导出关系，这个段的段名通常叫做“.dynsym”（Dynamic Symbol）。</p>
<p>与“.symtab”不同的是，“.dynsym”只保存了与动态链接相关的符号，对于那些模块内部的符号则不保存。很多时候动态链接的模块同时拥有“.dynsym”和“.symtab”两个表，“.symtab”中往往保存了所有符号，包括“.dynsym”中的符号。</p>
<p>与“.symtab”类似，动态符号表也需要一些辅助的表，比如用于保存符号名的字符串表。静态链接时叫做符号字符串表“.strtab”（String Table），在这里就是动态符号字符串表”.dynstr”（Dynamic String Table）；由于动态链接下，我们需要在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的符号哈希表（“.hash”）。</p>
<h4 id="7-5-4-动态链接重定位表"><a href="#7-5-4-动态链接重定位表" class="headerlink" title="7.5.4 动态链接重定位表"></a>7.5.4 动态链接重定位表</h4><p>共享对象的重定位与静态链接”的目标文件的重定位十分类似，唯一有区别的是目标文件的重定位是在静态链接时完成的，而共享对象的重定位是在装载时完成的。</p>
<p>在静态链接中，日标文件里面包含有专门用于表示重定位信息的重定位表，比如“.rel.text”表示是代码段的重定位表，“.rel.data”是数据段的重定位表。动态链接的文件中，也有类似的重定位表分别叫做“rel.dyn”和“rel.plt’”，它们分别相当于“.rel.text”和“.rel.data”。“rel.dyn”是对数据引用的修正，它所修正的位置位于“got”以及数据段；而“rel.plt”是对函数引用的修正，它所修止的位置位于“.got.plt”。</p>
<h3 id="7-6-动态链接的步骤和实现"><a href="#7-6-动态链接的步骤和实现" class="headerlink" title="7.6 动态链接的步骤和实现"></a>7.6 动态链接的步骤和实现</h3><h4 id="7-6-1-动态链接器自举"><a href="#7-6-1-动态链接器自举" class="headerlink" title="7.6.1 动态链接器自举"></a>7.6.1 动态链接器自举</h4><p>动态链接器本身也是一个共享对象，但是它有一些特殊性。对于普通共享对象文件来说，它的重定位工作由动态链接器来完成；它也可以依赖于其他共亨对象，其中的被依赖的共亨对象由动态链接器负责链接和装载。可是对于动态链接器本身来说，它是一切动态加载的起源，所以它有一些特殊。</p>
<p>动态链接器本身不可以依赖于其他任何共享对象；其次是动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成。对于第一个条件我们可以人为地控制，在编写动态链接器时保证不使用任何系统库、运行库；对于第二个条件，动态链接器必须在启动时有段非常精巧的代码可以完成这项艰巨的工作而同时又不能用到全局和静态变量。这种具有一定限制条件的启动代码往往被称为自举（Boot strap）。</p>
<p>动态链接器入口地址即是自举代码的入口，当操作系统将进程控制权交给动态链接器时，动态链接器的自举代码即开始执行。自举代码首先会找到它自己的GOT。而GOT的第一个入口保存的即是“.dynamic”段的偏移地址，由此找到了动态连接器本身的“.dynamic”段。通过“.dynamic”中的信息，自举代码便可以获得动态链接器本身的重定位表和符号表等，从而得到动态链接器本身的重定位入口，先将它们全部重定位。从这一步开始，动态链接器代码中才可以开始使用自己的全局变量和静态变量。</p>
<p>实际上在动态链接器的自举代码中，除了不可以使用全局变量和静态变量之外，甚至不能调用函数，即动态链接器本身的函数也不能调用。因为动态链接库模块使用GOT/PLT的方式编译，对于模块内部的函数调用也是采用跟模块外部函数调用一样的方式，所以在GOT/PLT没有被重定位之前，自举代码不可以使用任何全局变量，也不可以调用函数。</p>
<h4 id="7-6-2-装载共享对象"><a href="#7-6-2-装载共享对象" class="headerlink" title="7.6.2 装载共享对象"></a>7.6.2 装载共享对象</h4><p>完成基本自举以后，动态链接器将可执行文件和链接器本身的符号表都合并到一个全局符号表（Global Symbol Table）。然后链接器开始寻找可执行文件所依赖的共享对象，前面提到过“.dynamic”段中，有一种类型的是DT_NEEDED，它所指出的是该可执行文件（或共享对象）所依赖的共享对象。由此，链接器可以列出可执行文件所需要的所有共享对象，并将这些共享对象的名字放入到一个装载集合中。然后链接器开始从集合里取个所需要的共享对象的名字，找到相应的文件后打开该文件，读取相应的ELF文件头和“.dynamic”段，然后将它相应的代码段和数据段映射到进程空间中。如果这个ELF共享对象还依赖于其他共享对象，那么将所依赖的共享对象的名字放到装载集合中。如此循环直到所有依赖的共享对象都被装载进来为止，当然链接器可以有不同的装载顺序，如果我们把依赖关系看作一个图的话，那么这个装载过程就是一个图的遍历过程，链接器可能会使用深度优先或者广度优先或者其他的顺序来遍历整个图，这取决于链接器，比较常见的算法一般都是广度优先的。</p>
<p>当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中，所以当所有的共享对象都被装载进来的时候，全局符号表里面将包含进程中所有的动态链接所需要的符号。</p>
<h5 id="符号优先级"><a href="#符号优先级" class="headerlink" title="符号优先级"></a>符号优先级</h5><p>在加载多个动态链接库时，可能会遇到符号冲突的问题。Linux下的动态链接器规定：当一个符号需要被加入全局符号表时，如果相同符号已经存在，则后加入的符号被忽略。</p>
<p>由于存在这种重名符号被直接忽略的问题，当程序使用大量共享对象时应该非常小心符号的重名问题，如果两个符号重名又执行不同的功能，那么程序运行时可能会将所有该符号名的引用解析到第一个被加入全局符号表的使用该符号名的符号，从而导致程序莫名其妙的错误。</p>
<h5 id="全局符号介入与地址无关代码"><a href="#全局符号介入与地址无关代码" class="headerlink" title="全局符号介入与地址无关代码"></a>全局符号介入与地址无关代码</h5><p>前面说到地址无关代码时，对于模块内部调用或跳转处理，只是简单地将其当作是相对地址调用/跳转。但实际上这个问题比想象中要复杂。由于存在全局符号会覆盖的情况，调用或跳转一个模块内的符号时，它可能会被其他的全局符号覆盖，导致那个相对地址部分就需要重定位，这又与共享对象的地址无关性矛盾。所以对于模块内的调用，编译器只能当作模块外部符号处理。</p>
<p>不过也有一个补救办法。就是把函数变成编译单元私有函数，即使用“static”关键字定义函数，这种情况下，编译器要确定函数不被其他模块覆盖，就可以直接用模块内部调用指令，加快函数的调用速度。</p>
<h4 id="7-6-3-重定位和初始化"><a href="#7-6-3-重定位和初始化" class="headerlink" title="7.6.3 重定位和初始化"></a>7.6.3 重定位和初始化</h4><p>当上面的步骤完成之后，链接器开始重新遍历可执行文件和每个共享对象的重定位表，将它们的GOT/PLT中的每个需要重定位的位置进行修正。因为此时动态链接器已经拥有了进程的全局符号表，所以修正过程也比较容易，跟前面提到的地址重定位的原理基本相同。</p>
<p>重定位完成之后，如果某个共享对象有“.init”段，那么动态链接器会执行“.init”段中的代码，用以实现共享对象特有的初始化过程，比如最常见的，共享对象中的C++的全局/静态对象的构造就需要通过“.init”来初始化。相应地，共享对象中还可能有“.finit”段，当进程退出时会执行“.finit”段中的代码，可以用来实现类似C++全局对象析构之类的操作</p>
<p>如果进程的可执行文件也有“.init”段，那么动态链接器不会执行它，因为可执行文件中的“.init”段和“.finit”段由程序初始化部分代码负责执行。</p>
<p>当完成了重定位和初始化之后，所有的准备工作就宣告完成了，所需要的共享对象也都已经装载并且链接完成了，这时候动态链接器就将进程的控制权转交给程序的入口并且开始执行。</p>
<h3 id="7-7-显式运行时链接"><a href="#7-7-显式运行时链接" class="headerlink" title="7.7 显式运行时链接"></a>7.7 显式运行时链接</h3><p>支持动态链接的系统往往都支持一种更加灵活的模块加载方式，叫做显式运行时链接（Explicit Run-time Linking），有时候也叫做运行时加载。也就是让程序自己在运行时控制加载指定的模块，并且可以在不需要该模块时将其卸载。从前面我们了解到的来看，如果动态链接器可以在运行时将共享模块装载进内存并且可以进行重定位等操作，那么这种运行时加载在理论上也是很容易实现的。而且一般的共享对象不需要进行任何修改就可以进行运行时装载，这种共享对象往往被叫做动态装载库（DynamicLoadingLibrary），其实本质上它跟一般的共享对象没什么区别，只是程序开发者使用它的角度不同。</p>
<p>这种运行时加载使得程序的模块组织变得很灵活，可以用来实现一些诸如插件、驱动等功能。当程序需要用到某个插件或者驱动的时候，才将相应的模块装载进来，而不需要从开始就将他们全部装载进来，从而减少了程序启动时间和内存使用。并且程序可以在运行的时候重新加载某个模块，这样使得程序本身不必重新启动而实现模块的增加、删除、更新等，这对于很多需要长期运行的程序来说是很大的优势。最常见的例子是web服务器程序，对于web服务器程序来说，它需要根据配置来选择不同的脚本解释器、数据库连接驱动等，对于不同的脚本解释器分别做成一个独立的模块，当web服务器需要某种脚本解释器的时候可以将其加载进来；这对于数据库连接的驱动程序也是一样的原理。另外对于一个可靠的web服务器来说，长期的运行是必要的保证，如果我们需要增加某种脚本解释器，或者某个脚本解释器模块需要升级，则可以通知web服务器程序重新装载该共亨模块以实现相应的目的。</p>
<p>在Linux中，从文件本身的格式上来看，动态库实际上跟一般的共享对象没有区别，正如我们前面讨论过的。主要的区别是共享对象是由动态链接器在程序启动之前负责装载和链接的，这一系列步骤都由动态连接器自动完成，对于程序本身是透明的；而动态库的装载则是通过一系列由动态链接器提供的API，具体地讲共有4个函数：打开动态库（dlopen）、查找符号（dsym）、错误处理（dlerror）以及关闭动态库（dlclose），程序可以通过这几个API对动态库进行操作。这几个API的实现是在/lib/libdl.so2里面，它们的声明和相关常量被定义在系统标准头文件<dlfcn.h>。</p>
<ul>
<li><p>dlopen()</p>
<p>打开一个动态库，并将其加载到进程的地址空间，完成初始化过程。</p>
<p>如果参数filename为NUL，那返回的就是全局符号表。</p>
</li>
<li><p>dlsym()</p>
<p>通过这个函数来查找符号，包括函数和变量。</p>
<p>前面在介绍动态链接实现时，已经碰到过许多共享模块中符号名冲突的问题，结论是当多个同名符号冲突时，先装入的符号优先，我们把这种优先级方式称为装载序列。</p>
<p>当我们的进程中有模块是通过dlopen装入的共享对象时，这些后装入的模块中的符号可能会跟先前已经装入了的模块之间的符号重复。不管是通过动态链接器加载还是程序主动加载，都是采用装载序列。</p>
<p>dlsym()对符号的查找优先级分两种类型。第一种情况是，如果我们是在全局符号表中进行符号查找，即dlopen()时，参数filename为NUL，那就是和全局符号表生成时的顺序一样，采用装载序列。第二种情况是如果我们是对某个通过dlopen()打开的共享对象进行符号查找的话，那么采用的是一种叫做依赖序列的优先级。它是以被dlopen()打开的那个共享对象为根节点，对它所有依赖的共享对象进行广度优先遍历的顺序。</p>
</li>
<li><p>dlerror()</p>
<p>调用dlopen()、dlsym()、dlclose()后，都可以用dlerror()来检查是否成功</p>
</li>
<li><p>dlclose()</p>
<p>卸载一个已经加载的模块。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> CS基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[程序员的自我修养：静态链接]]></title>
      <url>http://petpwiuta.github.io/2020/05/09/%25E7%25A8%258B%25E5%25BA%258F%25E5%2591%2598%25E7%259A%2584%25E8%2587%25AA%25E6%2588%2591%25E4%25BF%25AE%25E5%2585%25BB%25EF%25BC%259A%25E9%259D%2599%25E6%2580%2581%25E9%2593%25BE%25E6%258E%25A5/</url>
      <content type="html"><![CDATA[<h2 id="3-目标文件里有什么"><a href="#3-目标文件里有什么" class="headerlink" title="3 目标文件里有什么"></a>3 目标文件里有什么</h2><h3 id="3-1-目标文件格式"><a href="#3-1-目标文件格式" class="headerlink" title="3.1 目标文件格式"></a>3.1 目标文件格式</h3><p>现在PC平台流行的可执行文件格式主要是Windows的PE（Portable Executable）和Linux的ELF（Executable Linkable Format）格式。它们都是COFF（Common file format）格式的变种。</p>
<p>其实可执行文件与动态库/静态库文件大致结构是类似的，仅仅是因为不同目的而具有不同的段数据而已。目标文件大致可分为以下几种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">ELF文件类型</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">可从定位文件（Relocatable File）</td>
<td style="text-align:center">这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类</td>
<td style="text-align:center">Linux的<code>.o</code> / Windows的<code>.obj</code></td>
</tr>
<tr>
<td style="text-align:center">可执行文件（Executable File）</td>
<td style="text-align:center">这类文件包含了代码和数据，可以直接执行，一般都没有扩展名</td>
<td style="text-align:center">Linux的<code>.out</code> / Windows的<code>.exe</code></td>
</tr>
<tr>
<td style="text-align:center">共享目标文件（Shared Object File）</td>
<td style="text-align:center">这种文件包含了代码和数据，可以跟其他的可重定位文件和共享目标文件静态链接。也可以通过动态链接器将几个这种共享目标文件与可执行文件结合，作为进程映像的部分来运行</td>
<td style="text-align:center">Linux的<code>.so</code> / Windows的<code>.dll</code></td>
</tr>
<tr>
<td style="text-align:center">核心转储文件（Core Dump File）</td>
<td style="text-align:center">当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件</td>
<td style="text-align:center">Linux的core dump</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-2-目标文件是什么样的"><a href="#3-2-目标文件是什么样的" class="headerlink" title="3.2 目标文件是什么样的"></a>3.2 目标文件是什么样的</h3><p>目标文件里面的内容有数据和机器码。这些内容被按照不同的属性分成了多个Section，也叫做“段”。如专门放代码的<code>.text</code>/<code>.code</code>段，专门放数据的<code>.data</code>段······</p>
<p>很多段的名字都是以一个 <code>.</code>符号（句点）开始，这表示是系统保留的段，对于用户自己设立的段可以不以点号开始。</p>
<p>总的来说程序员代码被编译后主要分成了两种段：指令和数据。指令和数据起始是分开存放的，这样做的原因主要是处于以下几点原因：</p>
<ul>
<li>系统可能会同时运行程序的多个副本，此时，程序的代码部分都是完全一样的，仅仅只有数据不同。指令部分抽离出来形成单独的段，可以让程序的副本共享同一个指令段，节省内存</li>
<li>现代的CPU有着强大的指令缓存体系，指令放到独立的段，有助于CPU预加载指令，来提高执行性能</li>
<li>指令放到单独的段可以精细控制内存访问属性，防止代码指令被修改</li>
</ul>
<h3 id="3-3-目标文件详解"><a href="#3-3-目标文件详解" class="headerlink" title="3.3 目标文件详解"></a>3.3 目标文件详解</h3><p>在Linux下，可以用objdump来把目标文件的段信息打印出来</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -s -d object_file.o  <span class="comment">#-s表示16进制打印，-d表示把所有包含指令的段反汇编</span></span></span><br></pre></td></tr></table></figure>
<p><code>.data</code> 段保存了初始化了的全局静态变量和局部静态变量</p>
<p><code>.rodata</code> 段保存了制度数据，如const修饰的变量，和字符串变量</p>
<p><code>.bss</code> 段存放的是未初始化的全局变量和局部静态变量</p>
<p>还有一些其他的常见的段：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">段名</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">.rodata1</td>
<td style="text-align:center">只读数据，和rodata类似</td>
</tr>
<tr>
<td style="text-align:left">.comment</td>
<td style="text-align:center">存放编译器版本信息</td>
</tr>
<tr>
<td style="text-align:left">.debug</td>
<td style="text-align:center">调试信息</td>
</tr>
<tr>
<td style="text-align:left">.dynamic</td>
<td style="text-align:center">动态链接库中才会用到，用来存放动态链接数据</td>
</tr>
<tr>
<td style="text-align:left">.hash</td>
<td style="text-align:center">加速符号查找的hash算法用到的段</td>
</tr>
<tr>
<td style="text-align:left">.line</td>
<td style="text-align:center">存储行号，用来调试</td>
</tr>
<tr>
<td style="text-align:left">.note</td>
<td style="text-align:center">额外的编译器信息，如公司名字等</td>
</tr>
<tr>
<td style="text-align:left">.strtab</td>
<td style="text-align:center">字符串表，用于存储ELF文件中用到的各种字符串</td>
</tr>
<tr>
<td style="text-align:left">.symtab</td>
<td style="text-align:center">符号表</td>
</tr>
<tr>
<td style="text-align:left">.shstrtab</td>
<td style="text-align:center">段名表</td>
</tr>
<tr>
<td style="text-align:left">.plt / .got</td>
<td style="text-align:center">动态链接的跳转和全局入口表</td>
</tr>
<tr>
<td style="text-align:left">.init / .fini</td>
<td style="text-align:center">C++全局构造和析构代码段</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-4-ELF文件结构描述"><a href="#3-4-ELF文件结构描述" class="headerlink" title="3.4 ELF文件结构描述"></a>3.4 ELF文件结构描述</h3><p>ELF目标文件格式的最前部是ELF文件头（ELF Header），它包含了描述整个文件的基本属性，如ELF文件版本、目标机器型号、程序入口地址等。</p>
<p>紧接着是ELF文件各个段。其中最重要结构就是段表（Section Header Table），该表描述了ELF文件包含的所有段的信息，比如每个段的段名、长度、在文件中的偏移、读写权限及段的其他属性。</p>
<p>还有就是一些ELF中辅助的结构，比如字符串表、符号表等：</p>
<p><img src="/images/程序员的自我修养：静态链接/3.4-1.png" alt="3.4-1" style="zoom:50%;" /></p>
<h4 id="3-4-1-文件头"><a href="#3-4-1-文件头" class="headerlink" title="3.4.1 文件头"></a>3.4.1 文件头</h4><p>可以用readelf命令来详细查看elf文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> readelf -h object_file.o <span class="comment">#-h 表示header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  ELF 头：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Magic：  7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  类别:                              ELF32</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  数据:                              2 补码，小端序 (little endian)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Version:                           1 (current)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  ABI 版本:                          0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  类型:                              EXEC (可执行文件)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  系统架构:                          Intel 80386</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  版本:                              0x1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  入口点地址：              0x8049000</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  程序头起点：              52 (bytes into file)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Start of section headers:          8228 (bytes into file)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Size of section headers:           40 (bytes)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Number of section headers:         4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Section header string table index: 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  标志：             0x0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Size of this header:               52 (bytes)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Start of program headers:          0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Size of program headers:           32 (bytes)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Number of program headers:         3</span></span><br></pre></td></tr></table></figure>
<p>从上而输出的结果可以看到，ELF的文件头中定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、AB版本、ELF重定位类型、硬件平台、硬件平台版本入口地址、程序头入口和长度、段表的位置和长度及段的数量等。</p>
<p>这里面非常重要的几个字段是：</p>
<ul>
<li><p>ELF Magic Number。这个常数用来识别这个文件属于ELF格式。很多二进制文件开头都有Magic Number，ELF格式也例外</p>
</li>
<li><p>类型（Type）。表示该ELF是可执行文件还是静态库/动态库或者是其他类型</p>
</li>
<li><p>入口点地址（Entry point address）。操作系统加载完该程序后，会从这个地址开始执行代码。只有可执行文件这个字段是有效的</p>
</li>
<li><p>段表信息</p>
<ul>
<li>段表的偏移地址（Start of section headers）。表示段表在ELF文件的第N个字节处开始</li>
<li>段表的描述符大小（Size of section headers）。表示一个段表的描述结构的大小</li>
<li>段表的描述符数量（Number of section headers）。表示有多少个段表</li>
<li>段名的下标（Section header string table index）。</li>
</ul>
<p>一个段从哪儿开始，每个段长度多少，有多少个段。有了这些信息就能找到每个段的数据。</p>
</li>
<li><p>Segment表信息</p>
<ul>
<li>Segment的偏移地址（Start of program headers）。表示Segment表在ELF文件的第N个字节处开始</li>
<li>Segment的描述符大小（Size of program headers）。表示一个Segment的描述结构的大小</li>
<li>Segment的描述符数量（Number of program headers）。表示有多少个Segment表</li>
</ul>
<p>在ELF文件中，一般会有很多段，在把段加载到内存中时，会分配单独的内存页来控制段的内存权限。不过很多段都很小，这样单独分配一个内存页太浪费空间。所以处于节省内存的考虑，就在ELF文件中新增了Segment的概念，即把内存属性相似的段合在一起，形成Segment。</p>
<p>这样本来以前可能有几十个段，现在合并内存权限相似的同类项，最后只形成几个Segment。这样系统在加载时只用进行有限的几种内存权限控制就行了。</p>
<p>不过Segment和并不是彼此替代关系。所有的Segment和所有的段表示的内容必然是一样的，只是两者侧重点不同，段是为了方便编译和执行而出现的；而Segment则是为了方便系统加载程序而出现。</p>
</li>
</ul>
<h4 id="3-4-2-段表"><a href="#3-4-2-段表" class="headerlink" title="3.4.2 段表"></a>3.4.2 段表</h4><p>之前用的readelf命令也可以用来来查看段表</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> readelf -S object_file.o <span class="comment">#-S 表示Section</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  There are 15 section headers, starting at offset 0x308:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash">  节头：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 1] .group            GROUP           00000000 000034 000008 04     12  12  4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 2] .text             PROGBITS        00000000 00003c 000051 00  AX  0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 3] .rel.text         REL             00000000 000244 000030 08   I 12   2  4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 4] .data             PROGBITS        00000000 00008d 000000 00  WA  0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 5] .bss              NOBITS          00000000 00008d 000000 00  WA  0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 6] .rodata           PROGBITS        00000000 00008d 00001a 00   A  0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 7] .text.__x86.get_p PROGBITS        00000000 0000a7 000004 00 AXG  0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 8] .comment          PROGBITS        00000000 0000ab 000012 01  MS  0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [ 9] .note.GNU-stack   PROGBITS        00000000 0000bd 000000 00      0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [10] .eh_frame         PROGBITS        00000000 0000c0 000050 00   A  0   0  4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [11] .rel.eh_frame     REL             00000000 000274 000010 08   I 12  10  4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [12] .symtab           SYMTAB          00000000 000110 0000f0 10     13  11  4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [13] .strtab           STRTAB          00000000 000200 000042 00      0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [14] .shstrtab         STRTAB          00000000 000284 000082 00      0   0  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Key to Flags:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    L (link order), O (extra OS processing required), G (group), T (TLS),</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    C (compressed), x (unknown), o (OS specific), E (exclude),</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    p (processor specific)</span></span><br></pre></td></tr></table></figure>
<p> readelf输出的结果就是ELF的文件段表的内容。段表的是一个“Elf32_Shdr”结构为元素的数组。“Elf_Shdr”又被称为段描述符。“Elf32_Shdr”结构被定义在“/usr/include/elf.h”，结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word sh_name;</span><br><span class="line">    Elf32_Word sh_type;</span><br><span class="line">    Elf32_Word sh_flags;</span><br><span class="line">    Elf32_Addr sh_addr;</span><br><span class="line">    Elf32_off  sh_offset;</span><br><span class="line">    Elf32_Word sh_size;</span><br><span class="line">    Elf32_Word sh_link;</span><br><span class="line">    Elf32_Word sh_info;</span><br><span class="line">    Elf32 Word sh_addralign;</span><br><span class="line">    Elf32_Word sh_entsize;</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>
<p>Elf32_Shdr的各个成员含义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sh_name</td>
<td>段名是个字符串，它位于一个叫做“.shstrtab”的字符串表。sh_name是段名字符串在“.shstrtab”中的偏移</td>
</tr>
<tr>
<td>sh_type</td>
<td>类型</td>
</tr>
<tr>
<td>sh_flags</td>
<td>段标志</td>
</tr>
<tr>
<td>sh_addr</td>
<td>如果该段可以被加载，则sh_addr为该段被加载后在进程地址空间中的虚拟地址，否则该值为0</td>
</tr>
<tr>
<td>sh_offset</td>
<td>如果该段存在于文件中，则表示该段在文件中的偏移；否则无意义。比如sh_offset对于BSS段来说就没有意义</td>
</tr>
<tr>
<td>sh_size</td>
<td>段的长度</td>
</tr>
<tr>
<td>sh_link / sh_info</td>
<td>段的链接信息</td>
</tr>
<tr>
<td>sh_addralign（段地址对齐）</td>
<td>有些段对段地址对齐有要求，比如我们假设有个段刚开始的位置包含了一个double变量，因为x86系统要求浮点数的存储地址必须是本身的整数倍，也就是说保存 double变量的地址必须是8字节的整数倍。这样对一个段来说，它的 sh_addr必须是8的整数倍<br/><br/>由于地址对齐的数量都是2的指数倍，sh_addralign表示是地址对齐数量中的指数，即 sh_addrlign=3表示对齐为2的3次方倍，即8倍,依此类推所以一个段的地址 sh_addr必须满足下面的条件，$sh_addr\% \left( 2^{sh_addrlign}\right) =0 $ <br/><br/>如果 sh_addralign为0或1，则表示该段没有对齐要求</td>
</tr>
<tr>
<td>sh_entsize（项的长度）</td>
<td>有些段包含了一些固定大小的项，比如符号表，它包含的每个符号所占的大小都是一样的。对于这种段，sh_entsize表示每个项的大小。如果为0，则表示该段不包含固定大小的项</td>
</tr>
</tbody>
</table>
</div>
<h5 id="段的类型（sh-type）"><a href="#段的类型（sh-type）" class="headerlink" title="段的类型（sh_type）"></a>段的类型（sh_type）</h5><p>段的名字只是在链接和编译过程中有意义，但它不能真正地表示段的类型。我们也可以将一个数据段命名为“text”，对于编译器和链接器来说，主要决定段的属性的是段的类型(sh_type)和段的标志位(sh_flags)。该字段的取值如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th style="text-align:center">值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHT_NULL</td>
<td style="text-align:center">0</td>
<td>无效段</td>
</tr>
<tr>
<td>SHT_PROGBITS</td>
<td style="text-align:center">1</td>
<td>代码段、数据段都是该类型</td>
</tr>
<tr>
<td>SHT_SYMTAB</td>
<td style="text-align:center">2</td>
<td>符号表</td>
</tr>
<tr>
<td>SHT_STRTAB</td>
<td style="text-align:center">3</td>
<td>字符串表</td>
</tr>
<tr>
<td>SHT_RELA</td>
<td style="text-align:center">4</td>
<td>重定位表</td>
</tr>
<tr>
<td>SHT_HASH</td>
<td style="text-align:center">5</td>
<td>符号表的哈希表</td>
</tr>
<tr>
<td>SHT_DYNAMIC</td>
<td style="text-align:center">6</td>
<td>动态链接信息</td>
</tr>
<tr>
<td>SHT_NOTE</td>
<td style="text-align:center">7</td>
<td>提示性信息</td>
</tr>
<tr>
<td>SHT_NOBITS</td>
<td style="text-align:center">8</td>
<td>表示该段在文件中没有内容</td>
</tr>
<tr>
<td>SHT_REL</td>
<td style="text-align:center">9</td>
<td>该段包含了重定位信息，用与静态链接</td>
</tr>
<tr>
<td>SHT_SHLIB</td>
<td style="text-align:center">10</td>
<td>保留</td>
</tr>
<tr>
<td>SHT_DNYSYM</td>
<td style="text-align:center">11</td>
<td>动态链接的符号表</td>
</tr>
</tbody>
</table>
</div>
<h5 id="段的标志位（sh-flag）"><a href="#段的标志位（sh-flag）" class="headerlink" title="段的标志位（sh_flag）"></a>段的标志位（sh_flag）</h5><p>段的标志位表示该段在进程虚拟地址在地址空间中的属性，比如是否可写，是否可执行等。该字段的取值如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th style="text-align:center">值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHF_WRITE</td>
<td style="text-align:center">1</td>
<td>表示该段在进程空间中可写</td>
</tr>
<tr>
<td>SHF_ALLOC</td>
<td style="text-align:center">2</td>
<td>表示该段在进程空间中须要分配空间。有些包含指示或控制信息的段不须要在进程空间中被分配空间，它们一般不会有这个标志。像代码段、数据段和bss段都会有这个标志位</td>
</tr>
<tr>
<td>SHF_EXECINSTR</td>
<td style="text-align:center">4</td>
<td>表示该段在进程空间中可执行，一般代码段是这个属性</td>
</tr>
</tbody>
</table>
</div>
<p>常见的段的标志位如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>段名</th>
<th style="text-align:left">sh_type</th>
<th style="text-align:center">sh_flag</th>
</tr>
</thead>
<tbody>
<tr>
<td>.bss</td>
<td style="text-align:left">SHT_NOBITS</td>
<td style="text-align:center">SHF_ALLOC + SHF_WRITE</td>
</tr>
<tr>
<td>.comment</td>
<td style="text-align:left">SHT_PROGBITS</td>
<td style="text-align:center">none</td>
</tr>
<tr>
<td>.data</td>
<td style="text-align:left">SHT_PROGBITS</td>
<td style="text-align:center">SHF_ALLOC + SHF_WRITE</td>
</tr>
<tr>
<td>.debug</td>
<td style="text-align:left">SHT_PROGBITS</td>
<td style="text-align:center">none</td>
</tr>
<tr>
<td>.dynamic</td>
<td style="text-align:left">SHT_DYNAMIC</td>
<td style="text-align:center">SHF_ALLOC + SHF_WRITE<br/>有些系统里.dynamic是只读的只有SHF_ALLOC</td>
</tr>
<tr>
<td>.hash</td>
<td style="text-align:left">SHT_HASH</td>
<td style="text-align:center">SHF_ALLOC</td>
</tr>
<tr>
<td>.line</td>
<td style="text-align:left">SHT_PROGBITS</td>
<td style="text-align:center">none</td>
</tr>
<tr>
<td>.note</td>
<td style="text-align:left">SHT_NOTE</td>
<td style="text-align:center">none</td>
</tr>
<tr>
<td>.rodata</td>
<td style="text-align:left">SHT_PROGBITS</td>
<td style="text-align:center">SHF_ALLOC</td>
</tr>
<tr>
<td>.shstrtab</td>
<td style="text-align:left">SHT_STRTAB</td>
<td style="text-align:center">none</td>
</tr>
<tr>
<td>.strtab</td>
<td style="text-align:left">SHT_PROGBITS</td>
<td style="text-align:center">如果ELF文件中有可装载的段须要用到该字符串表，那么该字符串表也将被装载到进程空间，则有SHF_ALLOC标志位</td>
</tr>
<tr>
<td>.symtab</td>
<td style="text-align:left">SHT_STRTAB</td>
<td style="text-align:center">同字符串表</td>
</tr>
<tr>
<td>.text</td>
<td style="text-align:left">SHT_PROGBITS</td>
<td style="text-align:center">SHF_ALLOC + SHF_EXECINSTR</td>
</tr>
</tbody>
</table>
</div>
<h5 id="段的链接信息（sh-link、sh-info）"><a href="#段的链接信息（sh-link、sh-info）" class="headerlink" title="段的链接信息（sh_link、sh_info）"></a>段的链接信息（sh_link、sh_info）</h5><p>如果段是和链接相关的，如重定位表、符号表等，那么这些段的含义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>sh_type</th>
<th style="text-align:left">sh_link</th>
<th style="text-align:center">sh_info</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHT_DYNAMIC</td>
<td style="text-align:left">该段所使用的字符串表在段表中的下标</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td>SHT_HASH</td>
<td style="text-align:left">该段所使用的符号表在段表中的下标</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td>SHT_REL</td>
<td style="text-align:left">该段所使用的相应符号表在段表中的下标</td>
<td style="text-align:center">该重定位表所作用的段在段表中的下标</td>
</tr>
<tr>
<td>SHT_RELA</td>
<td style="text-align:left">该段所使用的相应符号表在段表中的下标</td>
<td style="text-align:center">该重定位表所作用的段在段表中的下标</td>
</tr>
<tr>
<td>SHT_SYMTAB</td>
<td style="text-align:left">操作系统相关</td>
<td style="text-align:center">操作系统相关</td>
</tr>
<tr>
<td>SHT_DYNSYM</td>
<td style="text-align:left">操作系统相关</td>
<td style="text-align:center">操作系统相关</td>
</tr>
<tr>
<td>other</td>
<td style="text-align:left">SHN_UNDEF</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-4-3-重定位表"><a href="#3-4-3-重定位表" class="headerlink" title="3.4.3 重定位表"></a>3.4.3 重定位表</h4><p>链接器在处理目标文件时，须要对目标文件的代码段和数据段中那些对绝对地址的引用的位置进行重定位。这些重定位的信息都记录在ELF文件的重定位表里面，对于每个须要重定位的代码段或数据段，都会有一个相应的重定位表。比如之前的示例中，”rel.text“就是针对“text”段的重定位表。而”data“段则没有对绝对地址的引用，所以没有针对”data“段的重定位表”rel. data“。</p>
<h4 id="3-4-4-字符串表"><a href="#3-4-4-字符串表" class="headerlink" title="3.4.4 字符串表"></a>3.4.4 字符串表</h4><p>ELF文件中用到了很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。这样就诞生了字符串表这个结构。</p>
<p>最常见的字符串表就是”.strtab“和”.shstrtab“。这两个字符串表分别为字符串表（String Table）和段表字符串表（Section Header String Table）。字符串表用来保存普通的字符串，如符号的名字；段表字符串表用来保存段表中用到的字符串，如段名。</p>
<h3 id="3-5-链接的接口——符号"><a href="#3-5-链接的接口——符号" class="headerlink" title="3.5 链接的接口——符号"></a>3.5 链接的接口——符号</h3><p>在开发中，每个模块都会使用其他模块的功能，或者提供功能给其他模块引用，上述方法能成功工作是因为模块的函数或者变量都有自己独特的名字，避免了引用时发生混淆。在链接中这些函数和变量统称为符号，它们的名字就是符号名。</p>
<p>整个链接过程就是基于符号才能够正确完成。所以链接中很关键的一环就是符号管理，每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录了目标文件中所用到的所有符号。每个定义的符号有个对应的值，叫做符号值( Symbol Value)，对于变量和函数来说，符号值就是它们的地址。除了函数和变量之外，还存在其他几种不常用到的符号。我们将符号表中所有的符号进行分类，它们有可能是下面这些类型中的一种：</p>
<ul>
<li>定义在本目标文件的全局符号。可以被其他目标文件引用</li>
<li>在本目标文件中引用却在其他文件中定义的全局符号。这一般叫外部符号</li>
<li>局部符号。如本地的局部变量，这类符号仅仅在编译单元内部可见，因为链接器仅仅关注模块间的关系，所以这些符号其实对链接器来说没有什么作用。不过调试器可以使用这些符号来分析程序或崩溃时的核心转储文件</li>
<li>段名 、行号。这些符号用来提供一些辅助功能</li>
</ul>
<p>对于链接器来说，最重要的还是前面两种符号。</p>
<h4 id="3-5-1-ELF-符号表结构"><a href="#3-5-1-ELF-符号表结构" class="headerlink" title="3.5.1 ELF 符号表结构"></a>3.5.1 ELF 符号表结构</h4><p>ELF文件的符号表往往是文件的”symtab“段。它的结构很简单，是一个Elf32_Sym结构（32位ELF文件）的数组，每个Elf32_Sym结构对应一个符号。这个数组的第一个元素，也就是下标0的元素为无效的”未定义“符号。Elf32_Sym的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word st_name;</span><br><span class="line">    Elf32_Addr st_value;</span><br><span class="line">    Elf32_Word st_size;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;</span><br><span class="line">  	<span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; </span><br><span class="line">    Elf32_Half    st_shndx;</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>
<p>Elf32_Sym的各个成员含义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>st_name</td>
<td>符号名，这个字段的值是该符号在字符串表中的下标</td>
</tr>
<tr>
<td>st_value</td>
<td>符号相对应的值。这个值跟符号有关，可能是一个绝对值，也可能是一个地址等，不同的符号，它所对应的值含义不同</td>
</tr>
<tr>
<td>st_size</td>
<td>符号大小。对于包含数据的符号，这个值是该数据类型的大小。如 double 类型的符号就是 8 个字节</td>
</tr>
<tr>
<td>st_info</td>
<td>符号类型和绑定信息</td>
</tr>
<tr>
<td>st_other</td>
<td>目前未用</td>
</tr>
<tr>
<td>st_shndx</td>
<td>符号所在的段</td>
</tr>
</tbody>
</table>
</div>
<h5 id="符号值（st-value）"><a href="#符号值（st-value）" class="headerlink" title="符号值（st_value）"></a>符号值（st_value）</h5><p>每个符号都有一个对应的值，如果符号是一个函数或者变量的定义，那么符号的值就是这个函数或者变量的地址，更准确地说应该分成下面几种情况区别对待：</p>
<ul>
<li>在目标文件中，如果符号不是”COMMON“类型的。st_value表示该符号在段中的偏移。即符号所对应的函数或者变量位于 st_shndx 指定的段，偏移 st_value 的位置。这也是目标文件中定义全局变量的符号最常见的情况</li>
<li>如果符号是”COMMON“类型的。st_value表示该符号的对齐属性</li>
<li>在可执行文件中，st_value表示符号的虚拟地址</li>
</ul>
<h5 id="符号类型和绑定信息（st-info）"><a href="#符号类型和绑定信息（st-info）" class="headerlink" title="符号类型和绑定信息（st_info）"></a>符号类型和绑定信息（st_info）</h5><p>该字段低 4 位表示符号的类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏定义名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>STB_LOCAL</td>
<td>0</td>
<td>局部符号，对目标文件外的编译单位不可见</td>
</tr>
<tr>
<td>STB_GLOBAL</td>
<td>1</td>
<td>全局符号，对外部可见</td>
</tr>
<tr>
<td>STB_WEAK</td>
<td>2</td>
<td>弱符号</td>
</tr>
</tbody>
</table>
</div>
<p>高 28 位表示符号的绑定信息：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏定义名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>STB_NOTYPE</td>
<td>0</td>
<td>位置类型符号</td>
</tr>
<tr>
<td>STB_OBJECT</td>
<td>1</td>
<td>数据对象，如变量、数组</td>
</tr>
<tr>
<td>STB_FUNC</td>
<td>2</td>
<td>函数或者可执行代码</td>
</tr>
<tr>
<td>STB_SECTION</td>
<td>3</td>
<td>该符号是一个段</td>
</tr>
<tr>
<td>STB_FILE</td>
<td>4</td>
<td>一般是该目标文件所对应的源文件名</td>
</tr>
</tbody>
</table>
</div>
<h5 id="符号所在段（st-shndx）"><a href="#符号所在段（st-shndx）" class="headerlink" title="符号所在段（st_shndx）"></a>符号所在段（st_shndx）</h5><p>如果符号定义在本目标文件中，那这个成员表示符号所在的段在段表中的下标；如果不在本目标文件中，或者一些特殊符号 st_shndx 的值有些特殊：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏定义名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHN_ABS</td>
<td>0xFFF1</td>
<td>表示该符号包含一个绝对值。如文件名的符号就是此类型</td>
</tr>
<tr>
<td>SHN_COMMON</td>
<td>0xFFF2</td>
<td>表示该符号是一个”COMMON“块类型的符号。一般来说未初始化的全局符号定义就是该类型</td>
</tr>
<tr>
<td>SHN_UNDEF</td>
<td>0</td>
<td>表示该符号未定义。这个符号表示该符号在本目标文件被引用，但是定义在其他目标文件中</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-5-2-特殊符号"><a href="#3-5-2-特殊符号" class="headerlink" title="3.5.2 特殊符号"></a>3.5.2 特殊符号</h4><p>  在用 ld作为链接器来链接产生可执行文件时，它会生成一些特殊的符号，这些符号并没有在源代码中定义，但是可以直接引用。一些典型的特殊符号如下：</p>
<ul>
<li><code>__FILE__</code> 编译单元对应的文件名</li>
<li><p><code>__FUNCTION__</code> 符号所的函数</p>
</li>
<li><p><code>__executable_start</code> 程序起始地址</p>
</li>
<li><code>_end</code> 程序结束地址</li>
</ul>
<h4 id="3-5-3-符号修饰与函数签名"><a href="#3-5-3-符号修饰与函数签名" class="headerlink" title="3.5.3 符号修饰与函数签名"></a>3.5.3 符号修饰与函数签名</h4><p>在 C 语言之前已具备很多用汇编实现的程序库，这些库的符号名和对应的函数/变量名是一样的。为了避免名字冲突，Unix C 的编译器规定，C 语言源代码文件中的所有全局的变量和函数经过编译以后，相对应的符号名前加上下划线”_“，这个办法在当时解决了大部分的符号名冲突的问题。</p>
<p>到后来 C++在设计时就考虑到了这一点，引入了命名空间特性，才彻底解决符号名冲突的问题。一组用来确定函数唯一性的关键信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息称之为函数签名( Function Signature)。函数签名用于识别不同的函数，C++使用特定的名称修饰方法，使得每个函数签名对应唯一一个修饰后的名称。</p>
<p>生成函数签名以及根据函数签名生成对应的名称的方法可能每个编译器的实现都不一样，导致不同厂家的编译器产生的库不能相互链接，这也是 C++二进制难以兼容的原因之一。</p>
<h4 id="3-5-4-extern-“C”"><a href="#3-5-4-extern-“C”" class="headerlink" title="3.5.4 extern “C”"></a>3.5.4 extern “C”</h4><p>有时C++要和 C 兼容，C++有一个用来声明或定义一个 C 的符号的<code>extern &quot;C&quot;</code>关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"c"</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> var;    <span class="comment">//多行形式</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"c"</span> <span class="keyword">int</span> var;  <span class="comment">//单行形式</span></span><br></pre></td></tr></table></figure>
<p>C++编译器会将在<code>extern &quot;C&quot;</code>的大括号内部的代码当做 C 语言代码来处理，此时 C++的名称修饰机制就不会起作用。</p>
<h4 id="3-5-5-弱符号与强符号"><a href="#3-5-5-弱符号与强符号" class="headerlink" title="3.5.5 弱符号与强符号"></a>3.5.5 弱符号与强符号</h4><p>强弱符号是用来处理同一个符号在不同模块被重复定义的而出现的。对于 C / C++ 编译器来说，函数和以及初始化的全局变量是强符号，未初始化的全局变量是弱符号。不过强弱符号也可以用特定的修饰关键字单独指定。链接器会按照下列规则处理与选择被多次定义的全局符号：</p>
<ul>
<li>规则1：不允许强符号被多次定义；如果有多次重复定义，则链接器会报错</li>
<li>规则2：如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号</li>
<li>规则3：如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的个。比如目标文件A定义全局变量global为int型，占4个字节；目标文件B定义global为double型，占8个字节，那么目标文件A和B链接后，符号global占8个字节(尽量不要使用多个不同类型的弱符号，否则容易导致很难发现的程序错误)</li>
</ul>
<h5 id="强引用和弱引用"><a href="#强引用和弱引用" class="headerlink" title="强引用和弱引用"></a>强引用和弱引用</h5><p>目前我们所看到的对外部目标文件的符号引用在目标文件被最终链接成可执行文件时，它们须要被正确决议，如果没有找到该符号的定义，链接器就会报符号未定义错误，这种被称为强引用。</p>
<p>与之相对应还有一种弱引用，在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器对于该引用不报错。链接器处理强引用和弱引用的过程几乎一样，只是对于未定义的弱引用，链接器不认为它是一个错误。一般对于未定义的弱引用，链接器默认其为0，或者是一个特殊的值，以便于程序代码能够识别。</p>
<p>这种弱符号和弱引用对于库来说十分有用，比如库中定义的弱符号可以被用户定义的强符号所覆盖，从而使得程序可以使用自定义版本的库函数；或者程序可以对某些扩展功能模块的引用定义为弱引用，当我们将扩展模块与程序链接在一起时，功能模块就可以正常使用；如果我们去掉了某些功能模块，那么程序也可以正常链接，只是缺少了相应的功能，这使得程序的功能更加容易裁剪和组合。</p>
<h4 id="3-5-6-调试信息"><a href="#3-5-6-调试信息" class="headerlink" title="3.5.6 调试信息"></a>3.5.6 调试信息</h4><p>目标文件里面还有可能保存的是调试信息。几乎所有现代的编译器都支持源代码级别的调试，比如我们可以在函数里面设置断点，可以监视变量变化，可以单步行进等，前提是编译器必须提前将源代码与目标代码之间的关系保存下来，比如目标代码中的地址对应源代码中的哪行、函数和变量的类型、结构体的定义、字符串保存到目标文件里面。</p>
<p>现在的ELF文件采用一个叫DWARF（Debug With Arbitrary Record Format）的标准的调试信息格式来保存调试信息。值得注意的是，调试信息在目标文件中一般占据很大的空间，有时候甚至比代码和数据本身大好几倍，所以当代码完成开发时，往往要用 release 模式编译，把调试信息去掉。</p>
<h2 id="4-静态链接"><a href="#4-静态链接" class="headerlink" title="4 静态链接"></a>4 静态链接</h2><h3 id="4-1-空间与地址分配"><a href="#4-1-空间与地址分配" class="headerlink" title="4.1 空间与地址分配"></a>4.1 空间与地址分配</h3><p>如两个静态文件 A 和 B 链接成 AB，链接器会采取”合并同类项“的方式把两个文件相同的段合并起来，如 A 的代码段和 B 的代码段合在一起，形成一个新的代码段。最后文件 AB 的大小是根据 A 和 B 的所有段的大小来确定的。</p>
<p>合并的过程一般是两步：</p>
<ol>
<li>扫描全部输入文件，获得它们各个段的长度，并把所有符号以及符号引用收集起来，形成全局符号表</li>
<li>用第 1 步获得到的信息，进行符号解析和重定位，调整文件中的各种引用地址</li>
</ol>
<h3 id="4-2-符号解析与重定位"><a href="#4-2-符号解析与重定位" class="headerlink" title="4.2 符号解析与重定位"></a>4.2 符号解析与重定位</h3><h4 id="4-2-1-重定位"><a href="#4-2-1-重定位" class="headerlink" title="4.2.1 重定位"></a>4.2.1 重定位</h4><p>符号在段内的位置是相对不变的，而且这个相对位置在编译时已经确定，所以只要段的起始地址确定，符号地址也随之确定。所以在多个段合并后，每个段的起始地址也确定下来，此时段内的符号地址能具体地计算出来。</p>
<p>完成空间和地址的分配后，链接器就进入了符号解析和重定位的步骤，这也是静态链接的核心内容。</p>
<h4 id="4-2-2-重定位表"><a href="#4-2-2-重定位表" class="headerlink" title="4.2.2 重定位表"></a>4.2.2 重定位表</h4><p>重定位的工作中最重要的一项数据结构就是重定位表，它用来保存如何修改相应的段里的内容的信息。每个要被重定位的地方叫一个重定位入口（Relocation Entry），重定位入口的偏移（Offset）表示该入口在要被重定位的段中的位置。</p>
<p>对于 32 位的 x86 系列处理器来说，重定位表的结构是一个 Elf32_Rel 结构的数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  Elf32_Addr r_offset;</span><br><span class="line">  Elf32_Word r_info;</span><br><span class="line">&#125; Elf32_Rel</span><br></pre></td></tr></table></figure>
<p>具体的字段解释如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>r_offset</td>
<td>对于可重定位文件来说，这个值是该重定位入口所要修正的位置的第一个字节相对于段起始的偏移；<br/>对于可执行文件或共享对象文件来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址</td>
</tr>
<tr>
<td>r_info</td>
<td>这个成员的低8位表示重定位入口的类型，高24位表示重定位入口的符号在符号表中的下标。对于可执行文件和共享目标文件来说，它们的重定位入口是动态链接类型的</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-2-3-符号解析"><a href="#4-2-3-符号解析" class="headerlink" title="4.2.3 符号解析"></a>4.2.3 符号解析</h4><p>平时在编写程序的时候常遇到的问题就是，链接时符号未定义。导致这个问题的原因很多，最常见的一般都是链接时缺少了某个库，或者输入目标文件路径不正确或符号的声明与定义不一样。</p>
<p>通过前面指令重定位的介绍，现在可以更加深层次地理解为什么缺少符号的定义会导致链接错误。其实重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。重定位的过程中，每个重定位的入口都是对一个符号的引用，那么当链接器须要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。</p>
<p>在链接器扫描完所有的输入目标文件之后，理论上所有这些未定义的符号都应该能够在全局符号表中找到，否则链接器就报符号未定义错误。</p>
<h4 id="4-2-4-指令修正方式"><a href="#4-2-4-指令修正方式" class="headerlink" title="4.2.4 指令修正方式"></a>4.2.4 指令修正方式</h4><p>32 位的 x86 处理器支持的寻址方式特别多，很多是从 16 位开始一直兼容上来的。到现在已经用的不多，现在主要的还是以下两种：</p>
<ul>
<li>绝对近址32位寻址</li>
<li>相对近址32位寻址</li>
</ul>
<p>前面说到的 r_info 字段的 低 8 位表示重定位入口类型，具体如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏定义</th>
<th>值</th>
<th>重定位修正方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>R_386_32</td>
<td>1</td>
<td>绝对寻址修正 S + A</td>
</tr>
<tr>
<td>R_386_PC32</td>
<td>2</td>
<td>相对寻址修正 S + A - P</td>
</tr>
</tbody>
</table>
</div>
<p>A = 保存在被修正位置的值，这个位置由r_offset字段查询得到</p>
<p>S = 符号的实际地址，由 r_info 的高 24 位指定的符号的实际地址</p>
<p>P = 被修正的位置的第一个字节的虚拟地址</p>
<h5 id="绝对寻址修正"><a href="#绝对寻址修正" class="headerlink" title="绝对寻址修正"></a>绝对寻址修正</h5><p>一般进行绝对寻址修正时，就是直接把符号的地址赋值到引用该符号的地方。所以一般引用处的 A 值都是 0</p>
<h5 id="相对寻址修正"><a href="#相对寻址修正" class="headerlink" title="相对寻址修正"></a>相对寻址修正</h5><p>相对寻址需要计算符号引用的地方和符号相距的距离，所以上述的公式可以先简化成 S - P，这里 S 就是符号地址，P 就是引用符号的地址。</p>
<p>x86 执行相对近调用指令时，后面参数的偏移量的计算公式是：目的地地址 - 源地址 - call指令长度。是不是看着很熟悉。和上面的 S - P 公式有点像了，这里就知道为什么要加上 A了。A 的值就是call 指令的长度，由编译器在编译时计算得出，在32位x86的CPU上A的值一般为-4</p>
<h3 id="4-4-C-相关问题"><a href="#4-4-C-相关问题" class="headerlink" title="4.4 C++相关问题"></a>4.4 C++相关问题</h3><ul>
<li>C++的模板、虚函数表、外部内联函数可能在各种实例中出现，会形成大量冗余代码。所以C++的编译器把每个模板的代码放在一个单独的段里，重复的模板只会产生一个段，通过这样的方法来去除冗余</li>
<li>全局构造与析构代码放在.init和.finit 段，确保能在main之前前执行构造方法，在main之后执行析构方法</li>
<li>C++的模板、多继承、命名空间等诸多特性导致符号的生成规则因素过多，ABI的兼容性难度很大</li>
</ul>
<h3 id="4-6-链接过程控制"><a href="#4-6-链接过程控制" class="headerlink" title="4.6 链接过程控制"></a>4.6 链接过程控制</h3><ul>
<li>用命令行参数</li>
<li>把链接指令放在目标文件里面</li>
<li>用链接脚本控制链接过程</li>
</ul>
<h3 id="4-7-BFD-库"><a href="#4-7-BFD-库" class="headerlink" title="4.7 BFD 库"></a>4.7 BFD 库</h3><p>不同平台的目标文件格式千差万别，导致编译器和链接器很难处理不同平台的目标文件，特别是还具有跨平台特性的编译器来说，更是头疼。</p>
<p>所以业界出现了BFD（Binary File Descriptor library）项目，它能把目标文件抽象成一个统一的模型。</p>
]]></content>
      
        <categories>
            
            <category> CS基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[pod install 特别慢的终极解决方案😋]]></title>
      <url>http://petpwiuta.github.io/2019/04/03/pod%2520install%2520%25E7%2589%25B9%25E5%2588%25AB%25E6%2585%25A2%25E7%259A%2584%25E7%25BB%2588%25E6%259E%2581%25E8%25A7%25A3%25E5%2586%25B3%25E6%2596%25B9%25E6%25A1%2588/</url>
      <content type="html"><![CDATA[<h2 id="pod-install-特别慢的终极解决方案😋"><a href="#pod-install-特别慢的终极解决方案😋" class="headerlink" title="pod install 特别慢的终极解决方案😋"></a>pod install 特别慢的终极解决方案😋</h2><p><strong>pod install 在终端更新慢</strong> 其实真正慢的并不在 <strong>pod</strong> 命令，而是在于 <strong>github</strong>访问速度慢，那么真正的解决方案就是要加快 <strong>git</strong>命令的速度。当然，加速<strong>git</strong>的方法就是开代理。</p>
<p>我使用的 <strong>shadowsocks代理</strong>，默认代理端口为<strong>1080</strong>，打开小飞机，配置好代理之后，去终端输入<strong>git</strong>配置命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1086</span><br><span class="line"><span class="meta">#</span><span class="bash"> socks5://127.0.0.1:1086 1086端口号是shadowsocks的默认设置，实际以自己的机器为准</span></span><br></pre></td></tr></table></figure>
<p>如此就从根本上解决了问题。<strong>代理前 10k/s ☹️ 代理后 600k/s</strong> 😍</p>
<p>如果要恢复/移除上面设置的 <strong>git</strong>代理，使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.https://github.com.proxy</span><br></pre></td></tr></table></figure>
<h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><ul>
<li><a href="https://blog.csdn.net/wuquan0625/article/details/47401235" target="_blank" rel="noopener">https://blog.csdn.net/wuquan0625/article/details/47401235</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[UIStackView]]></title>
      <url>http://petpwiuta.github.io/2019/04/01/UIStackView/</url>
      <content type="html"><![CDATA[<h1 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h1><p>UIStackview是一个流式布局的工具。贼好用😝😝</p>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>UIStackView可以说是Auto Layout最强有力的助手，通过它能大幅简化多个view规律性的布局逻辑。stack view所管理的view都在它的 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616232-arrangedsubviews" target="_blank" rel="noopener"><code>arrangedSubviews</code></a> 属性里。stack view会把这些view根据其在数组中的先后顺序沿着横向/纵向（取决于<a href="https://developer.apple.com/documentation/uikit/uistackview/1616223-axis" target="_blank" rel="noopener"><code>axis</code></a>属性）排列，然当具体的排列效果还和 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616233-distribution" target="_blank" rel="noopener"><code>distribution</code></a>, <a href="https://developer.apple.com/documentation/uikit/uistackview/1616243-alignment" target="_blank" rel="noopener"><code>alignment</code></a>, <a href="https://developer.apple.com/documentation/uikit/uistackview/1616225-spacing" target="_blank" rel="noopener"><code>spacing</code></a>, 等属性有关。</p>
<p><img src="/images/stackview.png" style="zoom:40%" /></p>
<p>在Storyboard中使用stack view很简单，打开控件库，选择Horizontal Stack View 或 Vertical Stack View拖到view上，再拖一些其他控件到stack view里面就行了。如果约束足够明确的话Interface Builder会根据你的内容自动调整stack view的大小。另外还有一个快速使用stack view的小技巧，就是选中一组控件以后点击Interface Builder右下角的 <strong>Embed In</strong> <img src="/images/embedin.png" style="zoom:20%" /> 按钮选择stack view就能快速用stack view把选中的控件wrap起来。</p>
<h3 id="Stack-View-和-Auto-Layout"><a href="#Stack-View-和-Auto-Layout" class="headerlink" title="Stack View 和 Auto Layout"></a>Stack View 和 Auto Layout</h3><p>stack view通过自动布局来确定所管理的view的大小和位置。<code>axis</code>决定了stack view是水平排列还是垂直排列。如果设置 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616220-islayoutmarginsrelativearrangeme" target="_blank" rel="noopener"><code>isLayoutMarginsRelativeArrangement</code></a> 属性为 <code>true</code> ，stack view会基于margin来决定view之间位置（不设置的话就是基于视图的边缘来计算）。</p>
<p><code>distribution</code>属性用来设置沿着axis方向的各个view的排列方式。当axis是<code>UILayoutConstraintAxisHorizontal</code>就是设置水平方向各个view的排列关系，当axis是<code>UILayoutConstraintAxisVertical</code>就是设置垂直方向各个view的排列关系。</p>
<p>stack view对子view进行排列时，会依次调用view的<a href="https://developer.apple.com/documentation/uikit/uiview/1622600-intrinsiccontentsize" target="_blank" rel="noopener"><code>intrinsicContentSize</code></a>属性来确定其大小。有一个例外，就是distribution设置成<a href="https://developer.apple.com/documentation/uikit/uistackview/distribution/fillequally" target="_blank" rel="noopener"><code>UIStackView.Distribution.fillEqually</code></a>时，此时stack view会尽量把所有的view拉伸成同样的长度，均匀地填充整个容器。stack view在拉伸时会尝试把其他的view拉得和最长的那个一样长。</p>
<p><code>alignment</code>属性用来设置垂直于axis方向的各个view的对齐方式。当axis是<code>UILayoutConstraintAxisHorizontal</code>就是设置垂直方向各个view的对齐关系，当axis是<code>UILayoutConstraintAxisVertical</code>就是设置水平方向各个view的对齐关系。</p>
<p>stack view对子view进行对齐时，也会依次调用view的<a href="https://developer.apple.com/documentation/uikit/uiview/1622600-intrinsiccontentsize" target="_blank" rel="noopener"><code>intrinsicContentSize</code></a>属性来确定其大小。当然也有一个例外，就是alignment设置为<a href="https://developer.apple.com/documentation/uikit/uistackview/alignment/fill" target="_blank" rel="noopener"><code>UIStackView.Alignment.fill</code></a> 时，此时stack view会尽量把所有的view拉伸成同样的高度，均匀地填充整个容器。stack view在拉伸时会尝试把其他的view拉得和最高的那个一样高。</p>
<h3 id="Stack-View的位置和大小"><a href="#Stack-View的位置和大小" class="headerlink" title="Stack View的位置和大小"></a>Stack View的位置和大小</h3><p>stack view可以根据所管理的view推导出自己的大小，但是它无法确定自己的位置。所需要明确地写出位置约束。只要指定两个的相邻边的位置stack view就能确定其自身的位置。与此同时stack view也会根据内容来自动调整自己的宽度和高度：</p>
<ul>
<li>沿着axis方向的宽度等于其管理的所有view的尺寸加上view之间的间距</li>
<li>垂直于axis方向的高度等于所管理的view中最高的那个</li>
<li>如果stack view的 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616220-islayoutmarginsrelativearrangeme" target="_blank" rel="noopener"><code>isLayoutMarginsRelativeArrangement</code></a> 属性设置为 <code>true</code>, stack view的尺寸会包含margins的大小</li>
</ul>
<p>当然，上面的这些都是默认的行为，如果不能满足要求还能直接给stack view加高度或宽度的约束。stack view会根据 <a href="https://developer.apple.com/documentation/uikit/uistackview/distribution" target="_blank" rel="noopener"><code>UIStackView.Distribution</code></a> 和 <a href="https://developer.apple.com/documentation/uikit/uistackview/alignment" target="_blank" rel="noopener"><code>UIStackView.Alignment</code></a> 等设置来调整子view的排列和对齐来满足约束条件。 </p>
<p>虽然stack view仅仅只是一个布局容器，但是它也支持基于first/last baseline的布局：</p>
<ul>
<li>horizontal方向的stack view <a href="https://developer.apple.com/documentation/uikit/uiview/1622452-forfirstbaselinelayout" target="_blank" rel="noopener"><code>forFirstBaselineLayout</code></a>和 <a href="https://developer.apple.com/documentation/uikit/uiview/1622633-forlastbaselinelayout" target="_blank" rel="noopener"><code>forLastBaselineLayout</code></a> 会返回所管理的view中最高的那个对应的属性。 如果最高的那个也是stack view的话会进行递归调用，直到返回正常结果</li>
<li>vertical方向的stack view <code>forFirstBaselineLayout</code>会返回所管理的第一个子view，<code>forLastBaselineLayout</code>会返回最后一个。同样的如果第一个/最后一个还是stack view的话也会递归式调用</li>
</ul>
<blockquote>
<p>注意</p>
<p>Baseline alignment 仅仅只能在view的frame高度等于自己的intrinsic.height时才能正常工作，换句话说就是view如果被压缩或拉伸的话baseline alignment可能就会有bug</p>
</blockquote>
<h3 id="Stack-View的常用属性"><a href="#Stack-View的常用属性" class="headerlink" title="Stack View的常用属性"></a>Stack View的常用属性</h3><p>stack view虽然是view的子类，它只负责管理其排列视图的位置和大小，本身不会被渲染出来。所以一些外观相关的属性（如<a href="https://developer.apple.com/documentation/uikit/uiview/1622591-backgroundcolor" target="_blank" rel="noopener"><code>backgroundColor</code></a>）对它没有效果，也不能重载 <a href="https://developer.apple.com/documentation/uikit/uiview/1622626-layerclass" target="_blank" rel="noopener"><code>layerClass</code></a>, <a href="https://developer.apple.com/documentation/uikit/uiview/1622529-draw" target="_blank" rel="noopener"><code>draw(_:)</code></a>等方法。</p>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616223-axis" target="_blank" rel="noopener"><code>axis</code></a> 确定了stack的方向，选项是vertically/horizontally.</li>
<li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616233-distribution" target="_blank" rel="noopener"><code>distribution</code></a> 用来设置沿着axis方向的各个view的排列方式</li>
<li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616243-alignment" target="_blank" rel="noopener"><code>alignment</code></a> 用来设置垂直与axis方向的各个view的对齐方式</li>
<li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616225-spacing" target="_blank" rel="noopener"><code>spacing</code></a> view之间的最小间距</li>
<li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616224-isbaselinerelativearrangement" target="_blank" rel="noopener"><code>isBaselineRelativeArrangement</code></a> 当axis设置为垂直方向时才有用。垂直方向的view是否用基于baseline排列，这个属性在排列一些文本控件时很管用</li>
<li><a href="https://developer.apple.com/documentation/uikit/uistackview/1616220-islayoutmarginsrelativearrangeme" target="_blank" rel="noopener"><code>isLayoutMarginsRelativeArrangement</code></a> 是否基于margin进行排列</li>
</ul>
<h3 id="Stack-View的Arranged-Views和Subviews"><a href="#Stack-View的Arranged-Views和Subviews" class="headerlink" title="Stack View的Arranged Views和Subviews"></a>Stack View的Arranged Views和Subviews</h3><p>stack view保证 <a href="https://developer.apple.com/documentation/uikit/uistackview/1616232-arrangedsubviews" target="_blank" rel="noopener"><code>arrangedSubviews</code></a> 属性一直是其 <a href="https://developer.apple.com/documentation/uikit/uiview/1622614-subviews" target="_blank" rel="noopener"><code>subviews</code></a> 的子集. 具体规则如下:</p>
<ul>
<li><p>当stack view添加view到<code>arrangedSubviews</code> 时, 它也会把view添加到自己的subviews数组里面（如果已经添加过就不重复添加）</p>
</li>
<li><p>当一个view从stack view的subview中移除时，它也会从 <code>arrangedSubviews</code> 中移除</p>
</li>
<li><p>当一个view从stack view的 <code>arrangedSubviews</code> 中移除时，这个view<font color="red"> <strong>并不会</strong></font>从stack view的<code>arrangedSubviews</code>中移除</p>
</li>
</ul>
<p>  虽然<code>arrangedSubviews</code>属性一直是其<code>subviews</code>的子集，但这两个数组内的元素顺序并不一定是一致的。</p>
<ul>
<li><code>arrangedSubviews</code>中的顺序决定了view在容器中出现的顺序。在水平方向的stack view中，view是沿着阅读方向（绝大部分语言是从左到右，阿拉伯语是从右到左。不过这个不取决于系统语言设置，取决于布局是用left/right还是leading/trailing）排列的。index小的在前，index大的在后</li>
<li>而<code>subviews</code> 中的顺序决定子view的Z-order。Z-order高的会把低的view盖住</li>
</ul>
<h3 id="Stack-View-动态内容"><a href="#Stack-View-动态内容" class="headerlink" title="Stack View 动态内容"></a>Stack View 动态内容</h3><p>当对stack view<a href="https://developer.apple.com/documentation/uikit/uistackview/1616232-arrangedsubviews" target="_blank" rel="noopener"><code>arrangedSubviews</code></a> 进行添加/插入/删除，以及对它所管理的子view的属性进行修改时，stack view的内容会自动更新。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Appears to remove the first arranged view from the stack.</span></span><br><span class="line"><span class="comment">// The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout.</span></span><br><span class="line"><span class="keyword">let</span> firstView = stackView.arrangedSubviews[<span class="number">0</span>]</span><br><span class="line">firstView.isHidden = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>同样的，如果修改stack view的属性，它的内容也会根据属性的变化而动态地调整。比如设置<a href="https://developer.apple.com/documentation/uikit/uistackview/1616223-axis" target="_blank" rel="noopener"><code>axis</code></a>动态地改变stack view的方向。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Toggle between a vertical and horizontal stack</span></span><br><span class="line"><span class="keyword">if</span> stackView.axis == .<span class="type">Horizontal</span> &#123;</span><br><span class="line">    stackView.axis = .<span class="type">Vertical</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    stackView.axis = .<span class="type">Horizontal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在动画block里面调整子view的属性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animates removing the first item in the stack.</span></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.25</span>) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> firstView = stackView.arrangedSubviews[<span class="number">0</span>]</span><br><span class="line">    firstView.isHidden = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Jenkins进行iOS项目自动化发布]]></title>
      <url>http://petpwiuta.github.io/2019/01/16/%25E4%25BD%25BF%25E7%2594%25A8Jenkins%25E8%25BF%259B%25E8%25A1%258CiOS%25E9%25A1%25B9%25E7%259B%25AE%25E8%2587%25AA%25E5%258A%25A8%25E5%258C%2596%25E5%258F%2591%25E5%25B8%2583/</url>
      <content type="html"><![CDATA[<h3 id="使用Jenkins进行iOS项目自动化发布"><a href="#使用Jenkins进行iOS项目自动化发布" class="headerlink" title="使用Jenkins进行iOS项目自动化发布"></a>使用Jenkins进行iOS项目自动化发布</h3><p>前段时间把iOS发布逻辑迁移到fastlane平台，现在发布调一下fastlane脚本就好，对开发人员极度友好。不过后来发现虽然开发人员用得爽了，不过还是要被测试妹子催着打包，于是想釜底抽薪，把这个功能做得更彻底一点，直接让测试妹子自己来打包，这样就把iOS开发同学彻底解放了～</p>
<p>公司内网已经部署了一台linux系统的jenkins服务器，上面集成了一些后端和前端的发布逻辑，所以直接添加一个iOS项目的发布流程就行。Xcode环境只能跑在Mac OS上，所以iOS项目的发布流程势必要做远程服务。</p>
<p>在调研的时候打算在Mac OS上启一个http server，自己写相关的逻辑。后来发现jenkins有远程job互调用的功能，所以方案就变成在Mac OS上也部署一套jenkins，暴露出一些打包服务，然后在公司的jenkins中调用。因为有两套jenkins环境的配置（提供服务的和使用服务的），姑且称之为调用端和执行端。下面就来简单说一下这两部分的具体配置。</p>
<h4 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h4><p><img src="/images/jenkins-ios/c-1.png" alt="c-1"></p>
<h4 id="执行端"><a href="#执行端" class="headerlink" title="执行端"></a>执行端</h4><p>执行端主要就是提供一个http服务，用http协议来触发构建任务。下面是具体步骤：</p>
<ol>
<li>在jenkins中新建一个任务，这里选“自由风格的软件项目”</li>
</ol>
<p><img src="/images/jenkins-ios/a-0.png" alt="a-0"></p>
<ol>
<li>然后在General中勾选“参数化构建过程”，这里因为需要接收主调方发送的构建参数，所以要选这一项。因为要通知调用方执行结果，所以构建参数里增加“callbackurl”</li>
</ol>
<p><img src="/images/jenkins-ios/a-1.png" alt="a-1"></p>
<ol>
<li>接着在构建触发器中勾选“触发远程构建”，并填写身份证令牌。这里的身份证令牌和用户无关，仅仅只是这个job的api令牌，这里可以随便填一个，只要不太容易被猜到就行</li>
</ol>
<p><img src="/images/jenkins-ios/a-2.png" alt="a-2"></p>
<ol>
<li>最后在构建中增加“执行shell”选项。这里可以写执行任务的逻辑，我这儿就是简单的切换到工程目录，再调用fastlane打包，结束后回调完成的url</li>
</ol>
<p><img src="/images/jenkins-ios/a-3.png" alt="a-3"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/projectPath          <span class="comment">#项目路径</span></span><br><span class="line">git checkout branch       <span class="comment">#切换到指定分支</span></span><br><span class="line">fastlane inhousepackage   <span class="comment">#调用fastlane完成打包</span></span><br><span class="line">curl  <span class="variable">$&#123;callbackurl&#125;</span>      <span class="comment">#调用回调url，通知调用方任务完成</span></span><br></pre></td></tr></table></figure>
<ol>
<li>到了这一步就完成了项目配置，不过因为用户认证相关的设置还没有完成，所以这个任务还不能被远程触发。点击右上角用户名可以进入到用户设置页面，点击设置，在“API Token”中添加一个token，使用这个token和用户名就能在其他机器上触发任务</li>
</ol>
<p><img src="/images/jenkins-ios/a-5.png" alt="a-5"></p>
<ol>
<li><p>完成上面这些设置后，会得到下列信息。主调方有了这些信息就能触发远程构建</p>
<blockquote>
<ul>
<li><p>用户名(userName)</p>
</li>
<li><p>用户令牌(userToken)</p>
</li>
<li>任务令牌(jobToken)</li>
<li>执行任务的机器ip地址，jenkins服务端口号码</li>
<li>jenkins任务名字(jobName)</li>
<li>回调url，这个非必须，不过不传的话无法知道任务是否已经结束(callbackurl)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#最后用上面这些信息拼接成类似下面这样的URL，通过http协议访问就能触发这台机器上的远程任务</span></span><br><span class="line">jobTriggerURL = <span class="string">"http://<span class="variable">$&#123;userName&#125;</span>:<span class="variable">$&#123;userToken&#125;</span>@<span class="variable">$&#123;jobServerIPAndPort&#125;</span>/job/<span class="variable">$&#123;jobName&#125;</span>/buildWithParameters?token=<span class="variable">$&#123;jobToken&#125;</span>&amp;callbackurl=<span class="variable">$&#123;callbackurl&#125;</span>"</span></span><br><span class="line">curl jobTriggerURL</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<h4 id="调用端"><a href="#调用端" class="headerlink" title="调用端"></a>调用端</h4><p>当执行端设置好以后，调用端的设置就比较简单了。</p>
<ol>
<li>在jenkins中新建一个任务，这里选“流水线”，因为调用端的逻辑用到了一些pipeline插件，而且还有一些逻辑要处理，用流水线可以实现更精确控制</li>
</ol>
<p><img src="/images/jenkins-ios/b-1.png" alt="b-1"></p>
<ol>
<li>在“高级项目选项”中的“流水线”里写下下面的逻辑：</li>
</ol>
<p><img src="/images/jenkins-ios/b-2.png" alt="b-2"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">stage (<span class="string">"Wait remote iOS package job finish."</span>) &#123;</span><br><span class="line">    node &#123;</span><br><span class="line">        hook = registerWebhook()   <span class="comment">#这里使用了Webhook Step Plugin插件</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        ip = sh (</span><br><span class="line">            script: <span class="string">"ifconfig en0 | sed -n 's/[\\s\\t]*inet \\([0-9\\.]*\\) .*/\\1/p' | tr -d '\\t\\n'"</span>,</span><br><span class="line">            returnStdout: <span class="literal">true</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        url = sh (</span><br><span class="line">            script: <span class="string">"echo \"<span class="variable">$&#123;hook.getURL()&#125;</span>\" | sed -n 's/localhost:[0-9]*/<span class="variable">$&#123;ip&#125;</span>:8080/p'"</span>,</span><br><span class="line">            returnStdout: <span class="literal">true</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#$&#123;hook.getURL()&#125;获取的回调url中host部分是localhost，所以需要用本机ip替换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">#这里的所有信息都是在执行实际任务的机器上获取的，具体细节看“执行端”部分</span></span><br><span class="line">        user =  <span class="string">"username"</span>  <span class="comment">#用户名字</span></span><br><span class="line">        userToken = <span class="string">""</span>      <span class="comment">#用户认证token</span></span><br><span class="line">        jobToken = <span class="string">"triggertoken123"</span>  <span class="comment">#任务token</span></span><br><span class="line">        jobServerIP = <span class="string">"172.20.24.122:8080"</span> </span><br><span class="line">        jobName = <span class="string">"iOS"</span></span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        <span class="comment">#获取到上面的这些信息以后拼接成下面这个样式的url，发送get请求就能触发远程job</span></span><br><span class="line">        <span class="comment">#因为有些参数包含特殊字符，所以需要加上--data-urlencode来进行转义</span></span><br><span class="line">        jobTriggerURL = <span class="string">"http://<span class="variable">$&#123;user&#125;</span>:<span class="variable">$&#123;userToken&#125;</span>@<span class="variable">$&#123;jobServerIP&#125;</span>/job/<span class="variable">$&#123;jobName&#125;</span>/buildWithParameters"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"job url:<span class="variable">$&#123;jobTriggerURL&#125;</span>"</span></span><br><span class="line">        sh(<span class="string">"curl --data-urlencode \"token=<span class="variable">$&#123;jobToken&#125;</span>\" --data-urlencode \"callbackurl=<span class="variable">$&#123;url&#125;</span>\" <span class="variable">$&#123;jobTriggerURL&#125;</span>"</span>)</span><br><span class="line">        </span><br><span class="line">   </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Webhook called with data: <span class="variable">$&#123;url&#125;</span>"</span></span><br><span class="line">        data = waitForWebhook hook</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>脚本的主要逻辑是调用远程job，然后等待远程任务发送回调请求。这里用到了<a href="https://wiki.jenkins.io/display/JENKINS/Webhook+Step+Plugin" target="_blank" rel="noopener">Webhook Step Plugin</a>插件，它主要作用是获取一个回调URL，并挂起当前执行的脚本，直到回调url被调用以后再继续执行。</p>
<p>经过上面的配置后就能在公司jenkins上进行iOS项目自动化发布了。如果jenkins是在外网，则会麻烦一些，需要连vpn或者在NAT上做一个端口映射才行。</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[中国互联网拓扑结构]]></title>
      <url>http://petpwiuta.github.io/2018/12/26/%25E4%25B8%25AD%25E5%259B%25BD%25E4%25BA%2592%25E8%2581%2594%25E7%25BD%2591%25E6%258B%2593%25E6%2589%2591%25E7%25BB%2593%25E6%259E%2584/</url>
      <content type="html"><![CDATA[<h2 id="中国互联网拓扑结构"><a href="#中国互联网拓扑结构" class="headerlink" title="中国互联网拓扑结构"></a>中国互联网拓扑结构</h2><h3 id="1-中国7大骨干网运营商"><a href="#1-中国7大骨干网运营商" class="headerlink" title="1 中国7大骨干网运营商"></a>1 中国7大骨干网运营商</h3><p>目前中国有七家骨干网运营商，分别是中国电信、中国联通、中国移动、中国教育和科研计算机网、中国科技网 、中国国际电子商务网和中国长城互联网。</p>
<ul>
<li>中国电信，拥有2张全国骨干网：中国公用计算机互联网（CHINANET / CHINA163）和中国电信下一代承载网（ChinaNet Next Carrying Network，简称CN2）。</li>
<li>中国联通，拥有2张全国骨干网：中国网通互联网（CHINA169）和旧中国网通互联网（CNCNET）。原中国金桥信息网(CHINAGBN)由吉通公司负责建设、运营和管理，2002年5月16日，吉通公司并入中国网通；2009年中国网通与中国联通合并。2009年工业和信息化部同意原中国网通互联网骨干网（CHINA169）和原中国联通互联网骨干网（UNINET）实施网络融合，并将 UNINET 作为下级网络接入 CHINA169。中国网通互联网（CHINA169）是从中国公用计算机互联网（CHINA163）拆分而来，但中国网通从中国电信拆分前已经拥有一张独立的网络（CNCNET），自治域为AS9929，现在也称作中国联通工业互联网（China Unicom Industrial Internet，简称CUII），定位为主要提供国际和国内跨地市MPLS VPN和大客户互联网专线任务的承载，常用于企业宽带和IDC，已经极少见于家用宽带。</li>
<li>中国移动，拥有1张全国骨干网：中国移动互联网（CMNET），于2000年1月组建。</li>
<li>中国教育和科研计算机网（CERNET）：始建于1994年，由中国教育部投资并管理，是中国最大的公益性、学术性计算机互联网络，网络总控中心设在清华大学。</li>
<li>中国科技网（CSTNET）：中国科技网的前身是中国科学院于1989年8月建立的中关村教育与科研示范网络（NCFC）。1994年4月，NCFC与美国NSFNET直接互联，实现了中国与国际互联网的首次全功能网络连接。1996年2月，以NCFC为基础发展起来的中国科学院院网（CASNET）更名为中国科技网（CSTNET）。</li>
<li>中国国际经济贸易互联网（CIETNET）：全国外贸系统企事业单位专用，由中国国际电子商务中心负责组建、运行和维护，不设国际出口带宽。</li>
<li>中国长城互联网（CGWNET）：军队专用，不设国际出口带宽。</li>
</ul>
<h3 id="2-骨干网的基本技术概念"><a href="#2-骨干网的基本技术概念" class="headerlink" title="2 骨干网的基本技术概念"></a>2 骨干网的基本技术概念</h3><ul>
<li>骨干网（backbone  network）：核心节点互相连接组成的网络，保障核心节间信息转发，不负责直接接入用户</li>
<li>支撑网：监管业务网的网络。类似于管理磁盘的软件本身就要占用一部分磁盘空间，管理网络的系统也需要使用一部分网络资源。</li>
<li>接入网（Access Network）：指骨干网络到用户终端之间的网络。因为终端网络介质较多，所以网络类型也很多，如有线的光纤，双绞线；无线的wifi，蜂窝移动网，卫星等</li>
</ul>
<h3 id="3-中国电信网络拓扑结构"><a href="#3-中国电信网络拓扑结构" class="headerlink" title="3 中国电信网络拓扑结构"></a>3 中国电信网络拓扑结构</h3><h4 id="中国电信163"><a href="#中国电信163" class="headerlink" title="中国电信163"></a>中国电信163</h4><p>163网络分为骨干网和城域网两层结构。骨干网层面，又可分为三层：核心层、汇接层和接入层，另外核心层还连接有国际出入口层、互联互通层。骨干网分为3大片区：北京、上海、广州。</p>
<p>骨干网3大片区又细分为9个大区：<br>北京片区：北京大区、天津大区、西安大区<br>上海片区：上海大区、南京大区、杭州大区<br>广州片区：广州大区、武汉大区、成都大区</p>
<ul>
<li><p>核心层：<br>  超级核心：北京、上海、广州<br>  普通核心：天津、西安、南京、杭州、武汉、成都<br>  核心节点间Full-Mesh连接<br>  负责各省份间信息交互，超级核心还负责与国内其他运营商、国际访问的流量交互</p>
</li>
<li><p>汇接层：<br>  北方省份落地设备，南方省份省网汇聚设备<br>  各省份双方向上联，分别连接到一个超级核心和一个普通核心节点，部分省份三方向上联</p>
</li>
</ul>
<ul>
<li>接入层：<br>未完成扁平化的省份还有地市接入层设备，用于接入省内城域网</li>
<li><p>中国电信ChinaNet网络骨干拓扑<br><img src="/images/networking-structure/Picture1.png" alt="中国电信ChinaNet网络骨干拓扑"></p>
</li>
<li><p>中国电信ChinaNet网络省内拓扑结构<br><img src="/images/networking-structure/Picture2.png" alt="中国电信ChinaNet网络省内拓扑结构"></p>
</li>
<li>国内互联互通层：<br>在北京、上海、广州三个超级核心设有互联互通设备（E路由器） ，互联互通设备（E路由器）直接连接在超级核心C路由器</li>
<li>ChinaNet通过互联互通设备与部分其它运营商互联和流量互访<br><img src="/images/networking-structure/Picture3.png" alt="ChinaNet通过互联互通设备与部分其它运营商互联和流量互访"></li>
<li>ChinaNet－国际网间互联拓扑<br><img src="/images/networking-structure/Picture4.png" alt="ChinaNet－国际网间互联拓扑"></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E9%AA%A8%E5%B9%B2%E7%BD%91%E8%BF%90%E8%90%A5%E5%95%86" target="_blank" rel="noopener">中国骨干网运营商</a></li>
<li><a href="https://wenku.baidu.com/view/4e3ab12681c758f5f71f67b9.html?from=search" target="_blank" rel="noopener">中国电信运营商骨干网络架构</a></li>
<li><a href="http://blog.51cto.com/juispan/2095304" target="_blank" rel="noopener">中国运营商网络分析</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> CS基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Symbolicatecrash符号化crash日志]]></title>
      <url>http://petpwiuta.github.io/2018/12/26/%25E4%25BD%25BF%25E7%2594%25A8Symbolicatecrash%25E7%25AC%25A6%25E5%258F%25B7%25E5%258C%2596crash%25E6%2597%25A5%25E5%25BF%2597/</url>
      <content type="html"><![CDATA[<h2 id="使用Symbolicatecrash符号化crash日志"><a href="#使用Symbolicatecrash符号化crash日志" class="headerlink" title="使用Symbolicatecrash符号化crash日志"></a>使用Symbolicatecrash符号化crash日志</h2><ol>
<li><p>准备工作<br>解析crash日志需要3个文件：</p>
<ul>
<li><code>.crash</code>文件</li>
<li><code>.dSYM</code>文件</li>
<li><code>symbolicatecrash</code>工具</li>
</ul>
</li>
<li><p>配置symbolicatecrash<br>Xcode的symbolicatecrash路径如下：<br><code>/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash</code><br>如果在该路径下找不到工具的话可能是因为不同版本这个工具的位置不一样，可以用下面的命令搜索：<br><code>find /Applications/Xcode.app -name symbolicatecrash -type f</code></p>
<p> 到找symbolicatecrash以后还需要倒入环境变量才能使用，不然会报</p>
<blockquote>
<p>Error: “DEVELOPER_DIR” is not defined at ./symbolicatecrash<br>的错误</p>
</blockquote>
<p> 用<code>export DEVELOPER_DIR=&quot;/Applications/Xcode.app/Contents/Developer&quot;</code>就能设置环境变量，如果报错可能是安装了多个xcode，xcod的名字被修改了，如果是这样执行<code>xcode-select --print-path</code> 找到DEVELOPER_DIR，然后再执行上面的命令</p>
<p> 当然，设置环境变量也有一劳永逸的办法，就是把环境变量直接加到<code>~/.bash_profile</code>中，如果是zsh的话就是<code>~/.zshrc</code>。打开配置文件，在末尾添加</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="type">Add</span> environment variable <span class="type">DEVELOPER_DIR</span>  </span><br><span class="line">export <span class="type">DEVELOPER_DIR</span>=/<span class="type">Applications</span>/<span class="type">Xcode</span>.app/<span class="type">Contents</span>/<span class="type">Developer</span></span><br></pre></td></tr></table></figure>
<p>然后重启终端或者执行source命令刷新</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="type">Add</span> environment variable <span class="type">DEVELOPER_DIR</span>  </span><br><span class="line">source ~/.bash_profile</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>符号化crash文件<br>到这一步就是调用symbolicatecrash工具进行符号化了，代码如下：<br><code>symbolicatecrash [.crash 文件] [.dSYM文件] &gt; [输出文件]</code></p>
</li>
<li><p>参考</p>
<ul>
<li><a href="https://www.jianshu.com/p/2ccb50520cb1" target="_blank" rel="noopener"> Xcode 7.3 解析（符号化） iOS Crash 文件（.crash）</a></li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS Fastlane打包教程]]></title>
      <url>http://petpwiuta.github.io/2018/12/26/iOS%2520Fastlane%25E6%2589%2593%25E5%258C%2585%25E6%2595%2599%25E7%25A8%258B/</url>
      <content type="html"><![CDATA[<h3 id="iOS-Fastlane打包教程"><a href="#iOS-Fastlane打包教程" class="headerlink" title="iOS Fastlane打包教程"></a>iOS Fastlane打包教程</h3><p><a href="https://fastlane.tools/" target="_blank" rel="noopener">Fastlane</a>是一套由Ruby编写的自动打包以及分发工具集。它的设计类似于Unix中的shell pipeline，每个功能由特定的工具实现，通过不同的工具的连接组合成强大的功能。</p>
<blockquote>
<p>下面这些是Fastlane提供的常用工具：</p>
<ul>
<li><p><code>gym</code>: 打包 iOS App，是对<em>xcodebuild</em>的封装</p>
</li>
<li><p><code>match</code>: 用于在团队中同步证书和配置文件的工具</p>
</li>
</ul>
<ul>
<li><code>deliver</code>: 将应用截图，元数据和 app 上传到 App Store</li>
<li><code>produce</code>: 使用命令行在 iTunes Connect 后台和 Dev Portal 创建新的 iOS app</li>
</ul>
</blockquote>
<p>这里仅仅是列出了最常用的工具，Fastlane标准安装包中的<a href="https://docs.fastlane.tools/actions/" target="_blank" rel="noopener"><strong>工具</strong></a>非常多，而且还有<a href="https://www.jianshu.com/p/0520192c9bd7" target="_blank" rel="noopener"><strong>自定义插件</strong></a>功能，这里就不赘述。</p>
<h4 id="1-安装Fastlane"><a href="#1-安装Fastlane" class="headerlink" title="1 安装Fastlane"></a>1 安装Fastlane</h4><p> Fastlane本质是一个Ruby脚本的集合，所以机器上首先得安装Ruby。OS X 10.9(Mavericks)以后默认安装的是 Ruby 2.0 本。可能有些脚本或者工具要求更高的版本，所以安装的时候尽量选最新版的Ruby。</p>
<p>这里用<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>作为包管理器来安装Ruby：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">brew install ruby</span></span><br></pre></td></tr></table></figure>
<p>安装完Ruby以后才是我们的主角Fastlane：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo gem install fastlane</span></span><br></pre></td></tr></table></figure>
<p>等安装脚本执行完就可以开始Fastlane之旅啦！</p>
<h4 id="2-Fastlane设置"><a href="#2-Fastlane设置" class="headerlink" title="2 Fastlane设置"></a>2 Fastlane设置</h4><p>当Fastlane安装好以后，切换到想要用Fastlane进行打包的工程目录，然后初始化。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">fastlane init</span></span><br></pre></td></tr></table></figure>
<p>输入上面这个命令以后Fastlane会调用交互式脚本会询问你关于App的一些信息，按照实际信息填写完以后会生成下面这个结构的目录</p>
<p><img src="/images/fastlant-folder-structure.png" style="zoom:50%" align=left/></p>
<p>fastlane文件夹里面包含了Appfile、Fastfile等文件，它们其实都是ruby语法的脚本文件。上面这些都不用手动添加，运行对应的工具以后就会由工具自动生成，配置文件按需生成，不运行特定工具就不会有对应配置文件产生，如Matchfile，它在你运行<code>fastlane match</code>并输入相关信息后才会出现。</p>
<p>下面是常见的配置文件的用途：</p>
<ul>
<li>Appfile 记录了app_identifier、apple_id、itc_team_id、team_id等信息</li>
<li>Fastfile 最核心的文件。自己编写的Fastlane脚本逻辑都写在这个文件中</li>
<li>Matchfile 如果是用Match来管理证书的话会有这个文件，里面记录了Match工具在运行时所需要的app_identifier、team_id、username、git_url等信息</li>
</ul>
<p>fastlane的很多工具既可以写在Fastfile中当一个函数来调用，也可以直接在shell命令行用<code>fastlane 工具名</code>这种方式当命令来使（实际上是一样的，都是执行了对应的ruby脚本）。</p>
<p>上述文件里的配置信息会同步到Fastfile脚本的执行context中，如果用户在脚本里调用工具时没有指定这些字段的值，就会使用配置文件中的，反之就会以脚本里指定的为准。比如在Appfile中有app_identifier字段，你在Appfile中写的是a，在Fastfile中调用match时如果不写app_identifier就会取Appfile中的值也就是a，如果明确指定app_identifier为b，则会以b为准。不过在脚本中指定app_identifier为新值并不会把Appfile中的也改掉。</p>
<p>除了上面说的以外还有一种情况，就是在Matchfile和Appfile中都指定了app_identifier，这到底以哪个为准？这种情况下会以你运行的命令对应的配置文件为准，比如你运行的是match，它有自己的配置文件Matchfile，则app_identifier会以Matchfile中的为准。如果拿不准的话可以看fastlane的输出log，里面会详细列出脚本执行时的各种环境变量。</p>
<h4 id="3-Fastfile样例"><a href="#3-Fastfile样例" class="headerlink" title="3 Fastfile样例"></a>3 Fastfile样例</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">default_platform <span class="symbol">:ios</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span> <span class="keyword">do</span></span><br><span class="line">  before_all <span class="keyword">do</span>   </span><br><span class="line">    backup_project_info_file()</span><br><span class="line">    cocoapods()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  after_all <span class="keyword">do</span> <span class="params">|lane|</span></span><br><span class="line">    restore_project_info_file()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  error <span class="keyword">do</span> <span class="params">|lane, exception|</span></span><br><span class="line">    restore_project_info_file()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  desc <span class="string">"Deploy a new enterprise version"</span></span><br><span class="line">  lane <span class="symbol">:inhouse</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#start archive</span></span><br><span class="line">    build_app(</span><br><span class="line">      <span class="symbol">workspace:</span> <span class="string">"Demo.xcworkspace"</span>,</span><br><span class="line">      <span class="symbol">scheme:</span> <span class="string">"Demo"</span>,</span><br><span class="line">      <span class="symbol">configuration:</span> <span class="string">"Release"</span>,</span><br><span class="line">      <span class="symbol">clean:</span> <span class="literal">true</span>,</span><br><span class="line">      <span class="symbol">export_options:</span> <span class="string">"./fastlane/EnterpriseExportOptions.plist"</span>,</span><br><span class="line">      <span class="symbol">build_path:</span> <span class="string">"./Build/"</span>,</span><br><span class="line">      <span class="symbol">output_directory:</span> <span class="string">"./Build/"</span>,</span><br><span class="line">      <span class="symbol">include_symbols:</span> <span class="literal">false</span>,  <span class="comment">#ipa包中包含符号文件</span></span><br><span class="line">      <span class="symbol">output_name:</span> <span class="string">"Demo.ipa"</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">#make change log from commit history</span></span><br><span class="line">    log = changelog_from_git_commits(<span class="symbol">merge_commit_filtering:</span> <span class="string">"exclude_merges"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#upload to pger</span></span><br><span class="line">    pgyer(<span class="symbol">api_key:</span> <span class="string">"api key"</span>, <span class="symbol">user_key:</span> <span class="string">"ukey"</span> ,<span class="symbol">update_description:</span> log)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#post notification by dingding</span></span><br><span class="line">    dingding_noti(</span><br><span class="line">      <span class="string">"./Build/Demo.ipa"</span>,  <span class="comment">#ipa path</span></span><br><span class="line">      <span class="string">""</span>,   <span class="comment">#ipa url</span></span><br><span class="line">      <span class="string">""</span>, <span class="comment">#icon url</span></span><br><span class="line">      log <span class="comment">#change log</span></span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lane <span class="symbol">:inhouse</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">#自定义逻辑</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上面这个格式就是定义一个action，当你使用<code>fastlane inhouse</code>时里面的自定义代码就会被运行。</p>
<p>这是一个典型的Fastfile逻辑，先是调用build_app来archive并导出ipa文件，再调用changelog_from_git_commits生成change log，然后把ipa上传到蒲公英分发系统，最后再用钉钉通知任务完成。这里是在单个target以及证书和相关profile都配置好的情况下的demo。不过在实际中往往会有动态修改target信息，用match更新证书和profile等逻辑，最终的脚本就要比这个复杂很多。</p>
<h4 id="4-Fastlane-Jenkins"><a href="#4-Fastlane-Jenkins" class="headerlink" title="4 Fastlane+Jenkins"></a>4 Fastlane+Jenkins</h4><p>其实Jenkins对移动端的打包支持的并不好，所以在Fastlane成熟以后很多人都把打包逻辑迁移到Fastlane上了。这里Jenkins就演变成变成一个CI控制台，仅仅用来做权限控制和脚本触发器。</p>
<p>Jenkins中集成Fastlane就很简单了，在编译的环节直接调用本地的Fastlane脚本就行。</p>
<h4 id="5-题外话"><a href="#5-题外话" class="headerlink" title="5 题外话"></a>5 题外话</h4><p>Fastlane踩坑下来发现这套方案功能确实很强大，然而也很复杂。你得学Ruby（有些逻辑不一定能找到现成的插件，得自己写），然后还得把Fastlane的运行逻辑搞清楚，学习成本还是有一点的。所以Fastlane方案适合产品比较多，发版逻辑比较复杂的中大型公司。</p>
<p>在前几年专门做移动端CI的服务商还还不多，但现在移动领域CI集成方案已经很丰富。并且Xcode Server在经过几个版本的迭代以后基本上已经能满足大部分CI需求。所以Fastlane并非是唯一的选择，根据自己的需求选择合适的方案就行，<a href="https://medium.com/xcblog/five-options-for-ios-continuous-delivery-without-fastlane-2a32e05ddf3d" target="_blank" rel="noopener">这篇文章</a>详细介绍了除Fastlane以外其他的CI方案。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul>
<li><p><a href="https://xiaozhuanlan.com/topic/4591867203" target="_blank" rel="noopener">Fastlane 的神秘花园</a></p>
</li>
<li><p><a href="https://medium.com/xcblog/five-options-for-ios-continuous-delivery-without-fastlane-2a32e05ddf3d" target="_blank" rel="noopener">Five Options for iOS Continuous Delivery without Fastlane</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[移动开发中的CI方案简介]]></title>
      <url>http://petpwiuta.github.io/2018/12/26/%25E7%25A7%25BB%25E5%258A%25A8%25E5%25BC%2580%25E5%258F%2591%25E4%25B8%25AD%25E7%259A%2584CI%25E6%2596%25B9%25E6%25A1%2588%25E7%25AE%2580%25E4%25BB%258B/</url>
      <content type="html"><![CDATA[<h3 id="移动开发中的CI方案简介"><a href="#移动开发中的CI方案简介" class="headerlink" title="移动开发中的CI方案简介"></a>移动开发中的CI方案简介</h3><p> <a href="https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/" target="_blank" rel="noopener">Continuous integration</a> (CI) 是软件工程中的重要概念，以前在传统的软件开发中用的比较多（以前常说的daily build or nightly build意思和CI差不多）。现在随着移动App的流行，相关的工具以及方法论在移动开发中也有所体现。这里简单说一下现在移动研发领域的CI现状（CI工具一般都是跨语言的，所以下面列出的这些工具大部分也能在前后端开发中使用）。</p>
<p>现在CI的解决方案很多，有开源的也有收费的。开源的免费，绝大部分功能都够用，不过出问题得自己处理，不过如果选热门的开源解决方案的话基本上常见问题都有人帮你踩坑了，所以这点不用担心（反之如果选冷门开源方案一定要做好自己改代码的心理准备）。商业方案除了贵以外没啥缺点，一般就是衡量价格、功能，以及各厂商的差异化功能。</p>
<h4 id="开源方案"><a href="#开源方案" class="headerlink" title="开源方案"></a>开源方案</h4><ul>
<li><p><a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a></p>
<p>Jenkins是一款著名的开源CI工具，除了界面丑点，其他功能基本上和一般收费方案没什么区别。很多公司团队会基于Jenkins做二次开发，把后端、前端和移动端的CI都集成到Jenkins中。</p>
</li>
<li><p><a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis CI</a></p>
<p>Travis CI是一个开源的在线<a href="https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88" target="_blank" rel="noopener">持续集成</a>服务，用来构建和测试托管在Github上的代码。它和Github类似，对开源项目免费，其他项目要收费。这个用来做个人项目比较方便，如果公司要用的话可以选它的付费企业版服务。</p>
</li>
<li><p><a href="https://about.gitlab.com/" target="_blank" rel="noopener">GitLab</a></p>
<p>GitLab是互联网公司常用的开源代码管理工具，在8.0版本上也有CI功能了。</p>
</li>
</ul>
<h4 id="收费方案"><a href="#收费方案" class="headerlink" title="收费方案"></a>收费方案</h4><ul>
<li><p><a href="https://circleci.com/" target="_blank" rel="noopener">Circle CI</a></p>
<p>Circle CI本身是在线服务，不过企业版支持私有化部署。</p>
</li>
<li><p><a href="https://www.bitrise.io/" target="_blank" rel="noopener">Bitrise</a></p>
<p>Bitrise是专门为移动应用而设计的CI在线服务，企业版支持私有化部署。</p>
</li>
<li><p><a href="https://visualstudio.microsoft.com/zh-hans/app-center/" target="_blank" rel="noopener">Visual Studio App Center</a></p>
<p>Visual Studio App Center和Bitrise一样，是微软专门为移动应用而设计的CI在线服务</p>
</li>
</ul>
<p>这里只是对市面上常见的CI方案做了下汇总，如果想看看各种方案的详细对比可以看<a href="https://hackernoon.com/top-ci-cd-tools-for-your-android-and-ios-projects-8d356b983b3b" target="_blank" rel="noopener">这篇文章</a>。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul>
<li><a href="https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/" target="_blank" rel="noopener">Continuous integration</a></li>
<li><a href="https://hackernoon.com/top-ci-cd-tools-for-your-android-and-ios-projects-8d356b983b3b" target="_blank" rel="noopener">Best Jenkins alternatives. Top CI/CD Tools for your Android and iOS projects</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Xcode Signing 机制]]></title>
      <url>http://petpwiuta.github.io/2018/12/26/Xcode%25E7%25AD%25BE%25E5%2590%258D%25E6%259C%25BA%25E5%2588%25B6/</url>
      <content type="html"><![CDATA[<h3 id="Xcode-Signing-机制"><a href="#Xcode-Signing-机制" class="headerlink" title="Xcode Signing 机制"></a>Xcode Signing 机制</h3><h4 id="历史遗留问题"><a href="#历史遗留问题" class="headerlink" title="历史遗留问题"></a>历史遗留问题</h4><p>做iOS开发经验稍长的同学都知道Xcode8以前的证书管理机制做的比较简单。就是一旦发现你的机器没有provisionProfile所关联的证书，就会在界面上显示红色按钮，你点击“Fix it”，然后Xcode就revoke provisionProfile所关联的证书，然后在帮你申请一个新的。</p>
<p>这个单人单机的情况下没有什么问题，不过你如果有2台以上的mac就会发现“Fix it”这个按钮不能随便点。多台mac一般都是把私钥copy到每一台电脑上，如果在哪台电脑上点了“Fix it”，这时辛辛苦苦复制好的私钥就会revoke，瞬间所有mac都不能正常干活了。如果是一个人有多台电脑还好点，这个问题在团队里面更严重，多人有多人电脑时，很可能会有人误点到“Fix it”按钮，而造成整个团队罢工的情况。所以一般小组成员都会互相告诫不能随便点“Fix it”按钮，甚至有人还写了插件来禁用这个按钮。</p>
<p>这种痛苦的情况在Xcode8上得到了彻底解决。</p>
<h4 id="Xcode8引入的新的开发证书的更新机制"><a href="#Xcode8引入的新的开发证书的更新机制" class="headerlink" title="Xcode8引入的新的开发证书的更新机制"></a>Xcode8引入的新的开发证书的更新机制</h4><p>Xcode8引入的最大改变就是provisionProfile中关联的证书变成了多个，一个develop版本的provisionProfile中可以关联所有开发人员自己的证书。只要在机器上有列表中的任何一个证书就能进行代码签名，这样在新成员来时仅仅更新它自己的证书以及provisionProfile就行，并不会影响其他人，这个步骤在Xcode8中非常简单，只需要一个点击就能搞定</p>
<p>Xcode的这些操作都是在后台进行的，不过你如果想要了解估计的细节可以在左侧的“Show the Report navigator(最后一个选项)”选项卡中看到<br><img src="/images/xcode-sign.png" alt=""></p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ul>
<li><p>Automatically manage signning<br>在这种模式下每个开发人员都会有自己的develop证书，这时尽量用自己develop证书来archive，而不要用公共的开发证书，避免了别人不小心把公用证书revoke导致的一系列问题</p>
</li>
<li><p>manully manage signning<br>手动管理证书的时候主要不要选和自己帐号相关联的证书，因为自己的帐号只有自己有，到团队其他成员的机器上就不能工作了。这时候就选develope这样的默认值就行了</p>
</li>
</ul>
<h4 id="相关引用"><a href="#相关引用" class="headerlink" title="相关引用"></a>相关引用</h4><ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/403/" target="_blank" rel="noopener">What’s New in Signing for Xcode and Xcode Server - WWDC2017</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2016/401" target="_blank" rel="noopener">What’s New in Xcode App Signing - WWDC2016</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Match工具介绍]]></title>
      <url>http://petpwiuta.github.io/2018/12/26/Match%25E5%25B7%25A5%25E5%2585%25B7%25E4%25BB%258B%25E7%25BB%258D/</url>
      <content type="html"><![CDATA[<h3 id="Match工具介绍"><a href="#Match工具介绍" class="headerlink" title="Match工具介绍"></a>Match工具介绍</h3><p>Match是Fastlane工具集中非常重要的一个，它负责iOS应用生命周期中的各种证书和profile的创建和维护。想想各位被各种证书和profile问题所支配的恐惧就知道它的厉害之处。</p>
<h4 id="1-功能特性"><a href="#1-功能特性" class="headerlink" title="1 功能特性"></a>1 功能特性</h4><ul>
<li><p>创建、更新和删除Xcode所需的各种证书和Profiles</p>
</li>
<li><p>使用Git管理上述的文件，达到团队内共享证书和Profiles的目的</p>
</li>
<li><p>证书和Profiles在进入Git仓库时会进行加密，进一步保证安全性</p>
</li>
<li><p>支持多账户，多target</p>
</li>
</ul>
<h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h4><p>Match内部使用cert、sign来分别进行证书以及profiles的管理。cert、sign是对苹果官方的API的二次封装，使用它们配置好证书和profiles以后，再指定一个Git仓库的地址，以及加密证书和profiles的密码，Match就会用指定的密码把证书和profiles加密，然后在把加密后的文件commit到版本库，并push到Git仓库地址。当其他成员需要这些信息的时候使用Match命令，它就会从Git仓库pull加密过的文件，并询问密码，得到密码后再把这些文件解密并添加到keychain和Profiles目录。这样就像Git管理代码一样实现了团队内共享证书和Profiles的目的。</p>
<h4 id="3-用法"><a href="#3-用法" class="headerlink" title="3 用法"></a>3 用法</h4><h5 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fastlane match init</span><br></pre></td></tr></table></figure>
<p>会进入交互式shell环境，按照实际情况输入app_identifier、team_id、username、git_url等信息后会在fastlane目录生成Matchfile。</p>
<h5 id="3-2-生成并同步证书和profile"><a href="#3-2-生成并同步证书和profile" class="headerlink" title="3.2 生成并同步证书和profile"></a>3.2 生成并同步证书和profile</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开发环境证书</span></span><br><span class="line">$ fastlane match development</span><br><span class="line"><span class="comment"># 产品环境证书</span></span><br><span class="line">$ fastlane match appstore</span><br><span class="line"><span class="comment"># 内测环境证书</span></span><br><span class="line">$ fastlane match adhoc</span><br></pre></td></tr></table></figure>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul>
<li><p><a href="http://icyleaf.com/2017/03/fastlane-match-in-action/" target="_blank" rel="noopener">你虐我千百遍，我待你如初恋，直到我遇到 match</a></p>
</li>
<li><p><a href="https://docs.fastlane.tools/actions/match/" target="_blank" rel="noopener">match doc</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[给Xcode8安装插件]]></title>
      <url>http://petpwiuta.github.io/2017/11/13/%25E7%25BB%2599Xcode8%25E5%25AE%2589%25E8%25A3%2585%25E6%258F%2592%25E4%25BB%25B6/</url>
      <content type="html"><![CDATA[<h3 id="给Xcode8安装插件"><a href="#给Xcode8安装插件" class="headerlink" title="给Xcode8安装插件"></a>给Xcode8安装插件</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Xcode8以后安装以前<a href="http://alcatraz.io/" target="_blank" rel="noopener">Alcatraz</a>上的插件就行不通了，不过网上也有很多方案，主要是重新给Xcode签名。这里把这些文章做一个汇总。</p>
<p>在Xcode8以后，苹果为了安全性(比如防止再次出现XcodeGhost事件)，把Xcode增加了签名校验，不会再加载以前Alcatraz下载的插件。并给出了自己的插件机制(<a href="https://developer.apple.com/videos/play/wwdc2016/414/" target="_blank" rel="noopener">Xcode Source Editor Extension</a>)，但是这个插件机制实用性很低。所以很多人就想着要继续使用以前的插件。</p>
<p>现在的主流方案是是把Xcode复制一份，一个没有重签名，用来打包上线。另外一份重签名后，重新使用以前的插件，仅仅用来写代码。下面就来说说<strong>如何进行Xcode重签名</strong>、以及<strong>如何让以往的插件能在重签名的Xcode上跑起来</strong>。</p>
<h4 id="Xcode重签名"><a href="#Xcode重签名" class="headerlink" title="Xcode重签名"></a>Xcode重签名</h4><ol>
<li>创建自签名证书<br>打开钥匙串，创建新证书，名称填XcodeSigner，证书类型选择代码签名(名字里面尽量不要包含空格，免得在命令行容易出错)<br><img src="/images/Xcod8plugin/xcode8_resign_1.png" alt=""><br><img src="/images/Xcod8plugin/xcode8_resign_2.png" alt=""></li>
<li><p>复制Xcode。这里因为要留一份未重签名的Xcode来打包，所以这里先复制一份，并重命名为XcodeSigner</p>
</li>
<li><p>给Xcode重签名(这里的Xcode已经重命名为XcodeSigner)<br><code>sudo codesign -f -s XcodeSigner /Applications/XcodeSigner.app</code></p>
</li>
</ol>
<p>经过上面这些步骤Xcode就已经被重签名了，什么？你说为什么三步，能一步到位吗，恩、问得好。还真有一步到位的解决方案。<br><a href="https://github.com/fpg1503/MakeXcodeGr8Again" target="_blank" rel="noopener">MakeXcodeGr8Again</a>把上面说的这三步合在了一起，并提供了CLI和GUI两种使用方式。一步到位！</p>
<p>运行重新签名过后的Xcode很多人会发现以前的插件还是没有工作。这个问题在以前就有。原因是插件的<code>DVTPlugInCompatibilityUUIDs</code>包含了可运行的Xcode版本id，Xcode更新以后需要把新Xcode的id添加到插件的<code>DVTPlugInCompatibilityUUIDs</code>中。</p>
<h4 id="把Xcode-id加入DVTPlugInCompatibilityUUIDs"><a href="#把Xcode-id加入DVTPlugInCompatibilityUUIDs" class="headerlink" title="把Xcode id加入DVTPlugInCompatibilityUUIDs"></a>把Xcode id加入DVTPlugInCompatibilityUUIDs</h4><ol>
<li><p>获取Xcode的uuid<br>Xcode的Info.plist里就保存了自己的uuid。</p>
<p>可以<code>右键点击Xcode</code>-&gt;<code>显示包内容</code>-&gt;<code>Contents/Info.plist</code>-&gt;<code>复制DVTPlugInCompatibilityUUID</code>来获取</p>
<p>也可以通过<code>defaults read /Applications/Xcode.app/Contents/Info.plist DVTPlugInCompatibilityUUID</code>命令来获取</p>
</li>
<li><p>把uuid加入插件的DVTPlugInCompatibilityUUIDs<br>Xcode插件放在<code>~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins</code>为xcplugin格式。通过显示包内容可以看到xcplugin中有个<code>Info.plist</code>，DVTPlugInCompatibilityUUIDs字段就是。</p>
</li>
</ol>
<p>把uuid更新到插件中需要两步，但是！插件有很多个，一个个来肯定要把人逼疯，这里当然有all in one的解决方案。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~&#x2F;Library&#x2F;Application\ Support&#x2F;Developer&#x2F;Shared&#x2F;Xcode&#x2F;Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add &#96;defaults read &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Info.plist DVTPlugInCompatibilityUUID&#96;</span><br></pre></td></tr></table></figure>
<p>这个命令主要做了这些：<br>通过<code>find</code>在插件目录下找到所有插件的Info.plist文件。<br>通过<code>xargs</code>对上一步的搜索结果进行枚举，针对每一个Info.plist文件，利用<code>defaults write</code>命令将当前Xcode版本的uuid加到DVTPlugInCompatibilityUUIDs中。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="http://www.jianshu.com/p/309da7b2119d" target="_blank" rel="noopener">如何在Xcode8上安装插件</a></li>
<li><a href="http://joeshang.github.io/2015/04/10/fix-xcode-upgrade-plugin-invalid/" target="_blank" rel="noopener">Xcode升级后插件失效的原理与修复办法</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[NSURLProtocol总结]]></title>
      <url>http://petpwiuta.github.io/2017/09/10/NSURLProtocol%25E4%25BB%258B%25E7%25BB%258D/</url>
      <content type="html"><![CDATA[<h2 id="NSURLProtocol总结"><a href="#NSURLProtocol总结" class="headerlink" title="NSURLProtocol总结"></a>NSURLProtocol总结</h2><p>NSURLProtocol可以说是苹果允许的一个中间人攻击组件，功能非常强大。但是关于NSURLProtocol的官方文档不多，不过业内已经有很多人踩坑，网上相关的文章比较多，这里把网上搜集到的相关文章做一个汇总</p>
<h3 id="NSURLProtocol介绍"><a href="#NSURLProtocol介绍" class="headerlink" title="NSURLProtocol介绍"></a>NSURLProtocol介绍</h3><p>NSURLProtocol是URL Loading System中的一个模块，能拦截这个系统中发出的所有请求，那具体是哪些类发出的请求呢？<code>NSURLConnection</code>、<code>NSURLSession</code>、<code>UIWebVIew(页面内部的所有请求包括ajax)</code>、<code>WKWebVIew(不能直接拦截，需要hack)</code>，以及基于他们的封装如<code>AFNetworking</code>、<code>Alamofire</code>等都是能拦截的，而基于<code>CFNetwork</code>的请求则不能被拦截</p>
<p>进行拦截以后可以做非常多的自定义行为，比如说：</p>
<ul>
<li>拦截图片加载请求，转为从本地文件加载</li>
<li>对HTTP返回内容进行mock和stub</li>
<li>对发出请求的header进行格式化</li>
<li>对发出的媒体请求进行签名</li>
<li>创建本地代理服务，用于数据变化时对URL请求的更改</li>
<li>故意制造畸形或非法返回数据来测试程序的鲁棒性</li>
<li>过滤请求和返回中的敏感信息</li>
<li>在既有协议基础上完成对 NSURLConnection 的实现且与原逻辑不产生矛盾</li>
</ul>
<h3 id="NSURLProtocol的用法"><a href="#NSURLProtocol的用法" class="headerlink" title="NSURLProtocol的用法"></a>NSURLProtocol的用法</h3><h4 id="新建、注册子类"><a href="#新建、注册子类" class="headerlink" title="新建、注册子类"></a>新建、注册子类</h4><p><code>NSURLProtocol</code>是一个抽象类，必须被子类化之后才能使用，所以要新建一个继承于它的子类。</p>
<p>基于NSURLConnection或者使用[NSURLSession sharedSession]创建的网络请求，调用registerClass方法即可<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSURLProtocol</span> registerClass:NetworkURLProtocol.class];   <span class="comment">//注册</span></span><br><span class="line">[<span class="built_in">NSURLProtocol</span> unregisterClass:NetworkURLProtocol.class]; <span class="comment">//注销</span></span><br></pre></td></tr></table></figure></p>
<p>而基于NSURLSession的网络请求，需要通过配置NSURLSessionConfiguration对象的protocolClasses属性来注册。(网络上有<a href="http://tech.lede.com/2017/02/15/rd/iOS/iOS_NSURLProtocol/" target="_blank" rel="noopener">文章</a>说protocolClasses这个数组里只有第一个NSURLProtocol会起作用。并以OHHTTPStubs库为例子，它是在注册先NSURLProtocol插入到protocolClasses的第一个，进行拦截。拦截完成之后又进行移除。这个还没有做实验证实)<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *sessionConfiguration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">sessionConfiguration.protocolClasses = @[NetworkURLProtocol.class];</span><br><span class="line"><span class="comment">//取消注册的话直接把protocol从数组中移除就行</span></span><br></pre></td></tr></table></figure></p>
<h4 id="重载必要的方法"><a href="#重载必要的方法" class="headerlink" title="重载必要的方法"></a>重载必要的方法</h4><p>(1)当遍历到我们自定义的NSURLProtocol时，系统先会调用<code>canInitWithRequest:</code>这个方法。顾名思义，这是整个流程的入口，只有这个方法返回YES我们才能够继续后续的处理。我们可以在这个方法的实现里面进行请求的过滤，筛选出需要进行处理的请求<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否有已编辑的标识，用来识别是第一次过来的请求还是已经改写过的请求</span></span><br><span class="line">    <span class="built_in">BOOL</span> isEditedRequest = [[<span class="built_in">NSURLProtocol</span> propertyForKey:<span class="string">@"NetworkURLProtocol"</span> inRequest:request] boolValue];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据配置来过滤请求</span></span><br><span class="line">    <span class="built_in">BOOL</span> configDeny = ![[NetworkManager sharedManager].config canCaptureRequest:request];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isEditedRequest || configDeny) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(2)<code>canInitWithRequest</code>返回YES后系统会把请求回调到这里。在这里完成请求的编辑/替换工作。需要注意的是系统会以这个方法返回值为参数，再次调用上面说到的<code>canInitWithRequest</code>方法，所以这里一定要添加一些标志变量来区分请求是否被编辑，不然系统就会因为循环调用这两个方法而陷入死循环<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [request mutableCopy];</span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@YES</span><br><span class="line">                        forKey:<span class="string">@"NetworkURLProtocol"</span></span><br><span class="line">                     inRequest:mutableReqeust];</span><br><span class="line">    <span class="keyword">return</span> [mutableReqeust <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(3)处理开始和结束的状态<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Request被编辑完后，系统会调用这个方法，这里一般用来发起请求</span></span><br><span class="line"><span class="comment">//这里方法里一定要有手动发起网络请求的逻辑，否则整个流程就不会往下走</span></span><br><span class="line">- (<span class="keyword">void</span>)startLoading  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:[[<span class="keyword">self</span> <span class="keyword">class</span>] canonicalRequestForRequest:<span class="keyword">self</span>.request] delegate:<span class="keyword">self</span> startImmediately:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求结束后会调用这个方法，在这里取消请求，以及做一些数据处理工作</span></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于判断你的自定义reqeust是否相同，这里返回默认实现即可。主要应用场景是某些直接使用缓存而非再次请求网络的地方。如果不是用来做缓存的话这个方法可以不实现</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> requestIsCacheEquivalent:a toRequest:b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="调用NSURLProtocolClient协议方法"><a href="#调用NSURLProtocolClient协议方法" class="headerlink" title="调用NSURLProtocolClient协议方法"></a>调用NSURLProtocolClient协议方法</h4><p>NSURLProtocol给了一次机会让我们接管请求，我们在完成接管的过程中还是需要向我们的客户端(发起请求的业务代码)提供服务。NSURLProtocol实例中有个<code>id &lt;NSURLProtocolClient&gt; client</code>属性来帮我们做到这一点，我们只需要在合适的时机来调用<code>NSURLProtocolClient</code>协议规定的方法就行。<br>注意我们的模拟行为需要尽可能的和系统保持一致，所以<code>NSURLProtocolClient</code>协议规定的方法最好在对应的时机都要有相应的调用，换句话说就是<code>NSURLProtocolClient</code>协议规定的每一个方法都至少调用一遍</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSURLConnectionDelegate</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">  didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didFailWithError:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)connectionShouldUseCredentialStorage:(<span class="built_in">NSURLConnection</span> *)connection &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge &#123;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didReceiveAuthenticationChallenge:challenge];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">didCancelAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge &#123;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didCancelAuthenticationChallenge:challenge];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSURLConnectionDataDelegate</span></span><br><span class="line">- (<span class="built_in">NSURLRequest</span> *)connection:(<span class="built_in">NSURLConnection</span> *)connection willSendRequest:(<span class="built_in">NSURLRequest</span> *)request redirectResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    <span class="comment">//并非重定向请求才会走这个方法，一般的请求也会回调到这里。如果不做判断话会导致把一般请求当成重定向，而且在ios8.1上会直接崩溃</span></span><br><span class="line">    <span class="keyword">if</span> (response != <span class="literal">nil</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.response = response;</span><br><span class="line">        [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> wasRedirectedToRequest:request redirectResponse:response];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageAllowed</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSCachedURLResponse</span> *)connection:(<span class="built_in">NSURLConnection</span> *)connection willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedResponse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSURLProtocol的注意事项"><a href="#NSURLProtocol的注意事项" class="headerlink" title="NSURLProtocol的注意事项"></a>NSURLProtocol的注意事项</h3><p>(1) NSURLProtocol多线程问题。有同学可能会想到网络请求中多个request都会走NSURLProtocol的代理方法，那会不会有并发的问题。其实每个网络请求都会实例化一个NSURLProtocol的子类对象，所以每个网络请求之间不会互相影响</p>
<p>(2) NSURLProtocolClient回调必须跟发起请求的代码发送保持在一个线程、相同的Runloop。这个也很好理解，因为我们的改写逻辑对客户端(一般是业务代码)应该是透明的，所以行为和状态都应该和系统的网络请求框架保持一致：因此我们要在start方法中记录当前线程和Runloop模式。然后在记录的线程以相同的Runloop模式回调NSURLProtocolClient的方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:onThread:withObject:waitUntilDone:modes:];</span><br></pre></td></tr></table></figure></p>
<p>(3) NSURLSession的POST请求拿不到HTTPBody。苹果官方的解释是Body是NSData类型，而且还没有大小限制。为了性能考虑，拦截时就没有拷贝</p>
<p>(4) WKWebview不能直接拦截。WKWebView在独立于app进程之外的进程中执行网络请求，请求数据不经过主进程，因此在WKWebView上直接使用NSURLProtocol无法拦截请求。需要hack一下，具体的技术方案请看”<a href="https://blog.yeatse.com/2016/10/26/support-nsurlprotocol-in-wkwebview/" target="_blank" rel="noopener">让WKWebView支持NSURLProtocol</a>“</p>
<p>(5) 多个NSURLProtocol嵌套使用。若一个项目中存在多个NSURLProtocol，那么NSURLProtocol的拦截顺序跟注册的方式和顺序有关。<br>对于使用registerClass方法注册：多个NSURLProtocol拦截顺序为注册顺序的反序，即后注册的的NSURLProtocol先拦截。<br>对于通过配置NSURLSessionConfiguration对象的protocolClasses属性来注册的：<br>protocolClasses这个数组里据说只有第一个NSURLProtocol会起作用。(还没做实验证实)</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://developer.apple.com/library/content/samplecode/CustomHTTPProtocol/Introduction/Intro.html" target="_blank" rel="noopener">CustomHttpProtocol苹果官方示例</a></li>
<li><a href="http://blog.csdn.net/jingcheng345413/article/details/54967739" target="_blank" rel="noopener">NSURLProtocol概述</a></li>
<li><a href="http://tech.lede.com/2017/02/15/rd/iOS/iOS_NSURLProtocol/" target="_blank" rel="noopener">NSURLProtocol全攻略</a></li>
<li><a href="https://blog.yeatse.com/2016/10/26/support-nsurlprotocol-in-wkwebview/" target="_blank" rel="noopener">让WKWebView支持NSURLProtocol</a></li>
<li><a href="https://github.com/AliSoftware/OHHTTPStubs" target="_blank" rel="noopener">OHHTTPStubs库</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653578513&amp;idx=1&amp;sn=961bf5394eecde40a43060550b81b0bb&amp;chksm=84b3b716b3c43e00ee39de8cf12ff3f8d475096ffaa05de9c00ff65df62cd73aa1cff606057d&amp;mpshare=1&amp;scene=1&amp;srcid=0214nkrYxApaVTQcGw3U9Ryp" target="_blank" rel="noopener">WKWebView那些坑</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Autolayout笔记:基本概念]]></title>
      <url>http://petpwiuta.github.io/2017/07/13/AutoLayout-%25E5%259F%25BA%25E7%25A1%2580%25E6%25A6%2582%25E5%25BF%25B5/</url>
      <content type="html"><![CDATA[<h1 id="Autolayout笔记-基本概念"><a href="#Autolayout笔记-基本概念" class="headerlink" title="Autolayout笔记:基本概念"></a>Autolayout笔记:基本概念</h1><p>AutoLayout使用非常简单，Xcode的支持也非常直观。但是因为和之前的方式有很大的不同，学习曲线比较陡峭，所以给新手造成一些心理负担，下面我将通过一些列的文章来给大家简单的讲解一下Autolayout的基本用法。</p>
<p>AutoLayout是一个基于约束的布局系统。描述各种约束的行为，比如一个View 距离父View上边距多少，相邻之间的间隔多少，各个View之间的宽高关系等等。这一系列的条件就是为了最终确定之前提到的传统布局中需要的东西，这个View的大小、位置。所以，当我们设置的条件不足，或是条件冲突时，就会产生异常。</p>
<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>上面说了Autolayout是基于约束的，约束在iOS/OS X里面就是Constraint，让我们看看新建一个Constraint的API是怎样的：</p>
<pre><code>NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:item1
                                                                   attribute:NSLayoutAttributeLeft
                                                                   relatedBy:NSLayoutRelationEqual
                                                                      toItem:item2
                                                                   attribute:NSLayoutAttributeLeft
                                                                  multiplier:1
                                                                    constant:10];
</code></pre><p>这里的参数比较多，但仔细看可以发现它表述了这样一种关系：<br><strong>Item. Attribute relatedBy toItem. Attribute * multiplier + constant</strong>。用人话解释一遍就是一个view的某个属性在位置上和另外一个view的某个属性有一定关系。举个例子比如说我想表达view1的右边和view2的左边相互紧挨着，那应该这么写<br><strong>View1.右边 = view2.左边 * 1 + 0</strong><br>这里的<code>=</code>表示的是位置相同的意思，另外除了等于以外还有<code>≤</code>和<code>≥</code>同样它们都是表示位置上关系。完成一个constraint后需要把它添加到constraint所关联的iteam的共同superView上。</p>
<p><strong>需要注意的是constraints是累积的，它们之间是不能互相覆盖。</strong>如果你有一个constraints，你再添加一个同类型的constraints并不覆盖前一个。</p>
<h2 id="Intrinsic-Content-Size"><a href="#Intrinsic-Content-Size" class="headerlink" title="Intrinsic Content Size"></a>Intrinsic Content Size</h2><p>苹果在使用Autolayout的原则里有一条是<strong>“视图是趋于自治的”</strong>，因此苹果鼓励用户在自定义view时自己实现Intrinsic Content Size，让view自己决定自己的大小。</p>
<p>Intrinsic Content Size指的是view能显示内容的最佳尺寸。例如，UILabel的最佳高度取决于它的字体大小，它的最佳宽度取决于它的字体还有所显示的内容。一个UIProgressView的最佳高度取决于它的样式，而宽度则没有要求。一个空白的UIView则在宽度和高度上都没有要求。</p>
<p>如果一个自定义的view的大小和其所显示的内容有关的话，就需要实现Intrinsic Content Size相关的方法。在实现Intrinsic Content Size的相关方法时你需要做两件事情：</p>
<ol>
<li>重写intrinsicContentSize方法，根据view显示的内容返回合适的intrinsic content size；</li>
<li>在有些影响到Intrinsic Content Size的情况发生的时候调用<code>invalidateIntrinsicContentSize</code>例如当UILabel的文本内容变化的时候就需要调用上述的方法。如果view只有在某一个维度上有Intrinsic Content Size，那在另一个维度上返回<code>UIViewNoIntrinsicMetric</code>或者<code>NSViewNoIntrinsicMetric</code>就可以了。</li>
</ol>
<p><strong>需要注意的是intrinsic content size不能依赖view的frame。</strong>例如根据frame按比例返回intrinsic content size就是不可行的。</p>
<h2 id="Sprint-amp-struts-VS-Autolayout"><a href="#Sprint-amp-struts-VS-Autolayout" class="headerlink" title="Sprint&amp;struts VS. Autolayout"></a>Sprint&amp;struts VS. Autolayout</h2><p>在Autolayout出现之前，我们使用<code>autoresizingMask</code>来描述当父视图的尺寸变化时子视图的动作。现在autolayout里使用Compression Resistance 和 Content Hugging来替代它们。不过为了兼容<code>autoresizingMask</code>，UIView在iOS6之后添加了一个新属性<code>translatesAutoResizingMaskIntoConstraints</code>(默认为YES)来自动把<code>autoresizingMask</code>转换成Constraints。</p>
<p>在这里可能会有人问那在Autolayout环境下还能继续使用设置frame的方式进行布局吗。答案肯定是<strong>能</strong>，因为Autolayout系统仅仅是在frame布局的过程前面添加了一个计算约束的过程，最后计算好的结果还是通过frame来应用的。</p>
<p><strong>这里可能会有人有过在Autolayout环境下设置frame不生效的经历</strong>，这里简单说下为什么。如果<code>requiresConstraintBasedLayout</code>被设置为<code>YES</code>则只能使用Autolayout进行布局，<br>否则就看<code>translatesAutoresizingMaskIntoConstraints</code>的设置，如果是YES则Autolayout和frame都可以进行布局，如果为NO则需要继续看是否存在<code>intrinsicContentSize</code>，如果存在则只能用Autolayout布局、不存在则Autolayout和frame都可以进行布局。</p>
<p>你可以给view的每个维度(就是x方向和y方向)设置Compression Resistance、Content Hugging优先级。不过这个优先级仅仅对定义了intrinsic content size的view才会生效。</p>
<p>在iOS上可以用<code>setContentHuggingPriority:forAxis:</code> 和 <code>setContentCompressionResistancePriority:forAxis:</code> 分别设置优先级(如果是NSVIew则是<code>setContentHuggingPriority:forOrientation:</code> 和 <code>setContentCompressionResistancePriority:forAxis:</code>)优先级的默认值是<code>NSLayoutPriorityDefaultHigh</code>或 <code>NSLayoutPriorityDefaultLow</code>.</p>
<p>最后有一点需要注意，如果设定intrinsic content size和上述的优先级的话，系统把这些解释成一系列的constraint。例如一个label的intrinsic content size为{100,30}，x/y方向的compression resistance 优先级是750，Content Hugging优先级是250，这些条件会生成4个constraint：</p>
<pre><code>H:[label(&lt;=100@250)]
H:[label(&gt;=100@750)]
V:[label(&lt;=30@250)]
V:[label(&gt;=30@750)]
</code></pre><h2 id="Frame-VS-Alignment-Rect"><a href="#Frame-VS-Alignment-Rect" class="headerlink" title="Frame VS. Alignment Rect"></a>Frame VS. Alignment Rect</h2><p>Autolayout在布局的时候不是操作view的frame而是alignment rect。这两者有一些非常容易让人忽略的细小差异，在大部分情况下他们功能都一样，但在某些场合alignment rect的功能可能更强大。</p>
<p>大家可能都遇到过这样一种情况，一个button设置一个比较小的图片（或者图片周围有大面积的透明区）就会照成按钮看来很小，而且在布局的时候若以frame来做的话就会形成代码上是“对齐了”，但看起来就是“不整齐” 的情况，这是如果用alignment rect就会完美地解决这个问题。</p>
<p>用alignment rect可以很灵活地自定义用于layout的区域，大部分情况下仅仅需要重写alignmentRectInsets方法就行了，它会让你返回一个相对于frame的Inset。如果上面的方法还不能满足需求则可以重写<code>alignmentRectForFrame:</code>和<code>frameForAlignmentRect:</code>这两个方法，这两个方法可以让你更加灵活的根据frame来返回对应的alignment rect，需要注意的是这两个方法有互逆关系，你必须要保证frame和alignment rect能通过这两个方法互相转换。</p>
<p><img src="/images/Autolayout-1/pic_1-1.png" alt=""></p>
<h2 id="Baseline-alignment"><a href="#Baseline-alignment" class="headerlink" title="Baseline alignment"></a>Baseline alignment</h2><p>如果对自定义的view用<code>NSLayoutAttributeBaseline</code>的方式布局的话需要自己实现相关的方法。在iOS平台需要实现<code>viewForBaselineLayout</code>方法，方法返回的view的bottom edge将被用作baseline，系统默认实现是直接返回view本身。注意返回的view只能是此方法调用者本身或者子view。在OS X上你需要实现baselineOffsetFromBottom来返回基于view的bottom edge的一个offset，默认返回0。</p>
<h2 id="Phases-of-Display"><a href="#Phases-of-Display" class="headerlink" title="Phases of Display"></a>Phases of Display</h2><p>使用AutoLayout之后，把view显示到屏幕上面大体分成3步。</p>
<p><img src="/images/Autolayout-1/pic_1-2.png" alt=""></p>
<ol>
<li>Update constraints，就是更新约束，把所有的约束更新到最新状态；</li>
<li>Layout views，根据约束布局调整View之间的距离，大小；</li>
<li>Display，调用drawRect绘制view。</li>
</ol>
<p>下面来讲一下具体的工作流程。</p>
<p> <strong>Update constraints</strong> 这个过程是从底向上的(从<code>subview</code>到<code>supperview</code>)，你可以通过调用<code>setNeedsUpdateConstraints</code>来主动触发这个过程，你对constraint的任何更改都会导致系统自动调用这个方法。还可以重写<code>updateConstraints</code>方法来添加应用于自定义view内部的constraint。</p>
<p><strong>Layout view</strong> 这个过程是自顶向下的(从<code>super</code> view到<code>subview</code>)，这一步实际上是应用上一步的约束的结果的过程，根据约束调整view的<code>frame</code>(在OS X)，或者view的<code>center</code>和<code>bounds</code>(在iOS)。你可以调用<code>setNeedsLayout</code>方法来主动触发这个过程。</p>
<p><strong>Display</strong> 这个过程是也是自顶向下的，也可以调用<code>setNeedsDisplay</code>来主动触发这个过程，重写<code>drawRect:</code>来添加一些自定义的绘制代码这个相信大家都已经非常熟悉了。</p>
<p><strong>需要注意的是这3个步骤并不是严格按照顺序依次发生的。</strong>基于约束的布局是一个迭代的过程。layout的改变可以影响到生成上一次layout的constraint，当其他的layout改变后它能再次触发更新约束的过程。不过这个也存在死循环的风险，就是在其他的layout改变时调用你自己实现的<code>layoutSubviews</code>方法。</p>
<p><img src="/images/Autolayout-1/pic_1-3.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a style="text-decoration:none;color:#1D39DD" href="http://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/" target="_blank" rel="noopener"><br>《Advanced Auto Layout Toolbox》 - objc.io</a></li>
<li><a style="text-decoration:none;color:#1D39DD" href="http://studentdeng.github.io/blog/2014/06/13/auto-layout/" target="_blank" rel="noopener">《AutoLayout 相关概念介绍和动画demo》 - 不会开机的男孩</a></li>
<li><a style="text-decoration:none;color:#1D39DD" href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/Introduction/Introduction.html" target="_blank" rel="noopener">《Auto Layout Guide》 - Apple</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Autolayout笔记:自定义View]]></title>
      <url>http://petpwiuta.github.io/2017/07/13/Autolayout-%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589View/</url>
      <content type="html"><![CDATA[<h1 id="Autolayout笔记-自定义View"><a href="#Autolayout笔记-自定义View" class="headerlink" title="Autolayout笔记:自定义View"></a>Autolayout笔记:自定义View</h1><p>如果你想在自定义View里用Autolayout进行布局的话，有下面几个点需要注意：</p>
<ul>
<li>指定Intrinsic Content Size</li>
<li>区分frame和alignment rect</li>
<li>是否支持baseline-aligned布局</li>
<li>对子视图进行精确的布局控制</li>
</ul>
<p>下面将从这些方面逐步讲解。</p>
<h2 id="指定Intrinsic-Content-Size"><a href="#指定Intrinsic-Content-Size" class="headerlink" title="指定Intrinsic Content Size"></a>指定Intrinsic Content Size</h2><p>这部分的基本概念在上一篇文章已经讲过，这里不再赘述，主要注意三点：</p>
<ol>
<li>重写<code>intrinsicContentSize</code>方法。如果这个视图只有一个方向的尺寸设置了Intrinsic Size，那么为另一个方向的尺寸返回 <code>UIViewNoIntrinsicMetric</code>/<code>NSViewNoIntrinsicMetric</code>。</li>
<li>当view的某些属性的改变会影响到Intrinsic Content Size时，需要调用<code>invalidateIntrinsicContentSize</code>，例如当UILabel的text变化时，就需要重新计算Intrinsic Content Size。</li>
<li>当实现了<code>intrinsicContentSize</code>方法后，如果想进一步控制当View的实际大小和intrinsicContentSize`冲突时的行为，需要实现Compression Resistance和Content Hugging这方面的方法，具体做法请看<a href="http://blog.csdn.net/yongyinmg/article/details/39526207" target="_blank" rel="noopener" title="yongyinmg的专栏">这里</a></li>
</ol>
<h2 id="区分frame和alignment-rect"><a href="#区分frame和alignment-rect" class="headerlink" title="区分frame和alignment rect"></a>区分frame和alignment rect</h2><p>Autolayout系统的布局操作是基于alignment rect而非frame。绝大部分情况下它们是一样的，但是当你设置了<code>alignmentRectInsets</code>或者重写了<code>alignmentRectForFrame:</code>和<code>frameForAlignmentRect:</code>时就需要注意两者的差异。</p>
<p><img src="/images/Autolayout-2/pic_1-1.png" alt="img"></p>
<p>如图所示，Autolayout所有的约束（包括指定宽和高）都施加在alignment rect上，当你指定了<code>alignmentRectInsets</code>后View的frame是根据alignment rect和<code>alignmentRectInsets</code>计算出来的。上图里给view添加了left=80、top=100、width=100和height=100约束，使alignment rect上left为80、top为100、width为100、height为100，然后Autolayout系统根据alignmentRectInsets计算出view的frame，这里frame就是</p>
<p>{<br><code>alignmentRect.left-alignmentRectInsets.left</code>,<br><code>alignmentRect.top-alignmentRectInsets.top</code>,<br><code>alignmentRect.width+alignmentRectInsets.left+alignmentRectInsets.right</code>,<br><code>alignmentRect.height+alignmentRectInsets.top+alignmentRectInsets.bottom</code><br>}</p>
<p>即{<code>60</code>,<code>80</code>,<code>140</code>,<code>140</code>}</p>
<h2 id="是否支持baseline-aligned布局"><a href="#是否支持baseline-aligned布局" class="headerlink" title="是否支持baseline-aligned布局"></a>是否支持baseline-aligned布局</h2><p>如果需要支持baseline布局，就需要实现<code>viewForBaselineLayout</code>(iOS平台) ，系统默认实现只是简单地返回<code>self</code>。如果重写这个方法它返回的View的底边会作为baseline，而且这个View必须是你自定义View的子视图。在OS X中实现baseline布局需要重写<code>baselineOffsetFromBottom</code>返回一个从视图底部边缘开始的offset，默认返回0。</p>
<p>如果自定义View的frame和alignment rect不一样（设置了<code>alignmentRectInsets</code>或者重写了<code>alignmentRectForFrame:</code>和<code>frameForAlignmentRect:</code>）需要注意Autolayout布局是施加在alignment rect上的，自定义的view的最终位置是由<code>viewForBaselineLayout</code>和<code>alignmentRectInsets</code>共同决定的。</p>
<h2 id="如何对子视图进行精确的布局控制"><a href="#如何对子视图进行精确的布局控制" class="headerlink" title="如何对子视图进行精确的布局控制"></a>如何对子视图进行精确的布局控制</h2><p><strong>给子视图添加Constraints</strong> 官方建议的方法是在 <code>updateConstraints</code>里添加子视图的Constraints，而且要保证 <code>[super updateConstraints]</code>一定要在你自己的Constraints添加完之后再调用。而且在这个方法里不能<em>“invalidate any constraints”</em>如果Constraints失效时，需要移除对应的Constraints，并调用<code>setNeedsUpdateConstraints</code>来刷新。</p>
<p>如果是用添加Constraints的方式给子视图布局的话，这个自定义视图就仅仅在Autolayout环境下才能正常工作，因此可以重写<code>requiresConstraintBasedLayout</code>方法返回YES来告知系统必须使用Autolayout布局。</p>
<p><strong>子视图布局</strong> 回顾一下之前说起过的Autolayout布局的3个步骤，当Update constraints阶段结束后，就进入Layout view阶段，此时就会调用<code>layoutSubviews</code>方法来根据Constraints计算出来的结果来调整view的<code>bounds</code>和<code>center</code>。因此在<code>layoutSubviews</code>方法里可以对布局进行任意的调整。</p>
<p>最极端的情况是重写<code>layoutSubviews</code>/<code>layout</code>时不调用父类的实现。这就意味着系统虽然根据Constraints计算出视图树的位置，但你并没有应用计算的结果，换言之就是你在这个视图中完全放弃Autolayout布局，完全根据自己的意愿对子视图进行布局。</p>
<p>如果你仍然想使用Autolayout布局子视图，你可以先调用<code>[super layoutSubviews]</code>/<code>[super layout]</code>，然后对布局进行微调。这样可以创建一些通过Constraints无法实现的布局，比如，由到视图大小之间的关系或是视图之间间距的关系来定义的布局。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a style="text-decoration:none;color:#1D39DD" href="http://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/" target="_blank" rel="noopener"><br>《Advanced Auto Layout Toolbox》 - objc.io</a></li>
<li><a style="text-decoration:none;color:#1D39DD" href="http://blog.csdn.net/yongyinmg/article/details/39526207" target="_blank" rel="noopener">《AutoLayout中的Content Hugging 和 Content Compression Resistance》 - yongyinmg的专栏</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS平台Webview和原生代码交互]]></title>
      <url>http://petpwiuta.github.io/2017/02/20/iOS%25E5%25B9%25B3%25E5%258F%25B0Webview%25E5%2592%258C%25E5%258E%259F%25E7%2594%259F%25E4%25BB%25A3%25E7%25A0%2581%25E4%25BA%25A4%25E4%25BA%2592/</url>
      <content type="html"><![CDATA[<h1 id="iOS平台Webview和原生代码交互"><a href="#iOS平台Webview和原生代码交互" class="headerlink" title="iOS平台Webview和原生代码交互"></a>iOS平台Webview和原生代码交互</h1><p>最近遇到很多原生和前端进行交互的业务逻辑，前前后后做了一些调研。现在把常用的方法总结一下。<br>前端和原生交互大致分为这几种方式:拦截URL、WKWebView、JavaScriptCore，下面来分别说一下这几种方式的实现以及优缺点。</p>
<h2 id="1-拦截URL"><a href="#1-拦截URL" class="headerlink" title="1.拦截URL"></a>1.拦截URL</h2><h3 id="1-1-通过Webview的委托方法拦截"><a href="#1-1-通过Webview的委托方法拦截" class="headerlink" title="1.1 通过Webview的委托方法拦截"></a>1.1 通过Webview的委托方法拦截</h3><p>UIWebview<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">BOOL</span>)webView:(<span class="type">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="type">NSURLRequest</span> *)request navigationType:(<span class="type">UIWebViewNavigationType</span>)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">NSString</span> *url = request.<span class="type">URL</span>.absoluteString;</span><br><span class="line">	<span class="comment">//判断url特征，进行对应的逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>WKWebview<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)webView:(<span class="type">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="type">WKNavigationAction</span> *)navigationAction decisionHandler:(void (^)(<span class="type">WKNavigationActionPolicy</span>))decisionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">NSString</span> *url = navigationAction.request.<span class="type">URL</span>.absoluteString;</span><br><span class="line">    <span class="comment">//判断url特征，进行对应的逻辑处理</span></span><br><span class="line">    decisionHandler(<span class="type">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>优势：实现简单方便</li>
<li>缺点：如果是用GET请求的话在原生和webview之间传参会有长度限制。而POST请求的话需要只能在UIWebview上才能获取到请求体，在WKWebview里面是无法获取到POST请求体的。</li>
</ul>
<h3 id="1-2-使用WebViewJavascriptBridge"><a href="#1-2-使用WebViewJavascriptBridge" class="headerlink" title="1.2 使用WebViewJavascriptBridge"></a>1.2 使用WebViewJavascriptBridge</h3><p>这个是iOS上使用的比较多的js交互框架，也是基于拦截URL的方式来实现的。不过在自己公司项目中用的不多，所以没有做深入的了解。</p>
<h3 id="1-3-通过NSURLProtocol拦截"><a href="#1-3-通过NSURLProtocol拦截" class="headerlink" title="1.3 通过NSURLProtocol拦截"></a>1.3 通过NSURLProtocol拦截</h3><p>这个是利用了NSURLProtocol会拦截webview的网络请求而实现的，本质上和通过Webview的委托方法拦截差不多。不过据说WKWebView貌似不支持NSURLProtocol，没有做实验，具体是否可行还需要测试。</p>
<h2 id="2-WKWebView"><a href="#2-WKWebView" class="headerlink" title="2.WKWebView"></a>2.WKWebView</h2><p>iOS8，苹果新推出了WebKit，用WKWebView代替UIWebView和WebView。相关的使用和特性可以细读<a href="http://nshipster.cn/wkwebkit/" target="_blank" rel="noopener">WKWebView</a>和<a href="http://www.appcoda.com/webkit-framework-intro/" target="_blank" rel="noopener">A Look at the WebKit</a>、<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="noopener">WKWebView那些坑</a>(林泽水原创发表在bugly公众号上的一篇文章，基本上把它的缺陷都点出来了，入坑前必读)。</p>
<p>优点:功能比UIWebview强大很多，调用js的时候可以返回对象以及错误状态；而且js也可以直接反向回调<br>缺点:WKWebview的坑很多，参见上一段落提到的“<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="noopener">WKWebview那些坑</a>”</p>
<ul>
<li><p>App调用js<br>WKWebView调用js方法和UIWebView类似，一个是<code>evaluateJavaScript</code>，一个是<code>stringByEvaluatingJavaScriptFromString</code>。不过获取返回值的方式不同，WKWebView用的是闭包回调;UIWebview返回的是一个string。</p>
</li>
<li><p>js调用App<br>UIWebView中js是没办法直接回调App的(只能用url的方式间接回调)，而在WKWebView中有了改进。具体步骤分为App注册handler，js调用，App处理handler委托三个步骤</p>
<ol>
<li><p>注册handler</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config = <span class="type">WKWebViewConfiguration</span>()</span><br><span class="line"> <span class="comment">//注册js方法</span></span><br><span class="line">config.userContentController.addScriptMessageHandler(<span class="keyword">self</span>, name: <span class="string">"WebApp"</span>)</span><br><span class="line"> <span class="comment">// 初始化</span></span><br><span class="line">webView = <span class="type">WKWebView</span>(frame: <span class="keyword">self</span>.webWrap.frame, configuration: config)</span><br></pre></td></tr></table></figure>
</li>
<li><p>js调用<br>通过window.webkit.messageHandlers.WebApp找到之前注册的handler对象，然后调用postMessage方法把数据传到WebApp通过上一步的方法解析方法名和参数。WebApp是之前注册的name。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = &#123;</span><br><span class="line">                 'method' : 'hello',</span><br><span class="line">                 'param1' : 'liuyanwei',</span><br><span class="line">               &#125;;</span><br><span class="line"> window.webkit.messageHandlers.<span class="type">WebApp</span>.postMessage(message);</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理handler委托<br>之前初始化Webview时指定的MessageHandler要实现WKScriptMessageHandler的协议方法<code>userContentController(userContentController: WKUserContentController, didReceiveScriptMessage message: WKScriptMessage)</code>然后在这里面处理事件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">userContentController</span><span class="params">(<span class="number">_</span> userContentController: WKUserContentController, didReceive message: WKScriptMessage)</span></span> &#123;</span><br><span class="line">       <span class="comment">//根据传过来数据从而决定app调用的方法</span></span><br><span class="line">       <span class="keyword">let</span> dict = message.body <span class="keyword">as</span>! <span class="type">Dictionary</span>&lt;<span class="type">String</span>,<span class="type">Any</span>&gt;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="3-JavaScriptCore"><a href="#3-JavaScriptCore" class="headerlink" title="3.JavaScriptCore"></a>3.JavaScriptCore</h2><p>JavaScriptCore中类及协议：<br>JSContext：给JavaScript提供运行的上下文环境,通过-evaluateScript:方法就可以执行js代码<br>JSValue：封装了js与OC中的对应的类型，以及调用js的API等<br>JSManagedValue：管理数据和方法的类<br>JSVirtualMachine：处理线程相关，使用较少<br>JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议，在协议中声明的API都会在js中暴露出来，才能调用</p>
<ul>
<li><p>OC调用js<br>在JavaScriptCore中提供的调用js的方法<code>-(JSValue *)evaluateScript:(NSString *)script</code>方法就可以执行一段JavaScript脚本，并且如果其中有方法、变量等信息都会被存储在其中以便在需要的时候使用。<br>JSValue提供了<code>-(JSValue *)callWithArguments:(NSArray *)arguments</code>方法来将参数传进去调用方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个JSContext对象，就类似于js中的window</span></span><br><span class="line"> <span class="comment">// 只需要创建一次即可。</span></span><br><span class="line"><span class="type">JSContext</span> *context = [[<span class="type">JSContext</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"><span class="comment">// 执行一段js</span></span><br><span class="line">[context evaluateScript:@<span class="string">"function add(a, b) &#123; return a + b; &#125;"</span>];</span><br><span class="line"><span class="comment">// 根据下标取出方法</span></span><br><span class="line"><span class="type">JSValue</span> *add = context[@<span class="string">"add"</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">"Func: %@"</span>, add);</span><br><span class="line"><span class="comment">// 传入参数 调用取到的方法</span></span><br><span class="line"><span class="type">JSValue</span> *sum = [add callWithArguments:@[@(<span class="number">7</span>), @(<span class="number">21</span>)]];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">"Sum: %d"</span>,[sum toInt32]);</span><br><span class="line"><span class="comment">//OutPut:</span></span><br><span class="line"><span class="comment">// Func: function add(a, b) &#123; return a + b; &#125;</span></span><br><span class="line"><span class="comment">// Sum: 28</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>js调用OC<br>使用JavaScriptCore在JS端调用原生代码的时候主要有两种方式：block和方法注入。</p>
<ol>
<li><p>Block方式</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">JSContext</span> *context = [[<span class="type">JSContext</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">	<span class="comment">// 定义一个block</span></span><br><span class="line">	context[@<span class="string">"log"</span>] = ^() &#123;</span><br><span class="line">  	  <span class="type">NSArray</span> *args = [<span class="type">JSContext</span> currentArguments];</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">JSValue</span> *jsVal <span class="keyword">in</span> args) &#123;</span><br><span class="line">  	 		<span class="type">NSLog</span>(@<span class="string">"%@"</span>, jsVal);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">JSValue</span> *this = [<span class="type">JSContext</span> currentThis];</span><br><span class="line">		<span class="type">NSLog</span>(@<span class="string">"this: %@"</span>,this);</span><br><span class="line">		<span class="type">NSLog</span>(@<span class="string">"-------End Log-------"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用js执行log方法</span></span><br><span class="line"> [context evaluateScript:@<span class="string">"log('ider', [7, 21],&#123; hello:'world', js:100 &#125;);"</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC方法注入<br>这里需要原生自定义一个协议，并且它还需要遵守JSExport协议。协议里的方法，就是暴露给js端的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">protocol</span> <span class="title">JavaScriptObjectiveCDelegate</span> &lt;<span class="title">JSExport</span>&gt;</span></span><br><span class="line"><span class="class">-(<span class="title">void</span>)<span class="title">callWithDict</span>:(<span class="title">NSDictionary</span> *)<span class="title">params</span>;</span></span><br><span class="line"><span class="class">@<span class="title">end</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>然后自定义一个对象，让这个对象来实现上面所说的协议<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此模型用于注入JS的模型，这样就可以通过模型来调用方法。</span></span><br><span class="line">@interface <span class="type">HYBJsObjCModel</span> : <span class="type">NSObject</span> &lt;<span class="type">JavaScriptObjectiveCDelegate</span>&gt;</span><br><span class="line">@property (nonatomic, <span class="keyword">weak</span>) <span class="type">JSContext</span> *jsContext;</span><br><span class="line">@property (nonatomic, <span class="keyword">weak</span>) <span class="type">UIWebView</span> *webView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation <span class="type">HYBJsObjCModel</span></span><br><span class="line">- (void)callWithDict:(<span class="type">NSDictionary</span> *)params &#123;</span><br><span class="line"> <span class="type">NSLog</span>(@<span class="string">"Js调用了OC的方法，参数为：%@"</span>, params);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>对象实现完了，在哪里注入呢。在controller的webView加载完成后我们是通过webView的valueForKeyPath获取的，其路径为documentView.webView.mainFrame.javaScriptContext。这样就可以获取到js的context，然后为这个context注入我们的模型对象。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewDidFinishLoad:(<span class="type">UIWebView</span> *)webView </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">self</span>.jsContext = [webView valueForKeyPath:@<span class="string">"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line">  <span class="comment">// 通过模型调用方法，这种方式更好些。</span></span><br><span class="line">  <span class="type">HYBJsObjCModel</span> *model  = [[<span class="type">HYBJsObjCModel</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">  <span class="comment">// 模型</span></span><br><span class="line">  <span class="keyword">self</span>.jsContext[@<span class="string">"OCModel"</span>] = model;</span><br><span class="line">  model.jsContext = <span class="keyword">self</span>.jsContext;</span><br><span class="line">  model.webView = <span class="keyword">self</span>.webView;</span><br><span class="line">  <span class="comment">// 增加异常的处理</span></span><br><span class="line">  <span class="keyword">self</span>.jsContext.exceptionHandler = ^(<span class="type">JSContext</span> *context,   </span><br><span class="line"> <span class="type">JSValue</span> *exceptionValue) &#123;</span><br><span class="line">    context.exception = exceptionValue;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"异常信息：%@"</span>, exceptionValue);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对应的在js端调用的代码如下<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 100px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>OC方法注入<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Call OC method"</span> <span class="attr">onclick</span>=<span class="string">"OCModel.callWithDict()"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>JavaScript调用本地方法是在子线程中执行的，这里要根据实际情况考虑线程之间的切换。</p>
<h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考:"></a>相关参考:</h2><ul>
<li><a href="http://www.jianshu.com/p/0042d8eb67c0" target="_blank" rel="noopener">WebView与JS的几种交互</a></li>
<li><a href="http://www.jianshu.com/p/f896d73c670a" target="_blank" rel="noopener">Objective-C与JavaScript交互的那些事</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[《HTTP权威指南》笔记]]></title>
      <url>http://petpwiuta.github.io/2017/02/06/HTTP%25E6%259D%2583%25E5%25A8%2581%25E6%258C%2587%25E5%258D%2597/</url>
      <content type="html"><![CDATA[<h1 id="《HTTP权威指南》"><a href="#《HTTP权威指南》" class="headerlink" title="《HTTP权威指南》"></a>《HTTP权威指南》</h1><h3 id="第一部分-HTTP：Web的基础"><a href="#第一部分-HTTP：Web的基础" class="headerlink" title="第一部分 HTTP：Web的基础"></a>第一部分 HTTP：Web的基础</h3><h4 id="2-URL与资源"><a href="#2-URL与资源" class="headerlink" title="2 URL与资源"></a>2 URL与资源</h4><p>在Web和URL出现之前,人们要靠分类杂乱的应用程序来访问分布在网络中的数据。大多数人都不会幸运地拥有所有合适的应用程序,或者不能够理解,也没有足够的耐心来使用这些程序。</p>
<p>在URL出现之前,要想和朋友共享complete-catalog.xls文件,就得说这样一些话:“用FTP连接到 ftp.joes-hardware.com上。用匿名登录,然后输入你的用户名作为密码。变换到pub目录。转换为二进制模式。现在,可以将名为complete-catalog.xls的文件下载到本地文件系统,并在那里浏览这个文件了。”</p>
<p>现在,像网景的Navigator和微软的Internet Explorer这样的浏览器都将很多这样的功能捆绑成一个便捷包。通过URL,这些应用程序就可以通过一个接口,以统一的方式去访问许多资源了。只要说“将浏览器指向 ftp://ftp.lots-o-books.com/pub/complete-catalog.xls”就可以取代上面那些复杂的指令了。</p>
<p>URL 为应用程序提供了一种访问资源的手段。实际上,很多用户可能都不知道他们的浏览器在获取所请求资源时所使用的协议和访问方法。</p>
<p>有了Web浏览器,就不再需要用新闻阅读器来阅读因特网新闻,或者用FTP客户端来访问FTP服务器上的文件了,而且也无需用电子邮件程序来收发E-mail报文了。URL告知浏览器如何对资源进行访问和处理,这有助于简化复杂的网络世界。应用程序可以使用URL来简化信息的访问过程。</p>
<p>URL为用户及他们的浏览器提供了找到信息所需的所有条件。URL定义了用户所需的特定资源,它位于何处以及如何获取它。</p>
<h4 id="3-HTTP报文结构"><a href="#3-HTTP报文结构" class="headerlink" title="3 HTTP报文结构"></a>3 HTTP报文结构</h4><ul>
<li>HTTP报文由起始行、首部和报文体(可选)组成</li>
<li>HTTP的方法除了GET以外还有很多种，HEAD是代表让服务器只返回首部，一般用于查看资源的状态、尺寸、类型、是否存在等 。PUT是就是让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档,或者,如果那个URL已经存在的话,就用这个主体来替代它。Trace是用于诊断，收到Trace请求的服务端会把收到的请求完整地回传给客户端。OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法,或者对某些特殊资源支持哪些方法。服务端的响应中的Allow首部会列出所有支持的方法</li>
<li>HTTP的方法是可以扩展的，只要服务端能正常理解和反馈就行</li>
<li>常见状态码：1xx，信息状态码；2xx，成功状态码；3xx重定向状态码、注意当服务端有缓存内容的时候也会返回重定向状态码；4xx客户端错误码；5xx服务端错误码</li>
<li>HTTP的首部就是key-val形式的信息、可以分为通用、请求、响应、实体状态描述等几个大类</li>
</ul>
<h4 id="4-HTTP链接管理"><a href="#4-HTTP链接管理" class="headerlink" title="4 HTTP链接管理"></a>4 HTTP链接管理</h4><ul>
<li>TCP/IP是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集。TCP会把数据拆解成多个分组然后封装成IP数据包发送</li>
<li>一个IP数据包通常包含了一个IP分组首部(通常为20字节); 一个TCP段首部(通常为 20 字节); 一个TCP数据块(0 个或多个字节)。IP 首部包含了源和目的IP地址、长度和其他一些标记。TCP段的首部包含了TCP端口号、TCP 控制标记,以及用于数据排序和完整性检查的一些数字值</li>
<li>HTTP的延迟主要由于以下几个原因造成：（1）DNS查询没有命中 （2）TCP握手 （3）HTTP报文传输 （4）回送HTTP响应</li>
<li>TCP握手：（1）发送SYN=i （2）回送ACK=i+1，SYN=k （3）再发送ACK=k+1，以及载荷数据</li>
<li>延迟确认：在接收方接收到数据后都要发送回执，这个回执会在一定的窗口期(100-200ms)内寻找发送到接收方的数据包来搭便车。所以如果在一段时间内都是单项数据传输的话，可能会因此产生延迟确认现象</li>
<li>TCP慢启动：为了防止网络突然拥堵，TCP实现了慢启动机制。一个TCP连接会随着它成功发送的数据量的增大而提速</li>
<li>TCP的TCP_NODELAY参数：在TCP连接中尽量要发送全尺寸数据（局域网中是1500字节，广域网中为几百字节），所以TCP会启用Nagle算法来尽量把数据赞起来直到达到一个全尺寸的数据包为止。这里就会因为攒数据而产生延迟</li>
<li>当某个TCP端点关闭TCP连接时,会在内存中维护一个小的控制块,用来记录最近所关闭连接的IP地址和端口号。TIME_WAIT端口耗尽是很严重的性能问题,会影响到性能基准,但在现实中相对较少出现</li>
<li>对HTTP对应的TCP进行优化的方案：</li>
<li>并行连接：浏览器并发发起HTTP请求</li>
<li>TCP持久连接：HTTP1.1中默认使用了持久连接。而在HTTP1.0中需要加上Connection: Keep-Alive 首部</li>
<li>管道化连接：现在HTTP1.1中还可以在持久的TCP链接上发送多个请求</li>
</ul>
<h3 id="第二部分-HTTP结构"><a href="#第二部分-HTTP结构" class="headerlink" title="第二部分 HTTP结构"></a>第二部分 HTTP结构</h3><h4 id="5-Web服务器"><a href="#5-Web服务器" class="headerlink" title="5 Web服务器"></a>5 Web服务器</h4><ul>
<li>高性能的Web服务器能够同时支持数千条连接。 因为请求可能会在任意时刻到达,所以Web服务器会不停地观察有无新的Web请求。不同的Web服务器结构会以不同的方式为请求服务。服务器一般分为一下几种：（1）单线程Web服务器（2）多进程及多线程Web服务器 （3）复用 I/O 的服务器（4）复用的多线程Web服务器</li>
</ul>
<h4 id="7-缓存"><a href="#7-缓存" class="headerlink" title="7 缓存"></a>7 缓存</h4><ul>
<li>缓存命中、再验证命中。再验证命中需要向服务端请求数据，如果没有改变就是回传一个304、如果改变了就回传新内容并更新缓存、如果资源被删除就返回404并删除缓存</li>
<li>缓存在现实中是分层次的，如果小的缓存没有命中会把请求发向父级缓存</li>
<li>HTTP的资源附带有过期日期，它是通过Cache-Control首部和Expires 首部告知客户端。当缓存在过期日期之内可以无限次使用缓存，如果过期则会进行再验证。验证如果发现内容没有变化会获取新的首部（包含新的过期日期）</li>
<li>条件方法进行再验证：If-Modified-Since:日期  和 If-None-Match:ETag首部</li>
<li>ETag是为了解决经常被修改，但是文件本身内容却不会变化或者变化不大的情况。这时候通过Etag给资源一个标示符，然后通过标示符来检测文档是否变化</li>
<li>响应首部Cache-Control的取值:no-store禁止存储副本、no-cache会存储副本，但是只有进行再验证后才会回送、must-revalidate、max-age</li>
</ul>
<h3 id="第三部分-识别、认证与安全"><a href="#第三部分-识别、认证与安全" class="headerlink" title="第三部分 识别、认证与安全"></a>第三部分 识别、认证与安全</h3><ul>
<li>Cookies。服务端在相应首部使用Set-cookie可以让浏览器在本地设置Cookies</li>
<li>HTTP提供了一个原生的质询 / 响应(challenge/response)框架,简化了对用户的认<br>证过程。 但是这个认证安全性太弱了，所以现在提出了摘要认证。不过这个摘要认证的安全性也比较弱</li>
<li>数字签名。RSA的私钥和公钥可以互相加解密，RSA证明了签名的作者，而摘要算法保证了内容的真实性</li>
<li>数字证书的真实性由数字签名保证，而数字证书的作用是清晰而真实地公开一个实体所持有的RSA公钥</li>
<li>不要在自己的系统里面轻易的安装非CA签发的证书</li>
</ul>
]]></content>
      
        <categories>
            
            <category> CS基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[What's New in iOS]]></title>
      <url>http://petpwiuta.github.io/2016/10/08/What's-New-in-iOS10/</url>
      <content type="html"><![CDATA[<p>iOS10出现了很多新特性，这些新特性在官方的《What’s New in iOS》文章中做了一个综合性的简介。作为iOS开发者有必要对系统的新特性做一下跟进，所以就把上述提到的那篇文章翻译了一下，希望能对大家有所帮助！</p>
<h2 id="What’s-New-in-iOS"><a href="#What’s-New-in-iOS" class="headerlink" title="What’s New in iOS"></a>What’s New in iOS</h2><p>这篇文章汇总了在iOS10上引入的关于开发方面的重要新特性，也讲了一些关于新特性的细节。</p>
<p>如果想了解最前沿的新闻和已知的issues可以去看<a href="https://developer.apple.com/ios/download/" target="_blank" rel="noopener">iOS10 Release Notes</a>。至于iOS10新APIs列表，可以看<a href="https://developer.apple.com/library/content/releasenotes/General/iOS10APIDiffs/index.html" target="_blank" rel="noopener">iOS 10.0 API Diffs</a>。想了解新设备的细节可以去看<a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="noopener">iOS Device Compatibility Reference</a>。</p>
<p>关于Swift的更新可以看<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/WhatsNewXcode/introduction.html#//apple_ref/doc/uid/TP40004635-SW3" target="_blank" rel="noopener">Swift Language</a>和<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="noopener">The Swift Programming Language (Swift 3)</a>。</p>
<h3 id="触觉反馈"><a href="#触觉反馈" class="headerlink" title="触觉反馈"></a>触觉反馈</h3><p>在iPhone7和iPhone 7plus上，触觉反馈是一种获取用户注意力和增加交互沉浸感的新方式(可以理解为Force Touch的进一步运用。译者注)，像系统提供的pickers、switches和sliders都已经具有了触觉反馈特性。</p>
<p>UIKit引入了<code>UIFeedbackGenerator</code>类以及相关的3个子类来提供触觉反馈功能，不同的子类对应不同的触觉反馈场景，详情见下表。</p>
<p><img src="/images/Haptic-feedback.png" alt=""></p>
<p>另外你可以调用UIFeedbackGenerator的实例方法<code>prepare</code>来通知系统在经过一小段延迟后生成触觉反馈。</p>
<h3 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h3><p>Siri现在可以和App集成在一起了，不过只能支持特定类型的App。App集成Siri的方式是用<code>Intents</code>和<code>Intents UI frameworks</code>建立一个或多个应用扩展。下面是Siri支持的App类型：</p>
<ul>
<li>音频视频电话</li>
<li>短信</li>
<li>支付</li>
<li>照片搜索</li>
<li>打车</li>
<li>锻炼(可能是让手机开始记录你的健身活动，译者注)</li>
<li>调整设置(只能在支持CarPlay的汽车上，这个是提供给汽车厂商的)</li>
<li>预定餐厅(需要Apple的额外支持)</li>
</ul>
<p>当用户的Siri指令涉及到你的服务时，SiriKit会给你的App扩展发送一个<code>Intent</code>对象，它描述了用户的指令以及相关的信息。你需要根据<code>Intent</code>对象做出具体处理用户指令的应答。一般情况下Siri会接管所有的用户交互，但你也可以自定义UI来显示更多的信息以及增加品牌曝光 。</p>
<p>SiriKit提供了一个接收App内部发生的交互和活动数据的机制。并定义了一个interaction的对象，这个对象包含了之前说到的<code>Intent</code>对象以及诸如指令开始处理的时刻和持续时间等<code>intent-handling</code>过程的信息。如果App注册的可处理的活动类型刚好与用户的intent同名，即使你没有开发Siri应用扩展，系统也会启动你的App，并发送相关的Siri事件信息。</p>
<p>虽说用户通过地图App和Siri都可以打车，而且还能在地图App里订餐。但你的Intent扩展无论是处理从地图App发起的请求还是从Siri发起的，其方式完全一样。当然，你如果是自定义UI的话，仍可以根据不同的来源定制不同的UI。</p>
<p>想进一步了解SiriKit并给用户一种新方式使用你的服务，可以看<a href="https://developer.apple.com/library/content/documentation/Intents/Conceptual/SiriIntegrationGuide/index.html#//apple_ref/doc/uid/TP40016875" target="_blank" rel="noopener">SiriKit Programming Guide</a>。想了解如何开发<code>Intents</code>扩展可以看<a href="https://developer.apple.com/reference/intents" target="_blank" rel="noopener">Intents Framework Reference</a>和<a href="https://developer.apple.com/reference/intentsui" target="_blank" rel="noopener">Intents UI Framework Reference</a>。</p>
<h3 id="基于场景的智能推荐"><a href="#基于场景的智能推荐" class="headerlink" title="基于场景的智能推荐"></a>基于场景的智能推荐</h3><p>iOS10引入了一种新的方式来增加用户体验，那就是基于场景的智能推荐。如果你提供适当的场景信息的话，系统就可以在合适的时机展示你的App。如果你曾适配过iOS9的App搜索，你就明白如何通过Spotlight、Safari搜索结果、Handoff和Siri建议来展示App内容数据。在iOS10以后，你可以提供用户在App内的活动信息来帮助系统在其他地方展示你的App，例如键盘的词汇联想区、地图、CarPlay、应用切换列表(双击Home键切换应用的那个界面，译者注)、Siri交互界面和锁屏界面(仅对音视频App)。这些和系统深度整合的功能由NSUserActivity，Web<br>markup，Core Spotlight、MapKit、UIKit和Media Player等技术提供。</p>
<p>在iOS10，NSUserActivity对象包含了mapItem属性，它能让你提供用于其他场景的位置信息。例如，你的App显示了一个酒店的信息，你可以在mapItem属性里保存酒店的地理位置信息，当用户切换到一个行程规划App中时，你刚刚保存的酒店地理位置信息会自动提供给它。如果你的App支持应用内搜索，你可以在CSSearchableItemAttributeSet中使用新的基于文本的地址属性，比如<code>thoroughfare</code>和<code>postalCode</code>，来完整地描述用户想去的地理位置。另外注意当你使用mapItem属性时，系统会自动把它的内容填充到contentAttributeSet属性中。</p>
<p>如果要共享一个地理位置信息给系统的话，一定要提供经纬度信息，以及指定CSSearchableItemAttributeSet中的地址属性。另外也建议提供 namedLocation属性，用户能看到位置的名字当然是最好的；此外还有phoneNumbers属性，如果指定了它的值的话，用户可以直接用Siri拨打这个电话。</p>
<p>在iOS9上，给应用内容的镜像站点上添加Web Markup信息可以让用户在Spotlight和Safari搜索结果中直接查看App的内容数据。在iOS10上你可以使用定义在Schema.org上的地理位置相关的词汇，如PostalAddress来进一步提高用户体验。例如，当用户查看你的网站上显示的一个位置时，如果用户切换到地图应用，系统会自动显示这个位置的提示。对于Schema.org上的词汇，Safari同时支持JSON-LD和Micordata编码。</p>
<p>UIKit在UITextInputTraits协议中引入了textContentType属性。你可以告诉系统希望用户在文本框所输入内容的含义。当你提供了这些信息以后，系统能在某些场合自动切换到适当类型的键盘以及增进智能推荐的效果。例如，如果你指定UITextContentTypeFullStreetAddress属性来告诉系统你希望用户输入的是一个地址，系统就会自动提示用户最近所浏览的地址信息。</p>
<p>如果你是媒体播放器类型的App，并且使用了<code>MPPlayableContentManager</code>APIs，在iOS10以后，能让用户在锁屏界面就直接通过你的App播放媒体。</p>
<p>如果你是ride-sharing类型的App，并且使用了<code>MKDirectionsRequest</code>API，iOS10以后，当用户想开始行程时能在应用切换界面显示这个App。想要注册ride-share provider，只需要在Info.plist文件中增加<code>MKDirectionsApplicationSupportedModes</code>字段并把值设为<code>MKDirectionsModeRideShare</code>就可以了。如果你的App仅仅支持ride sharing，系统显示的建议的文字会以“Get a ride to…”开头；如果你的App同时支持ride sharing和其他种类的交通路线(比如骑行或者驾车)系统显示的建议的文字会以“Get directions to…”开头。注意你接收到的MKMapItem对象可能不包含经纬度信息，需要手动获取。</p>
<h3 id="Messages-App扩展"><a href="#Messages-App扩展" class="headerlink" title="Messages App扩展"></a>Messages App扩展</h3><p>在iOS10后，你可以创建和Messages App进行交互的App扩展。它能让用户发送文本、表情、媒体文件以及已读反馈。如果把扩展标记为<code>#images</code>类型，那扩展内的表情(图片)资源就会成为公开的，苹果可以对这些公开的表情进行索引和热度排行。</p>
<p>Messages App的扩展有下面两种：</p>
<ul>
<li>表情包</li>
<li>在Messages App内能展现自定义UI的<code>iMessage app</code>，能让用户浏览表情、文本和媒体文件，并创建、发送以及更新消息</li>
</ul>
<p><code>iMessage app</code>可以让用户直接在Messages App内部直接搜索应用内容的镜像站点上的图片。</p>
<p>创建表情包很简单根本不用敲代码，只要在Xcode里把表情包图片文件夹拖到asset catalog中就行了。</p>
<p>开发一个<code>iMessage app</code>需要使用<code>Messages.framework</code>，Messages framework的详细信息参见<a href="https://developer.apple.com/reference/messages" target="_blank" rel="noopener">Messages Framework Reference</a>。至于如何创建一个扩展可以看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="noopener">App Extension Programming Guide</a>。</p>
<p><code>#images app</code>展示了当前最火的表情。你在扩展中公开的表情资源经过苹果的爬虫(如Applebot)收录后会被展示到<code>#images app</code>里。经过下面这几个步骤就能把扩展注册为<code>#images app</code>类型：</p>
<ul>
<li>创建一个<code>iMessage app</code></li>
<li>在app的entitlements里添加<code>com.apple.developer.associated-domains</code>字段。包含了你想要被收录的表情(图片)所在的站点的域名列表。每个域名都需要以<code>spotlight-image-search</code>开头，例如<code>spotlight-image-search:yourdomain.com</code></li>
<li>表情(图片)所在的站点上添加一个以<code>apple-app-site-association</code>命名的字典文件(key-val结构，比如json，译者注)。里面需要包含你的app ID(以team ID或者app ID为前缀)和bundle ID。一个<code>#images</code>索引最多能包含500个paths和patterns(website paths的例子可以看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW4" target="_blank" rel="noopener">Creating and Uploading the Association File</a>)</li>
<li>允许Applebot进行收录(参见<a href="https://support.apple.com/en-us/HT204683" target="_blank" rel="noopener">About Applebot</a>)</li>
</ul>
<h3 id="推送通知"><a href="#推送通知" class="headerlink" title="推送通知"></a>推送通知</h3><p>iOS10引入了全新的推送通知框架(UserNotifications.framework)，它统一了本地通知和远程推送通知。你可以用新框架根据时间和地点等条件触发的本地通知。现在这个框架还能在设备收到通知后让你拦截和修改通知的内容。</p>
<p>除了上面说的外在iOS10还引入了推送通知UI框架(UserNotificationsUI.framework) ，当通知到达设备上时可以显示自定义的UI了。而且可以开发对应的扩展来响应用户对通知的操作。</p>
<h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><p>iOS10引入了新的连续语音识别框架<code>Speech.framework</code>，除了语音识别外还能把语音转换成文字。另外语音识别和录音可以同时进行。下面是示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let recognizer &#x3D; SFSpeechRecognizer()</span><br><span class="line">let request &#x3D; SFSpeechURLRecognitionRequest(url: audioFileURL)</span><br><span class="line">recognizer?.recognitionTask(with: request, resultHandler: &#123; (result, error) in</span><br><span class="line">     print (result?.bestTranscription.formattedString)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>语音识别中为了提高识别率，苹果会把用户的语音数据临时保存在服务器上，所以算是获取到了用户的隐私数据(关于访问用户的隐私数据的细节可以看<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW3" target="_blank" rel="noopener">Security and Privacy Enhancements</a>)，所以这里需要用户的授权。获取语音识别的授权需要在Info.plist文件里增加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW52" target="_blank" rel="noopener">NSSpeechRecognitionUsageDescription</a>字段，内容就是你对数据用途的描述。</p>
<p>另外当你在进行语音识别时记得加上明确的UI引导，这样用户体验会更好。</p>
<h3 id="广色域"><a href="#广色域" class="headerlink" title="广色域"></a>广色域</h3><p>系统中大量的图形组件，如Core Graphics、Core Image、Metal和AVFoundation等现在支持更大的色彩空间。UIKit现在已经集成了这个新特性。<br>下面是使用广色域特性的最佳实践：</p>
<ul>
<li>在iOS10上，<code>[UIColor](https://developer.apple.com/reference/uikit/uicolor)</code>使用了扩展的sRGB色彩空间，initializers no longer clamp raw component values to between 0.0 and 1.0. If your app relies on UIKit to clamp component values (whether you’re creating a color or asking a color for its component values), you need to change your app’s behavior when you link against iOS 10.</li>
<li>iPad Pro(9.7寸)上在UIView自定义draw方法时，色彩空间默认就是扩展的sRGB</li>
<li>如果需要渲染自定义图片对象，使用<a href="https://developer.apple.com/reference/uikit/uigraphicsimagerenderer" target="_blank" rel="noopener">UIGraphicsImageRenderer</a>来控制生成的位图的色彩空间是extended-range还是standard-range</li>
<li>如果在支持宽色域的设备上用Core Graphics、Metal等底层API处理图片，应该用扩展的色彩空间并且要用16位的floating-point component values. When clamping of color values is necessary, you should do so explicitly</li>
<li>Core Graphics、Core Image和Metal执行Shaders时提供了转换颜色和图片的色彩空间的功能</li>
</ul>
<h3 id="True-Tone-Display适配"><a href="#True-Tone-Display适配" class="headerlink" title="True Tone Display适配"></a>True Tone Display适配</h3><p>True Tone display利用环境光传感器根据用户周边的光照自动调整色彩和显示强度。为了True Tone在标准色上产生的色彩偏移不会给应用带来负面影响，可以在Info.plist添加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW31" target="_blank" rel="noopener">UIWhitePointAdaptivityStyle</a>字段，并指定适当的类型，例如：</p>
<ul>
<li>如果你的应用是照片编辑类的，对色彩精准地还原才是重中之重。可以指定类型为UIWhitePointAdaptivityStylePhoto来减少True Tone产生的色彩偏移</li>
<li>如果你的应用是阅读类的，舒适的阅读环境对用户最重要。可以指定指定类型为UIWhitePointAdaptivityStyleReading来增加True Tone产生的色彩偏移</li>
</ul>
<h3 id="App-Search增强"><a href="#App-Search增强" class="headerlink" title="App Search增强"></a>App Search增强</h3><p>iOS10上Core Spotlight框架得到了一些增强：</p>
<ul>
<li>应用内搜索</li>
<li>Search continuation</li>
<li>Crowdsourcing deep link popularity with differential privacy</li>
<li>Visualization of validation results</li>
</ul>
<p>新的<a href="https://developer.apple.com/reference/corespotlight/cssearchquery" target="_blank" rel="noopener">CSSearchQuery</a>类支持应用内搜索。使用这个API可以避免自己维护内容索引，并能马上能利用Spotlight技术带来的便利，类似于，邮件、短信和备忘录的搜索，这个完全是在应用内进行。</p>
<p>在iOS9，通过搜索APIs(比如Core Spotlight、NSUserActivity还有web markup)来索引应用内的内容后，用户就能通过Spotlight和Safari搜索来使用它。在iOS10上，Core Spotlight功能进一步增强。当用户通过搜索特定内容启动App时，可以得知用户搜索的内容，并显示出相应的数据。在Info.plist中增加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW43" target="_blank" rel="noopener">CoreSpotlightContinuation</a>字段并设置为YES就可以启用这个特性。另外需注意如果开启这个特性需要实现对<a href="https://developer.apple.com/reference/corespotlight/csquerycontinuationactiontype" target="_blank" rel="noopener">CSQueryContinuationActionType</a>类型的activity continuation的处理逻辑。<a href="https://developer.apple.com/reference/uikit/uiapplicationdelegate/1623072-application" target="_blank" rel="noopener">application:continueUserActivity:restorationHandler:</a>方法回传的<a href="https://developer.apple.com/reference/foundation/nsuseractivity" target="_blank" rel="noopener">NSUserActivity</a>对象包含了用户信息，通过<a href="https://developer.apple.com/reference/corespotlight/cssearchquerystring" target="_blank" rel="noopener">CSSearchQueryString</a>可以取到用户的搜索关键字。</p>
<p>iOS10引入了更具隐私的技术来提高你的App内容在用户搜索中的曝光率。新引入的<a href="https://developer.apple.com/reference/foundation/nsuseractivity/1414701-iseligibleforpublicindexing" target="_blank" rel="noopener">eligibleForPublicIndexing</a>属性可以告诉系统是否把指定内容设为公共的(所有iOS用户都可以查看,译者注)，当用户使用App或者<a href="https://developer.apple.com/reference/foundation/nsuseractivity" target="_blank" rel="noopener">NSUserActivity</a>包含一个<code>deep link</code>时，如果它们的<code>eligibleForPublicIndexing</code>被设置成了YES，系统就会把对应的数据经过信息哈希算法生成内容摘要(内容摘要是不包含用户数据的字符串，不能反向还原出原内容，译者注)，然后发送到苹果的服务器。苹果的服务器只用统计这些内容摘要的使用频率就能算出热度排行，从而对搜索进行排名，这个过程完全不涉及到具体的用户数据。</p>
<p>当你用App搜索有效性验证工具测试你的website markup和deep links时，它现在有更人性化的视觉展示了。包括支持的markup(具体定义在<a href="http://schema.org/" target="_blank" rel="noopener">Schema.org</a>上)。这个工具能查看Applebot对你的应用内容的具体收录信息，类似于title、description、URL以及其他的元素。App搜索有效性验证工具在这里：<a href="https://search.developer.apple.com/appsearch-validation-tool。如果想了解如何支持`deep" target="_blank" rel="noopener">https://search.developer.apple.com/appsearch-validation-tool。如果想了解如何支持`deep</a> links<code>和</code>markup`可以看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8" target="_blank" rel="noopener">Mark Up Web Content</a>。</p>
<p>想要了解如何让Messages app内的表情(图片)可以被外部搜索到，可以看<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW4" target="_blank" rel="noopener">Integrating with the Messages App</a>。</p>
<h3 id="Widget增强"><a href="#Widget增强" class="headerlink" title="Widget增强"></a>Widget增强</h3><p>iOS10重新设计了锁屏界面，现在从锁屏界面右滑就能看见widgets。为了保证widget在各种背景下都好看，需要根据情况调用<a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1771278-widgetprimaryvibrancyeffect" target="_blank" rel="noopener">widgetPrimaryVibrancyEffect</a>或<a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1771277-widgetsecondaryvibrancyeffect" target="_blank" rel="noopener">widgetSecondaryVibrancyEffect</a>(这两个方法会替代即将废弃的<a href="https://developer.apple.com/reference/uikit/uivibrancyeffect/1613917-notificationcentervibrancyeffect" target="_blank" rel="noopener">notificationCenterVibrancyEffect</a>)。另外widgets现在新增加了显示模式的概念(通过<a href="https://developer.apple.com/reference/notificationcenter/ncwidgetdisplaymode" target="_blank" rel="noopener">NCWidgetDisplayMode</a>属性获取显示模式)，需要你根据用户选择的模式显示合适的内容。(现在就是”展开”、”收起”两种模式，需要根据用户的选择，来显示较少或更多的内容，译者注)。</p>
<h3 id="Apple-Pay增强"><a href="#Apple-Pay增强" class="headerlink" title="Apple Pay增强"></a>Apple Pay增强</h3><p>iOS10以后用户可以在网站上使用Apple Pay，还能直接用Siri和地图下达支付命令。对于开发者而言，iOS10引入了同时支持iOS和watchOS的新API，并且支持随时更换银行卡和新沙盒测试环境。</p>
<p>iOS10引入的新API可以直接集成到网站上，当网站集成好Apple Pay后，用户通过Safari(iOS和macOS都行)浏览时就能用Apple Pay付款。想要了解更多关于网站集成Apple Pay的知识可以看<a href="https://developer.apple.com/reference/applepayjs" target="_blank" rel="noopener">ApplePay JS Framework Reference</a>。</p>
<p>PassKit框架(PassKit.framework)引入的新API不依赖UIkit。比如PKPaymentAuthorizationController和PKPaymentAuthorizationControllerDelegate的特性是由PKPaymentAuthorizationViewController和它的委托来实现的。但它也不需要导入UIKit。 尽管是为了让watchOS和其他情况使用Apple Pay而设计的这些API，但建议实现一套统一的代码框架来适配Apple Pay的所有使用场景(Siri、网站、地图，译者注)。想要了解更多关于Siri集成的知识可以看<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW5" target="_blank" rel="noopener">SiriKit</a>。</p>
<p>PassKit还有一项新特性。就是让发卡商家从他们的应用中显示卡片。<code>PKPaymentButtonTypeInStore</code>类型的button可以给卡片显示Apple Pay的标志。实现<code>presentPaymentPass:</code>方法就能显示卡片。(<code>presentPaymentPass:</code>方法在<a href="https://developer.apple.com/reference/passkit/pkpasslibrary" target="_blank" rel="noopener">PKPassLibrary</a>中定义)。</p>
<p>当有新的行银片绑定时，应用能自动适应而不需要重新发版。<a href="https://developer.apple.com/reference/passkit/pkpaymentrequest/1833288-availablenetworks" target="_blank" rel="noopener">availableNetworks</a>方法可以查询当前可用的银行卡。另外<a href="https://developer.apple.com/reference/passkit/pkpaymentrequest/1619329-supportednetworks" target="_blank" rel="noopener">supportedNetworks</a>属性可以限定所支持的银行卡。想了解更多关于Apple Pay的知识可以去：<a href="https://developer.apple.com/apple-pay/。" target="_blank" rel="noopener">https://developer.apple.com/apple-pay/。</a></p>
<p>iOS10引入了新的测试技术，可以直接在设备上添加测试卡片。测试环境返回加密的支付数据。需要下面几步来开启测试环境：<br>1<em> 在iTunes Connect上新建一个iCloud测试账号<br>2</em> 在设备上登录测试账号<br>3<em> 设置这个账号所在的地区<br>4</em> 使用<a href="https://developer.apple.com/apple-pay/上列出的银行卡测试" target="_blank" rel="noopener">https://developer.apple.com/apple-pay/上列出的银行卡测试</a></p>
<p>注意：如果切换iCloud账号，测试环境也会自动切换。所以最好用真实的卡片在生产环境上测试。</p>
<h3 id="安全和隐私的增强"><a href="#安全和隐私的增强" class="headerlink" title="安全和隐私的增强"></a>安全和隐私的增强</h3><p>iOS10增强了代码的安全性以及用户数据的安全性。想了解更多可以看：<a href="https://developer.apple.com/security/。" target="_blank" rel="noopener">https://developer.apple.com/security/。</a></p>
<ul>
<li>如果应用启用了ATS，但又想在加载web内容的时候使用非安全连接。只需要在Info.plist中添加<code>NSAllowsArbitraryLoadsInWebContent</code>字段就行</li>
<li><code>SecKey</code>API增强了非对称加密key的生成。请使用<code>SecKey</code>API来替代废弃的Common Data Security Architecture (CDSA) APIs</li>
<li>SSL/TLS中已经默认禁用RC4对称加密算法了，而且Secure Transportations API未来也不会再支持SSLv3。建议尽可能地使用SHA-1和3DES加密算法</li>
<li>在iOS10上出现了可以在多台登录iCloud的设备上互相复制粘贴的功能(<a href="https://developer.apple.com/reference/uikit/uipasteboard" target="_blank" rel="noopener">UIPasteboard</a>)。你可以针对指定的设备把剪贴板功能做限制以及给剪贴板加上超时时间(超过时间不使用里面的内容，剪贴板就会被清空)。另外具名剪贴板不再被持久化了，作为替代你现在可以用共享式的容器。还有就是”Find”剪贴板(通过<a href="https://developer.apple.com/reference/uikit/uipasteboardnamefind" target="_blank" rel="noopener">UIPasteboardNameFind</a>获取)从iOS10开始被禁用了。</li>
<li>现在访问用户受保护的数据都需要在Info.plist里添加对应的字段，并附上对数据的用途的描述。例如如果要访问日历数据的话就需要在Info.plist中添加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW15" target="_blank" rel="noopener">NSCalendarsUsageDescription</a>并写上你用日历数据的目的。如果未经允许就读取数据会造成应用闪退。</li>
</ul>
<h3 id="CallKit"><a href="#CallKit" class="headerlink" title="CallKit"></a>CallKit</h3><p>CallKit框架(CallKit.framework)现在允许VoIP应用的呼入直接通过系统来电UI展现出来。这样用户就能直接在锁屏界面接听或拒绝VoIP呼叫，并且这个呼叫会被记录在最近通话之中。</p>
<p>CallKit还引入了来电拦截和骚扰电话识别扩展。利用这些扩展可以根据系统给定的电话号码给出具体的提示或者告诉系统这个电话是否该被拦截。</p>
<h3 id="News-Publisher增强"><a href="#News-Publisher增强" class="headerlink" title="News Publisher增强"></a>News Publisher增强</h3><p>News Publisher现在可以很容易地通过Apple News向用户提供新闻、杂志以及web内容。无论是主流杂志和新闻机构还是独立的记者和博客，任何人都可以注册为News Publisher。想要了解更多关于这方面的信息可以看：<a href="https://newsresources.apple.com。" target="_blank" rel="noopener">https://newsresources.apple.com。</a></p>
<h3 id="视频订阅账户"><a href="#视频订阅账户" class="headerlink" title="视频订阅账户"></a>视频订阅账户</h3><p>iOS10引入了视频订阅账户框架(VideoSubscriberAccount.framework)来帮助支持授权流媒体/视频的应用从有线电视/卫星电视供应商获取授权。使用这个框架可以达到多个视频应用一键登录的效果(必须是支持VideoSubscriberAccount的应用)，大大提升了用户体验。</p>
<h3 id="App扩展"><a href="#App扩展" class="headerlink" title="App扩展"></a>App扩展</h3><p>iOS10引入了多个新类型的App扩展：</p>
<ul>
<li>Call Directory</li>
<li>Intents</li>
<li>Itents UI</li>
<li>Messages</li>
<li>Notification Content</li>
<li>Notification Service</li>
<li>Sticker Pack</li>
</ul>
<p>另外，iOS10还包含了对第三方键盘的一些增强：</p>
<ul>
<li>可以用<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy" target="_blank" rel="noopener">UITextDocumentProxy </a>来检测用户正在输入的语言，并据此调整键盘。</li>
<li>新增的handleInputModeListFromView:withEvent:方法能显示系统的键盘切换按钮</li>
</ul>
<p>虽然你能自定义输入法切换按钮的外观，但这个按钮一定要放到和系统键盘一样的位置。想要了解关于应用扩展的信息可以看：<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="noopener">App Extension Programming Guide</a></p>
<h3 id="其他框架的改动"><a href="#其他框架的改动" class="headerlink" title="其他框架的改动"></a>其他框架的改动</h3><p>除了上述的主要改动外，iOS10还包含了其他的改进。</p>
<h5 id="AVFoundation-Camera-Capture"><a href="#AVFoundation-Camera-Capture" class="headerlink" title="AVFoundation Camera Capture"></a>AVFoundation Camera Capture</h5><p>AVFoundation框架(AVFoundation.framework)中的媒体采集组件包含了多项重要改进。</p>
<h6 id="Dual-Camera-and-Device-Discovery"><a href="#Dual-Camera-and-Device-Discovery" class="headerlink" title="Dual Camera and Device Discovery"></a>Dual Camera and Device Discovery</h6><p>iPhone7 plus的相机有2个镜头，一个为广角镜一个为长焦镜，但它们组合在一起成为一个双镜头相机。当使用这个双镜头相机时，iOS根据环境和设置自动地使用两者或者其中某一个。当你通过<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice" target="_blank" rel="noopener">AVCaptureDevice</a>来拍照或录视频时可以选择双镜头相机(iOS自动调整两个镜头的使用)或者单独指定是广角镜还是长焦镜。</p>
<p>在iOS10以后可以通过下面的方法使用摄像机：</p>
<ul>
<li>调用<code>defaultDeviceWithDeviceType:mediaType:position:</code>方法。  (指定<code>AVCaptureDeviceTypeBuiltInDuoCamera</code>参数启用双镜头相机。如果返回值为nil，说明设备上没有双镜头相机；指定<code>AVCaptureDeviceTypeBuiltInWideAngleCamera</code>参数启用默认的后置相机)</li>
<li>实例化一个<code>AVCaptureDeviceDiscoverySession</code>对象，指定相关的参数，并从设备列表中选择想要使用的摄像机</li>
</ul>
<p>注意：<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice" target="_blank" rel="noopener">AVCaptureDevice</a>的<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice/1386237-devices" target="_blank" rel="noopener">devices</a>和<a href="https://developer.apple.com/reference/avfoundation/avcapturedevice/1390520-deviceswithmediatype" target="_blank" rel="noopener">devicesWithMediaType:</a>方法在iOS10被弃用。并且不提供访问双镜头相机和广角镜相机的方法。</p>
<p>当使用双镜头相机时，RAW格式和大部分手动控制特性都暂时不可用。这两个特性必须在单镜头相机上才能开启。关于每个镜头的性能参数可以看<a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="noopener">iOS Device Compatibility Reference</a>。</p>
<h6 id="New-Photo-Capture-API"><a href="#New-Photo-Capture-API" class="headerlink" title="New Photo Capture API"></a>New Photo Capture API</h6><p>新的<a href="https://developer.apple.com/reference/avfoundation/avcapturephotooutput" target="_blank" rel="noopener">AVCapturePhotoOutput</a>类为图片处理提供了统一的方案。这个方案能提供更细粒度的控制，监听整个采样过程以及支持新的Live Photos、RAW格式等新特性。建议用它替换<a href="https://developer.apple.com/reference/avfoundation/avcapturestillimageoutput" target="_blank" rel="noopener">AVCaptureStillImageOutput</a>(AVCaptureStillImageOutput在iOS10已经废弃)。</p>
<h6 id="Wide-Color"><a href="#Wide-Color" class="headerlink" title="Wide Color"></a>Wide Color</h6><p>摄像机采样现在已经支持输出宽色域数据(需要在支持宽色域的设备，译者注)。默认情况下<a href="https://developer.apple.com/reference/avfoundation/avcapturesession" target="_blank" rel="noopener">AVCaptureSession</a>会自动配置是否启用宽色域，具体的细节可以看：<a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="noopener">iOS Device Compatibility Reference</a></p>
<h5 id="AVFoundation-Media"><a href="#AVFoundation-Media" class="headerlink" title="AVFoundation Media"></a>AVFoundation Media</h5><p>AVFoundation框架(AVFoundation.framework)中的媒体播放和编辑组件包含了下列改进：</p>
<ul>
<li>不用再根据内容是视频文件还是HTTP流媒体来设置不同的<a href="https://developer.apple.com/reference/avfoundation/avplayeritem" target="_blank" rel="noopener">AVPlayerItem</a>了。在iOS10以后，仅仅需要设置<a href="https://developer.apple.com/reference/avfoundation/avplayer/1388846-rate" target="_blank" rel="noopener">rate</a>属性，AVFoundation会自动进行后续的配置</li>
<li>新的<a href="https://developer.apple.com/reference/avfoundation/avplayerlooper" target="_blank" rel="noopener">AVPlayerLooper</a>类让重复播放媒体的部分内容变更容易(就是复读机功能，译者注)</li>
<li>用<a href="https://developer.apple.com/reference/avfoundation/avassetdownloadurlsession" target="_blank" rel="noopener">AVAssetDownloadURLSession</a>类来离线媒体资源，包括HTTP流媒体等(离线到设备上，然后无网的时候也能看，译者注)。它跟FairPlay Streaming结合在一起时还能离线加密的HTTP流媒体</li>
</ul>
<h5 id="AVKit"><a href="#AVKit" class="headerlink" title="AVKit"></a>AVKit</h5><p>AVKit框架(AVKit.framework)，包含了<code>updatesNowPlayingInfoCenter</code>属性，可以调用它来刷新<code>Now Playing Info Center</code>。</p>
<h5 id="Core-Data"><a href="#Core-Data" class="headerlink" title="Core Data"></a>Core Data</h5><p>Core Data框架(CoreData.framework)包含了下列改进：</p>
<ul>
<li><a href="https://developer.apple.com/reference/coredata/nspersistentstorecoordinator" target="_blank" rel="noopener">NSPersistentStoreCoordinator</a>现在维护了一个SQLite连接池。<a href="https://developer.apple.com/reference/coredata/nsmanagedobjectcontext" target="_blank" rel="noopener">NSManagedObjectContext</a>对象(没有父MOCs)透明地支持并发查询and faulting without serializing against each other.</li>
<li><a href="https://developer.apple.com/reference/coredata/nsmanagedobjectcontext" target="_blank" rel="noopener">NSManagedObjectContext</a>对象和SQLite存储在WAL文件里，<code>journal_model</code>支持现在支持query generation特性。These allow a MOC to be pinned to a version of the database at a point in time and perform all future fetching and faulting against that version of the database. Pinned MOCs are moved to the most recent transaction with any save, and query generations do not survive the process’s life time.</li>
<li>新的<a href="https://developer.apple.com/reference/coredata/nspersistentcontainer" target="_blank" rel="noopener">NSPersistentContainer</a>类提供了高层API来维护对<code>NSPersistentStoreCoordinator</code>和<a href="https://developer.apple.com/reference/coredata/nsmanagedobjectmodel" target="_blank" rel="noopener">NSManagedObjectModel</a>以及其他配置源的引用</li>
<li>Core Data现在进一步地与Xcode集成在一起。并能自动生成和更新<a href="https://developer.apple.com/reference/coredata/nsmanagedobject" target="_blank" rel="noopener">NSManagedObject</a></li>
<li><code>NSManagedObject</code>包含了多个获取和创建其子类的快捷方法。<code>NSManagedObject</code> subclasses that have a 1:1 relationship with an entity now support <code>entity</code>.</li>
<li>Core Data对API进行了一些Swift friendly式的调整，包括像参数化的<a href="https://developer.apple.com/reference/coredata/nsfetchrequest" target="_blank" rel="noopener">NSFetchRequest</a>对象</li>
</ul>
<p>更多信息参见<a href="https://developer.apple.com/reference/coredata" target="_blank" rel="noopener">Core Data Framework Reference</a></p>
<h5 id="Core-Image"><a href="#Core-Image" class="headerlink" title="Core Image"></a>Core Image</h5><p>Core Image框架(CoreImage.framework)包含了下面这些改进。</p>
<p>搭载A8、A9CPU的设备开始支持RAW格式的图片。对于第三方相机产生的RAW格式的图片CoreImage也能很好地支持，使用RAW格式的图片需要调用<a href="https://developer.apple.com/reference/coreimage/cifilter/1437879-init" target="_blank" rel="noopener">filterWithImageData:options:</a>或<a href="https://developer.apple.com/reference/coreimage/cifilter/1438096-init" target="_blank" rel="noopener">filterWithImageURL:options:</a>来创建一个<a href="https://developer.apple.com/reference/coreimage/cifilter" target="_blank" rel="noopener">CIFilter</a>对象，再根据RAW Image Options选项调整RAW数据，最后从<a href="https://developer.apple.com/reference/coreimage/cifilter/1438169-outputimage" target="_blank" rel="noopener">outputImage</a>属性中得到处理后的图片数据。</p>
<p>现在可以用<a href="https://developer.apple.com/reference/coreimage/ciimage/1639637-withextent" target="_blank" rel="noopener">imageWithExtent:processorDescription:argumentDigest:inputFormat:outputFormat:options:roiCallback:processor:</a>方法在Core Image滤镜中插入自定义的处理逻辑。这个方法添加了一个回调Block，这个Block会在处理图片数据和输出图片数据之间的一个时刻被调用。在Block里能获取到像素数据或Metal纹理数据，你在这里可以运行自定义的图形算法。</p>
<p>在写自定义图形处理逻辑或重写滤镜内核时除了Core Image的contex的色彩空间外还能用其他的色彩空间，可以用 <a href="https://developer.apple.com/reference/coreimage/ciimage/1645898-matchedfromworkingspace" target="_blank" rel="noopener">imageByColorMatchingWorkingSpaceToColorSpace:</a>和<a href="https://developer.apple.com/reference/coreimage/ciimage/1645896-matchedtoworkingspace" target="_blank" rel="noopener">imageByColorMatchingColorSpaceToWorkingSpace:</a>方法来互相转换。</p>
<p>在Core Image框架的优化下渲染<a href="https://developer.apple.com/reference/uikit/uiimage" target="_blank" rel="noopener">UIImage</a>对象的效率得到大幅提升(比如用<a href="https://developer.apple.com/reference/uikit/uiimage/1624114-init" target="_blank" rel="noopener">initWithCIImage:</a>方法初始化)。另外UIImageView中的宽色域的支持是由它内部的Core Image对象实现的。</p>
<p>Core Image核心代码现在可以指定输出像素格式。</p>
<p>Core Image引入了5个新滤镜：</p>
<ul>
<li>CINinePartTiled</li>
<li>CINinePartStretched</li>
<li>CIHueSaturationValueGradient</li>
<li>CIEdgePreserveUpsampleFilter</li>
<li>CIClamp</li>
</ul>
<h5 id="Core-Motion"><a href="#Core-Motion" class="headerlink" title="Core Motion"></a>Core Motion</h5><p>Core Motion框架(CoreMotion.framework)引入了计步器事件，它可以实时监听手机用户的运动状态，包括跑步、暂停等。在支持这个特性的设备上可以用<a href="https://developer.apple.com/reference/coremotion/cmpedometer" target="_blank" rel="noopener">CMPedometer</a>APIs来注册并接受实时计步事件。</p>
<h5 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h5><p>Foundation框架(Foundation.framework)包含了下列增强：</p>
<ul>
<li>新的<a href="https://developer.apple.com/reference/foundation/nsdateinterval" target="_blank" rel="noopener">NSDateInterval</a>类提供了判断某个时刻是否处于指定的时间段内。</li>
<li><a href="https://developer.apple.com/reference/foundation/nslocale" target="_blank" rel="noopener">NSLocale</a>增加了获取本地化信息的属性</li>
<li>新的<a href="https://developer.apple.com/reference/foundation/nsmeasurement" target="_blank" rel="noopener">NSMeasurement</a>类能把尺寸转换成不同的单位，并在两种尺寸之间进行计算。新的<a href="https://developer.apple.com/reference/foundation/measurementformatter" target="_blank" rel="noopener">NSMeasurementFormatter</a>类可以把尺寸进行本地化(转换成当地惯用单位，译者注)</li>
<li>新的<a href="https://developer.apple.com/reference/foundation/unit" target="_blank" rel="noopener">NSUnit</a>类以其子类<a href="https://developer.apple.com/reference/foundation/nsdimension" target="_blank" rel="noopener">NSDimension</a>能表示特定的计量单位</li>
</ul>
<h5 id="GameKit"><a href="#GameKit" class="headerlink" title="GameKit"></a>GameKit</h5><p>GameKit框架(GameKit.framework)包含了下列改进：</p>
<ul>
<li>Game Center应用现在已经被移除。如果游戏中实现了GameKit特性，需要自定义相关的UI。例如，你的游戏支持排行榜，你可以直接从Game Center获取相关数据并用自定义的视图展示(当然，直接用<a href="https://developer.apple.com/reference/gamekit/gkgamecenterviewcontroller" target="_blank" rel="noopener">GKGameCenterViewController</a>对象也行)</li>
<li>新的账户类型，由<a href="https://developer.apple.com/reference/gamekit/gkcloudplayer" target="_blank" rel="noopener">GKCloudPlayer</a>实现，支持iCloud-only游戏账号</li>
<li>Game Center对其内部的数据持久化提供了新的解决方案。一个游戏会话(<a href="https://developer.apple.com/reference/gamekit/gkgamesession" target="_blank" rel="noopener">GKGameSession</a>)拥有参与这个会话的玩家列表。你需要做的是决定何时以及如何从服务端存储和遍历数据或在玩家之间传输数据。游戏会话技术非常适用于回合制比赛、实时比赛以及其他多人互动游戏上</li>
</ul>
<h5 id="GameplayKit"><a href="#GameplayKit" class="headerlink" title="GameplayKit"></a>GameplayKit</h5><p>GameplayKit框架(GameplayKit.framework)包含了下列的改进：</p>
<ul>
<li>用于增强游戏场景效果的声音合成器。以及看起来更自然的纹理和更真实的相机移动。</li>
<li>空间隔离减少了游戏数据处理复杂度，让数据搜索效率更高</li>
<li>新的Monte Carlo策略(<a href="https://developer.apple.com/reference/gameplaykit/gkmontecarlostrategist" target="_blank" rel="noopener">GKMonteCarloStrategist</a>)类能帮你免除对可能产生的动作进行详尽地计算</li>
<li>新的决策树API能让游戏的AI设计起来更方便(前提是你的游戏AI是通过玩家行为数据用决策树来生成的)</li>
<li><a href="https://developer.apple.com/reference/gameplaykit/gkagent3d" target="_blank" rel="noopener">GKAgent3D</a>和<a href="https://developer.apple.com/reference/gameplaykit/gkgraphnode3d" target="_blank" rel="noopener">GKGraphNode3D</a>类引入了对existing agent和path-finding的3D支持</li>
<li><a href="https://developer.apple.com/reference/gameplaykit/gkobstaclegraph" target="_blank" rel="noopener">GKObstacleGraph</a>有了性能更好的替代品———<a href="https://developer.apple.com/reference/gameplaykit/gkmeshgraph" target="_blank" rel="noopener">GKMeshGraph</a>它能生成更自然的路径</li>
<li>新的<a href="https://developer.apple.com/reference/gameplaykit/gkscene" target="_blank" rel="noopener">GKScene</a>、<a href="https://developer.apple.com/reference/gameplaykit/gksknodecomponent" target="_blank" rel="noopener">GKSKNodeComponent</a>和SpriteKit以及Xcode editor的结合让集成GameplayKit、SpriteKit变得前所未有地简单</li>
</ul>
<h5 id="HealthKit"><a href="#HealthKit" class="headerlink" title="HealthKit"></a>HealthKit</h5><p>HealthKit框架(HealthKit.framework)包含了下列改进：</p>
<ul>
<li>新的<a href="https://developer.apple.com/reference/healthkit/hkcdadocument" target="_blank" rel="noopener">HKCDADocument</a>类，代表CDA文件(遵循Clinical Document Architecture标准的文件)</li>
<li>新的<a href="https://developer.apple.com/reference/healthkit/hkworkoutconfiguration" target="_blank" rel="noopener">HKWorkoutConfiguration</a>类，能让你为一项锻炼指定<a href="https://developer.apple.com/reference/healthkit/hkworkoutconfiguration/1649492-activitytype" target="_blank" rel="noopener">activityType</a>和<a href="https://developer.apple.com/reference/healthkit/hkworkoutconfiguration/1649491-locationtype" target="_blank" rel="noopener">locationType</a></li>
<li>新的<a href="https://developer.apple.com/reference/healthkit/hkwheelchairuseobject" target="_blank" rel="noopener">HKWheelchairUseObject</a>特征对象类型和<a href="https://developer.apple.com/reference/healthkit/hkhealthstore" target="_blank" rel="noopener">HKHealthStore</a>相关的方法<a href="https://developer.apple.com/reference/healthkit/hkhealthstore/1648356-wheelchairuse" target="_blank" rel="noopener">wheelchairUseWithError:</a></li>
<li>新的代表天气的元数据key，比如<a href="https://developer.apple.com/reference/healthkit/hkweathercondition/hkweatherconditionclear" target="_blank" rel="noopener">HKWeatherConditionClear</a>和<a href="https://developer.apple.com/reference/healthkit/hkweathercondition/hkweatherconditioncloudy" target="_blank" rel="noopener">HKWeatherConditionCloudy</a>。还有锻炼类的，比如<a href="https://developer.apple.com/reference/healthkit/hkworkoutactivitytype/1649808-flexibility" target="_blank" rel="noopener">HKWorkoutActivityTypeFlexibility</a>和<a href="https://developer.apple.com/reference/healthkit/hkworkoutactivitytype/hkworkoutactivitytypewheelchairrunpace" target="_blank" rel="noopener">HKWorkoutActivityTypeWheelchairRunPace</a></li>
</ul>
<h5 id="HomeKit"><a href="#HomeKit" class="headerlink" title="HomeKit"></a>HomeKit</h5><p>iOS10以后，iPad可以变成家庭控制中心，允许进行远程访问，运行自动任务触发器以及共享用户授权。另外HomeKit框架(HomeKit.framework)添加了对摄像机和门铃的支持，并引入了很多新API：</p>
<ul>
<li>调用并控制网络摄像机，显示实时视频流和截图以及控制摄像机、扬声器和话筒</li>
<li>Access new services and characteristics</li>
<li>For the primary service, link services and valid values to provide more context and configuration about the accessories</li>
</ul>
<p>现在可以用Apple家居设备设置流程来添加或者设置家居设备。想要了解更多可以看<a href="https://developer.apple.com/reference/homekit" target="_blank" rel="noopener">HomeKit Framework Reference</a></p>
<h5 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a>Metal</h5><p>iOS10以后Metal引入了一些新特性并对某些方面进行了增强，比如：</p>
<ul>
<li>支持tessellation。允许3D游戏和应用进行更细致地渲染</li>
<li>函数专精化。这样就能开发出高度优化的函数来处理材质和光照</li>
<li>资源堆和更小内存的渲染目标。在未来会对资源分配进行更细粒度的控制来优化性能</li>
</ul>
<h5 id="ModelIO"><a href="#ModelIO" class="headerlink" title="ModelIO"></a>ModelIO</h5><p>ModelIO框架(ModelIO.framework)包含了下列改进：</p>
<ul>
<li>支持USD格式</li>
<li>新的<code>MDLMaterialPropertyGraph</code>类让运行时修改models更容易</li>
<li><a href="https://developer.apple.com/reference/modelio/mdlvoxelarray" target="_blank" rel="noopener">MDLVoxelArray</a>类现在支持signed distance fields</li>
<li>可以实现<code>MDLLightProbeIrradianceDataSource</code>协议来添加assisted light probe</li>
</ul>
<h5 id="Photos"><a href="#Photos" class="headerlink" title="Photos"></a>Photos</h5><p>Photos框架(Photos.framework)现在支持对Live Photo进行编辑了。特别是新<a href="https://developer.apple.com/reference/photos/phlivephotoeditingcontext" target="_blank" rel="noopener">PHLivePhotoEditingContext</a>类允许你编辑视频和Live Photo中的静态内容。Core Image的性能增强在这里也得以体现，想要了解更多请看<a href="https://developer.apple.com/reference/coreimage/ciimageprocessorinput" target="_blank" rel="noopener">CIImageProcessorInput</a>和<a href="https://developer.apple.com/reference/coreimage/ciimageprocessoroutput" target="_blank" rel="noopener">CIImageProcessorOutput</a>。</p>
<h5 id="ReplayKit"><a href="#ReplayKit" class="headerlink" title="ReplayKit"></a>ReplayKit</h5><p>ReplayKit框架(ReplayKit.framework)包含了下列增强：</p>
<ul>
<li>ReplayKit支持广播服务，用户可以通过第三方广播自己的屏幕内容。使用下面这些API就能够集成这个新特性 <a href="https://developer.apple.com/reference/replaykit/rpscreenrecorder" target="_blank" rel="noopener">RPScreenRecorder</a>、<a href="https://developer.apple.com/reference/replaykit/rpbroadcastactivityviewcontroller" target="_blank" rel="noopener">RPBroadcastActivityViewController</a>、<a href="https://developer.apple.com/reference/replaykit/rpbroadcastcontroller" target="_blank" rel="noopener">RPBroadcastController</a></li>
<li>若要参与ReplayKit广播，第三方广播服务商需要实现相应的应用扩展。这个扩展应该具有让用户接入并配置广播的功能</li>
</ul>
<h5 id="SceneKit"><a href="#SceneKit" class="headerlink" title="SceneKit"></a>SceneKit</h5><p>The SceneKit framework (SceneKit.framework) includes several enhancements.</p>
<p>A new Physically Based Rendering (PBR) system allows you to leverage the latest in 3D graphics research to create more realistic results with simpler asset authoring. Specifically:</p>
<ul>
<li><p>Use the new <a href="https://developer.apple.com/reference/scenekit/scnmaterial.lightingmodel/1640553-physicallybased" target="_blank" rel="noopener">SCNLightingModelPhysicallyBased</a> shading model to opt into PBR shading for materials. PBR materials require only three fundamental properties—<a href="https://developer.apple.com/reference/scenekit/scnmaterial/1462589-diffuse" target="_blank" rel="noopener">diffuse</a>, <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1640554-metalness" target="_blank" rel="noopener">metalness</a>, and <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1640555-roughness" target="_blank" rel="noopener">roughness</a>—to produce a wide range of realistic shading effects. (The <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1462542-normal" target="_blank" rel="noopener">normal</a>, <a href="https://developer.apple.com/reference/scenekit/scnmaterial/1462579-ambientocclusion" target="_blank" rel="noopener">ambientOcclusion</a>, and selfIllumination material properties also remain useful for PBR materials, but you can now ignore the large number of other properties used for traditional materials.)</p>
</li>
<li><p>PBR shading works best with environment-based lighting, which causes even diffuse surfaces to pick up the colors of the scene around them. Use the <a href="https://developer.apple.com/reference/scenekit/scnscene/1639532-lightingenvironment" target="_blank" rel="noopener">lightingEnvironment</a> property to assign global image-based lighting to an entire scene, and place light probes in the Xcode scene editor to pick up the local lighting contributions from objects within your scene.<br>Authors of PBR scene content often prefer working in physically based terms, so you can now define lighting using intensity (in lumens) and color temperature (in degrees Kelvin), and import specifications for real-world light fixtures using the IESProfileURL property.</p>
</li>
</ul>
<p>Add even more realism with the new HDR features and effects in the <a href="https://developer.apple.com/reference/scenekit/scncamera" target="_blank" rel="noopener">SCNCamera</a> class. With HDR rendering, SceneKit captures a much wider range of brightness and contrast in a scene, then allows you to customize the tone mapping that adapts that scene for the narrower range of a device’s display. Enable exposure adaptation to create automatic effects when, for example, the player in your game moves from a darkened area into sunlight. Or use vignetting, color fringing, and color grading to add a filmic look to your game.</p>
<p>Although linear, more color-accurate rendering is the basis for PBR shading and HDR camera features, it produces better results even for traditional rendering. By default, SceneKit now performs all color calculations in a linear (not gamma-adjusted) color space, and uses the P3 color gamut of devices that include wide-color displays. This feature is enabled automatically for all apps linking against the iOS 10 SDK, and has a few ramifications for content design and asset management:</p>
<ul>
<li>SceneKit color matches all colors. In previous versions, SceneKit would read only the color values from material colors specified as <a href="https://developer.apple.com/reference/appkit/nscolor" target="_blank" rel="noopener">NSColor</a> or <a href="https://developer.apple.com/reference/uikit/uicolor" target="_blank" rel="noopener">UIColor</a> objects, ignoring color profile information and assuming the sRGB color space.</li>
<li>SceneKit interprets color component values specified within shader modifier or custom Metal or OpenGL shader code in linear RGB space.</li>
<li>SceneKit reads and adjusts for color profile information in texture images. Design textures for a linear brightness ramp, and use Asset Catalogs in Xcode to make sure your images use the correct color profile.</li>
<li>If necessary, you can disable linear space rendering with the <code>SCNDisableLinearSpaceRendering</code> key in your app’s Info.plist file, and wide color rendering with the <code>SCNDisableWideGamut</code> key.<br>Geometry can now be loaded from scene files or programmatically defined using arbitrary polygon primitives (<a href="https://developer.apple.com/reference/scenekit/scngeometryprimitivetype/scngeometryprimitivetypepolygon" target="_blank" rel="noopener">SCNGeometryPrimitiveTypePolygon</a>). SceneKit automatically triangulates polygon meshes for rendering, but makes use of the underlying polygon mesh for more accurate surface subdivision (to learn more, see the <a href="https://developer.apple.com/reference/scenekit/scngeometry/1524177-subdivisionlevel" target="_blank" rel="noopener">subdivisionLevel</a> property).</li>
</ul>
<h5 id="SpriteKit"><a href="#SpriteKit" class="headerlink" title="SpriteKit"></a>SpriteKit</h5><p>The SpriteKit framework (SpriteKit.framework) includes the following enhancements:</p>
<ul>
<li>A new tilemap solution supports square, hexagonal, and isometric tilemaps that make it easy to create 2D, 2.5D, and side-scroller games. The Xcode editor provides comprehensive support for organizing your tiles and creating your tilemap. For more information, see the <code>SKTileMapNode</code>, <code>SKTileGroup</code>, <code>SKTileGroupRule</code>, and <code>SKTileSet</code> classes .</li>
<li>The new <code>SKWarpGeometry</code> class is used to stretch or distort how a <a href="https://developer.apple.com/reference/spritekit/skspritenode" target="_blank" rel="noopener">SKSpriteNode</a> or <a href="https://developer.apple.com/reference/spritekit/skeffectnode" target="_blank" rel="noopener">SKEffectNode</a> object is rendered. The warp is specified by a set of control points. New <a href="https://developer.apple.com/reference/spritekit/skaction" target="_blank" rel="noopener">SKAction</a> types can be used to animate between different warp effects.</li>
<li>A custom shader can use attributes that can be configured separately by each node that uses the shader. To add an attribute, create an <code>SKAttribute</code> object and attach it to your shader. Then, for each node that uses that shader, attach an <code>SKAttributeValue</code> object.]</li>
<li>The <a href="https://developer.apple.com/reference/spritekit/skview" target="_blank" rel="noopener">SKView</a> class defines new methods that give you finer control over when and how your scene is rendered.</li>
</ul>
<h5 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h5><p>UIKit框架(UIKit.framework)包含了大量的改进，包括：</p>
<ul>
<li>新的基于对象互动式动画系统，可以很方便的持有它，并和用户手势进行交互。想要了解更多请看<a href="https://developer.apple.com/reference/uikit/uiviewanimating" target="_blank" rel="noopener">UIViewAnimating Protocol Reference</a>、<a href="https://developer.apple.com/reference/uikit/uiviewpropertyanimator" target="_blank" rel="noopener">UIViewPropertyAnimator Class Reference</a>、<a href="https://developer.apple.com/reference/uikit/uitimingcurveprovider" target="_blank" rel="noopener">UITimingCurveProvider Protocol Reference</a>、<a href="https://developer.apple.com/reference/uikit/uicubictimingparameters" target="_blank" rel="noopener">UICubicTimingParameters Class Reference</a>、 <a href="https://developer.apple.com/reference/uikit/uispringtimingparameters" target="_blank" rel="noopener">UISpringTimingParameters Class Reference</a></li>
<li>新的<a href="https://developer.apple.com/reference/uikit/uipreviewinteraction" target="_blank" rel="noopener">UIPreviewInteraction</a>类和 <a href="https://developer.apple.com/reference/uikit/uipreviewinteractiondelegate" target="_blank" rel="noopener">UIPreviewInteractionDelegate</a>协议可以为peek和pop操作提供自定义界面</li>
<li><code>UIAccessibilityCustomRotor</code>以及相关的类可以让应用更好地集成辅助性技术，类似于向VoiceOver提供朗读内容。你可以创建自定义的rotor，返回拼写错误的单词的位置来让用户得知文档中的拼写错误</li>
<li><code>UIAccessibilityIsAssistiveTouchRunning</code>和<code>UIAccessibilityAssistiveTouchStatusDidChangeNotification</code>可以在AssistiveTouch激活的时候通知你。<code>UIAccessibilityHearingDevicePairedEar</code>和<code>UIAccessibilityHearingDevicePairedEarDidChangeNotification</code>能让你得知MFi助听器的配对状态</li>
<li>新的<a href="https://developer.apple.com/reference/uikit/uipasteboard" target="_blank" rel="noopener">UIPasteboard</a>提供了对大部分类实例兼容类型的声明，以及提供了对剪贴板内对象的生命周期进行限制的选项</li>
<li><a href="https://developer.apple.com/reference/uikit/uipasteboard" target="_blank" rel="noopener">UIPasteboard</a>的新选项</li>
<li><a href="https://developer.apple.com/reference/uikit/uifont" target="_blank" rel="noopener">UIFont</a>的<code>preferredFontForTextStyle:compatibleWithTraitCollection:</code>方法提供了对labels、text fields和其他文本控件的动态字体支持</li>
<li>当设备的<code>UIContentSizeCategory</code>改变时<code>UIContentSizeCategoryAdjusting</code>协议提供了<code>adjustsFontForContentSizeCategory</code>属性来帮你更新相关的字体</li>
<li>对tab bar item的badge外观的更多控制，诸如背景颜色和text attributes</li>
<li>所有的scrol view及其子类都支持refresh control了</li>
<li><a href="https://developer.apple.com/reference/uikit/uiapplication" target="_blank" rel="noopener">UIApplication</a>的新方法<code>openURL:options:completionHandler:</code>为异步执行，并在主线程执行回调(这个方法将来要取代<a href="https://developer.apple.com/reference/uikit/uiapplication/1622961-openurl" target="_blank" rel="noopener">openURL:</a>)</li>
<li>新的<code>UICloudSharingController</code>类和<code>UICloudSharingControllerDelegate</code>协议可以初始化Cloudkit分享操作，并向用户展示一个相关配置选项的界面</li>
<li>增强了<a href="https://developer.apple.com/reference/uikit/uicollectionview" target="_blank" rel="noopener">UICollectionView</a>以及新增了<a href="https://developer.apple.com/reference/uikit/uicollectionviewdatasourceprefetching" target="_blank" rel="noopener">UICollectionViewDataSourcePrefetching</a>协议，通过提前获取cell的方式增强了滑动体验</li>
</ul>
<h5 id="WebKit"><a href="#WebKit" class="headerlink" title="WebKit"></a>WebKit</h5><p>WebKit框架(WebKit.framework)的<a href="https://developer.apple.com/reference/webkit/wkwebview" target="_blank" rel="noopener">WKWebView</a>增强了peek和pop操作。在iOS10上用户可以使用<a href="https://developer.apple.com/reference/webkit/wkuidelegate/1648359-webview" target="_blank" rel="noopener">webView:shouldPreviewElement:</a>方法来决定是否在指定的链接上显示预览页面。</p>
<h3 id="Deprecated-APIs"><a href="#Deprecated-APIs" class="headerlink" title="Deprecated APIs"></a>Deprecated APIs</h3><p>iOS10把下列的APIs标记为废弃：</p>
<ul>
<li><a href="https://developer.apple.com/reference/cloudkit/ckdiscoverallcontactsoperation" target="_blank" rel="noopener">CloudKit CKDiscoverAllContactsOperation</a>、<a href="https://developer.apple.com/reference/cloudkit/ckdiscovereduserinfo" target="_blank" rel="noopener">CKDiscoveredUserInfo</a>、<a href="https://developer.apple.com/reference/cloudkit/ckdiscoveruserinfosoperation" target="_blank" rel="noopener">CKDiscoverUserInfosOperation</a>, <a href="https://developer.apple.com/reference/cloudkit/ckfetchrecordchangesoperation" target="_blank" rel="noopener">CKFetchRecordChangesOperation</a>。作为替代可以使用 <a href="https://developer.apple.com/reference/cloudkit/ckdiscoveralluseridentitiesoperation" target="_blank" rel="noopener">CKDiscoverAllUserIdentitiesOperation</a>、<a href="https://developer.apple.com/reference/cloudkit/ckuseridentity" target="_blank" rel="noopener">CKUserIdentity</a>、<a href="https://developer.apple.com/reference/cloudkit/ckdiscoveruseridentitiesoperation" target="_blank" rel="noopener">CKDiscoverUserIdentitiesOperation</a>和 <a href="https://developer.apple.com/reference/cloudkit/ckfetchrecordzonechangesoperation" target="_blank" rel="noopener">CKFetchRecordZoneChangesOperation</a>。<br>多个<a href="https://developer.apple.com/reference/cloudkit/cksubscription" target="_blank" rel="noopener">CKSubscription</a>的APIs，比如zone-based subscriptions相关的方法和属性(用<code>CKRecordZoneSubscription</code>替代)</li>
<li><a href="NSPersistentStoreCoordinator">NSPersistentStoreCoordinator</a>相关的常量</li>
<li><a href="https://developer.apple.com/reference/uikit/uiviewcontroller" target="_blank" rel="noopener">UIViewController</a>中的<a href="https://developer.apple.com/reference/iad/adbannerview" target="_blank" rel="noopener">ADBannerView</a>和<a href="https://developer.apple.com/reference/iad/adinterstitialad" target="_blank" rel="noopener">ADInterstitialAd</a>类以及相关常量</li>
<li><a href="https://developer.apple.com/reference/spritekit/skuniform" target="_blank" rel="noopener">SKUniform</a>相关的浮点常量。可以在适当的情况下用<code>initWithName:vectorFloat2:</code>和<code>uniformWithName:matrixFloat2x2:</code>作为替代</li>
<li>UIkit相关的通知，诸如<a href="https://developer.apple.com/reference/uikit/uilocalnotification" target="_blank" rel="noopener">UILocalNotification</a>、<a href="https://developer.apple.com/reference/uikit/uimutableusernotificationaction" target="_blank" rel="noopener">UIMutableUserNotificationAction</a>、<a href="https://developer.apple.com/reference/uikit/uimutableusernotificationcategory" target="_blank" rel="noopener">UIMutableUserNotificationCategory</a>、<a href="https://developer.apple.com/reference/uikit/uiusernotificationaction" target="_blank" rel="noopener">UIUserNotificationAction</a>、<a href="https://developer.apple.com/reference/uikit/uiusernotificationcategory" target="_blank" rel="noopener">UIUserNotificationCategory</a>和<a href="https://developer.apple.com/reference/uikit/uiusernotificationsettings" target="_blank" rel="noopener">UIUserNotificationSettings</a>。请使用User Notifications框架作为替代(<a href="https://developer.apple.com/reference/usernotifications" target="_blank" rel="noopener">Notifications Framework Reference</a>)</li>
<li><a href="https://developer.apple.com/reference/watchkit/wkinterfacecontroller/1619516-handleactionwithidentifier" target="_blank" rel="noopener">handleActionWithIdentifier:forLocalNotification:</a>、<a href="https://developer.apple.com/reference/watchkit/wkinterfacecontroller/1619530-handleactionwithidentifier" target="_blank" rel="noopener">handleActionWithIdentifier:forRemoteNotification:</a>、<a href="https://developer.apple.com/reference/watchkit/wkusernotificationinterfacecontroller/1619534-didreceivelocalnotification" target="_blank" rel="noopener">didReceiveLocalNotification:withCompletion:</a>和 <a href="https://developer.apple.com/reference/watchkit/wkusernotificationinterfacecontroller/1619568-didreceiveremotenotification" target="_blank" rel="noopener">didReceiveRemoteNotification:withCompletion:</a>等方法。请使用<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate/1628138-handleactionwithidentifier" target="_blank" rel="noopener">handleActionWithIdentifier:forNotification:</a>和<a href="https://developer.apple.com/reference/watchkit/wkusernotificationinterfacecontroller/1648287-didreceive" target="_blank" rel="noopener">didReceiveNotification:withCompletion:</a>作为替代。<br>同样还有<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate" target="_blank" rel="noopener">WKExtensionDelegate</a>的通知处理方法，诸如<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate/1628170-didreceiveremotenotification" target="_blank" rel="noopener">didReceiveRemoteNotification:</a>和<a href="https://developer.apple.com/reference/watchkit/wkextensiondelegate/1628138-handleactionwithidentifier" target="_blank" rel="noopener">handleActionWithIdentifier:forRemoteNotification:</a>作为使用上述方法的替代方案，首先实例化一个遵循<a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenterdelegate" target="_blank" rel="noopener">UNUserNotificationCenterDelegate</a>协议的托对象并实现适当的方法，然后把这个实例对象赋值给<a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenter" target="_blank" rel="noopener">UNUserNotificationCenter</a>单例的<a href="https://developer.apple.com/reference/usernotifications/unusernotificationcenter/1649522-delegate" target="_blank" rel="noopener">delegate</a>属性</li>
</ul>
<p>完整的API废弃列表请看<a href="https://developer.apple.com/library/content/releasenotes/General/iOS10APIDiffs/index.html" target="_blank" rel="noopener">iOS 10.0 API Diffs</a>。</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS worst practice]]></title>
      <url>http://petpwiuta.github.io/2016/10/08/iOS-worst-practice/</url>
      <content type="html"><![CDATA[<h1 id="iOS-worst-practice"><a href="#iOS-worst-practice" class="headerlink" title="iOS worst practice"></a>iOS worst practice</h1><p>最近在重构公司的项目，随着对项目的逐渐深入（被坑的次数越来越多），被各路大牛的神迹所折服，以至于感觉这些人是不是我们竞争对手派来的卧底。这些坑可以算是iOS worst practice了，在这里总结一下。</p>
<h2 id="命名的问题"><a href="#命名的问题" class="headerlink" title="命名的问题"></a>命名的问题</h2><p>给变量或者类以及方法起名能从一个侧面反映出一个程序员的水平以及项目的管理情况。在这个项目中，方法名、变量名和类名都没有统一，而且相关业务命名也没有规定。比如用于引导页面就有<code>TechView</code>、<code>IntroduceView</code>、<code>guideView</code>等，而下面的这些命名真是让人看了直接让人凌乱：</p>
<p>方法：</p>
<p><code>-(void)preTeachView2KnowActionWithNoShow:(UIButton *)sender</code></p>
<p><code>-(void)setTableView_Up_Down_NoHidden</code></p>
<p>变量：</p>
<p><code>#define fuckvalue   -34</code></p>
<p><code>_info_tmp</code></p>
<p><code>NSString *fuck1;</code></p>
<p><code>NSString *fuck2;</code></p>
<p>类:</p>
<p><code>@interface New_AdPersonViewController : New_PersonDetailViewController</code></p>
<h2 id="代码复用性"><a href="#代码复用性" class="headerlink" title="代码复用性"></a>代码复用性</h2><p>不会Ctrl-C/Ctrl-V的程序员不是好程序员，不过有些人玩得太high了，看你的工程中到处都是下面这些代码的时候你是什么感觉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    UITableViewCell *cell;</span><br><span class="line">    if(indexPath.section &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cell &#x3D; [self setTableView:tableView CellForRowAtIndexPath:indexPath section:0];</span><br><span class="line">    &#125;</span><br><span class="line">    else if(indexPath.section &#x3D;&#x3D; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        cell &#x3D; [self setTableView:tableView CellForRowAtIndexPath:indexPath section:1];</span><br><span class="line">    &#125;</span><br><span class="line">    else if(indexPath.section &#x3D;&#x3D; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        cell &#x3D; [self setTableView:tableView CellForRowAtIndexPath:indexPath section:2];</span><br><span class="line">    &#125;</span><br><span class="line">    else if(indexPath.section &#x3D;&#x3D; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        cell &#x3D; [self setTableView:tableView CellForRowAtIndexPath:indexPath section:3];</span><br><span class="line">    &#125;</span><br><span class="line">    else if(indexPath.section &#x3D;&#x3D; 4)</span><br><span class="line">    &#123;</span><br><span class="line">        cell &#x3D; [self setTableView:tableView CellForRowAtIndexPath:indexPath section:4];</span><br><span class="line">    &#125;</span><br><span class="line">    else if(indexPath.section &#x3D;&#x3D; 5)</span><br><span class="line">    &#123;</span><br><span class="line">        cell &#x3D; [self setTableView:tableView CellForRowAtIndexPath:indexPath section:5];</span><br><span class="line">    &#125;</span><br><span class="line">    else if(indexPath.section &#x3D;&#x3D; 6)</span><br><span class="line">    &#123;</span><br><span class="line">        cell &#x3D; [self setTableView:tableView CellForRowAtIndexPath:indexPath section:6];</span><br><span class="line">    &#125;</span><br><span class="line">    else if(indexPath.section &#x3D;&#x3D; 7)</span><br><span class="line">    &#123;</span><br><span class="line">        cell &#x3D; [self setTableView:tableView CellForRowAtIndexPath:indexPath section:7];</span><br><span class="line">    &#125;</span><br><span class="line">    else if(indexPath.section &#x3D;&#x3D; 8)</span><br><span class="line">    &#123;</span><br><span class="line">        cell &#x3D; [self setTableView:tableView CellForRowAtIndexPath:indexPath section:8];</span><br><span class="line">    &#125;</span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> NSString *sectionTitle &#x3D; @&quot;&quot;;</span><br><span class="line">        if(indexPath.section &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            sectionTitle &#x3D; [_arraySections objectAtIndex:0];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(indexPath.section &#x3D;&#x3D; 1)</span><br><span class="line">        &#123;</span><br><span class="line">            sectionTitle &#x3D; [_arraySections objectAtIndex:1];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(indexPath.section &#x3D;&#x3D; 2)</span><br><span class="line">        &#123;</span><br><span class="line">            sectionTitle &#x3D; [_arraySections objectAtIndex:2];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(indexPath.section &#x3D;&#x3D; 3)</span><br><span class="line">        &#123;</span><br><span class="line">            sectionTitle &#x3D; [_arraySections objectAtIndex:3];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(indexPath.section &#x3D;&#x3D; 4)</span><br><span class="line">        &#123;</span><br><span class="line">            sectionTitle &#x3D; [_arraySections objectAtIndex:4];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(indexPath.section &#x3D;&#x3D; 5)</span><br><span class="line">        &#123;</span><br><span class="line">            sectionTitle &#x3D; [_arraySections objectAtIndex:5];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(indexPath.section &#x3D;&#x3D; 6)</span><br><span class="line">        &#123;</span><br><span class="line">            sectionTitle &#x3D; [_arraySections objectAtIndex:6];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(indexPath.section &#x3D;&#x3D; 7)</span><br><span class="line">        &#123;</span><br><span class="line">            sectionTitle &#x3D; [_arraySections objectAtIndex:7];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(indexPath.section &#x3D;&#x3D; 8)</span><br><span class="line">        &#123;</span><br><span class="line">            sectionTitle &#x3D; [_arraySections objectAtIndex:8];</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>反正我看了第一感觉是，我x、原来以前公司发工资是按代码行数算钱的······</p>
<h2 id="没有面向对象思想"><a href="#没有面向对象思想" class="headerlink" title="没有面向对象思想"></a>没有面向对象思想</h2><ul>
<li>在ViewController基类中放一些特定的业务逻辑，然后所有的子类中都有一堆阴魂不散的代码</li>
<li>该封装的不封装，完成同样功能的函数在每个用到的地方都一个copy，一旦逻辑变动，改起来真心好爽</li>
<li>不该封装的乱封装，封装的暴露的方法完全不知道是干什么的，想要类运行还必须先设定某些它所依赖的全局变量</li>
</ul>
<h2 id="滥用单例、通知"><a href="#滥用单例、通知" class="headerlink" title="滥用单例、通知"></a>滥用单例、通知</h2><p>实际上工程里面单例就一个，不过单例对象把所有的活都干，所以可以理解为整个工程的架构，都是面向过程的，全部模块水乳交融、浑然一体。用户数据保存靠这个单例、具体页面数据设置靠靠这个单例、应用行为配置靠靠这个单例······然后大部分的ViewController想要正常工作都得提前把所需的数据在这个单例中配置好，想想都佩服那些大神的记忆力；对于滥用通知的后果和单例一样，当你见到一个控制器中有一二十条通知齐刷刷地写在初始化方法里的时候有什么感觉。想想都有点小激动，你确定不是在逗我？</p>
<h2 id="各种脑洞大开的实现"><a href="#各种脑洞大开的实现" class="headerlink" title="各种脑洞大开的实现"></a>各种脑洞大开的实现</h2><p>看见一个函数名叫做addRequestQueue的时候你会有什么反应，大部分人肯定想着肯定会是生成请求实例、有请求队列对它们进行管理······对此我只能说大神的想象力是无穷的，这个addRequestQueue是用<strong>递归的方式</strong>发送的请求，在网络请求成功或失败的闭包中会再次调用自己发送请求，这时候我终于明白这个队列是在哪儿了。</p>
<p>类似的例子还有很多，一次次的被大神的想象力所折服！</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[项目中Cell自动计算行高的实践]]></title>
      <url>http://petpwiuta.github.io/2016/10/08/cell-height-calc-with-autolayout/</url>
      <content type="html"><![CDATA[<h1 id="项目中Cell自动计算行高的实践"><a href="#项目中Cell自动计算行高的实践" class="headerlink" title="项目中Cell自动计算行高的实践"></a>项目中Cell自动计算行高的实践</h1><h3 id="在前面总该说些什么"><a href="#在前面总该说些什么" class="headerlink" title="在前面总该说些什么"></a>在前面总该说些什么</h3><p>这篇文章是对团队最近关于使用Autolayout对Cell进行高度计算的总结。</p>
<hr>
<p>接下来你将会看到以下内容：</p>
<blockquote>
<ul>
<li>数据和UI分离式的Cell高度计算的弊端</li>
<li>Self-Sizing Cell的解决方案</li>
<li>UITableView+FDTemplateLayoutCell简介</li>
<li>UITableView+FDTemplateLayoutCell代码分析</li>
<li>UITableView+FDTemplateLayoutCell集成</li>
</ul>
</blockquote>
<h3 id="数据和UI分离式的Cell高度计算的弊端"><a href="#数据和UI分离式的Cell高度计算的弊端" class="headerlink" title="数据和UI分离式的Cell高度计算的弊端"></a>数据和UI分离式的Cell高度计算的弊端</h3><p>通过数据模型的方式计算行高，这样的方式已经从ios4延伸到ios9了，这种方式的核心是在cell或者model里面提供一个方法，传入数据，然后根据内容+各种Margin计算出cell的高度。但是这种方法有个巨大的缺陷就是数据和界面是割裂的，你不得不在调完了UI后还要去计算高度的方法里再改一通。阅读和维护这部分逻辑时也会比较麻烦</p>
<p>或许已经有人想到了把计算高度的方法放到cel里面，然后把那些Margin做成常量，然后把数据传入cell来计算高度，这样当你修改内部的Margin时，高度计算的方法会不用做任何修改。不错，这个办法已经部分解决了上面的部分问题。不过当你调整UI以后对应的高度计算方法肯定会需要根据UI重写一遍，上述的问题还是存在。那有没有什么更简单的方法呢</p>
<p>答案是肯定的。苹果在iOS8提出了Self-Sizing Cell的概念。只要你用Autolayout对cell进行约束布局，当约束足够清晰时，Cell就能自动计算出自己的高度。如果后续UI有变化，也仅仅只需要调整控件以及相关的约束就行。</p>
<h3 id="Self-Sizing-Cell的解决方案"><a href="#Self-Sizing-Cell的解决方案" class="headerlink" title="Self-Sizing Cell的解决方案"></a>Self-Sizing Cell的解决方案</h3><p>理想很丰满，现实很骨感。Self-Sizing Cell可以解决问题，但是它自身也有它自己的问题。</p>
<p>首先Self-Sizing Cell必须使用Autolayout布局，用Frame方式布局从iOS诞生就开始了，只要稍稍有点历史的项目，在维护中肯定会遇到用Frame布局的Cell。所以不能使用纯Autolayout布局的方案。</p>
<p>其次是Self-Sizing Cell本身的设计策略，导致它有一定的性能嫌疑。在iOS8之前，TableView会缓存下Cell的高度，反复滑动Cell不会重复计算；但是在iOS8以后，苹果认为Cell可能会随时改变大小（用户在设置里面调整字体什么的）所以不会做缓存了，这就导致了同一个Cell在反复滑动的时候会反复计算高度。</p>
<p>最后是iOS6、7、8三个版本中关于高度计算API不一致的问题：<br>在iOS6上，我们是在<code>tableView:heightForRowAtIndexPath:</code>方法里返回通过数据计算的高度；而在在iOS7中，出现了<code>estimatedRowHeight</code>相关的属性，苹果通过这个属性把计算的工作从TableView加载时延迟到了Cell出现时，提高了TableView的加载速度；在iOS8中只需要写<code>self.tableView.estimatedRowHeight = RowHeight</code>这样的一行代码就能自动计算出Cell的高度(前提是Cell使用Autolayout写的布局)。可以看到随着苹果对Cell高度计算的不断优化让代码越来越简单，但是越简单的API需要的iOS版本越高，如果App要兼容低版本，就不得不在工程里写很多冗余的兼容性代码。</p>
<p>那如何能解决上面的这些问题呢，答案就是<code>UITableView+FDTemplateLayoutCell</code>。</p>
<h3 id="UITableView-FDTemplateLayoutCell简介"><a href="#UITableView-FDTemplateLayoutCell简介" class="headerlink" title="UITableView+FDTemplateLayoutCell简介"></a><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">UITableView+FDTemplateLayoutCell</a>简介</h3><p>关于UITableView+FDTemplateLayoutCell我就直接把<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">作者</a>的原话扒过来。</p>
<blockquote>
<p>使用<code>UITableView+FDTemplateLayoutCell</code>无疑是解决算高问题的最佳实践之一，既有 iOS8<br>self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。 使用起来大概是这样： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    return [tableView fd_heightForCellWithIdentifier:@&quot;identifer&quot; cacheByIndexPath:indexPath configuration:^(id cell) &#123;</span><br><span class="line">        &#x2F;&#x2F; 配置 cell 的数据源，和 &quot;cellForRow&quot; 干的事一致，比如：</span><br><span class="line">        cell.entity &#x3D; self.feedEntities[indexPath.row];</span><br><span class="line">    &#125;]; &#125; </span><br></pre></td></tr></table></figure>
<p>写完上面的代码后，你就已经使用到了：</p>
<ul>
<li>和每个 UITableViewCell ReuseID 一一对应的 template layout cell<br>这个 cell 只为了参加高度计算，不会真的显示到屏幕上；它通过 UITableView 的 <code>-dequeueCellForReuseIdentifier:</code> 方法 lazy 创建并保存，所以要求这个 ReuseID 必须已经被注册到了 UITableView 中，也就是说，要么是 Storyboard 中的原型 cell，要么就是使用了 UITableView 的 <code>-registerClass:forCellReuseIdentifier:</code> 或 <code>-registerNib:forCellReuseIdentifier:</code>其中之一的注册方法。</li>
<li>根据 autolayout 约束自动计算高度<br>使用了系统在 iOS6 就提供的 API：<code>-systemLayoutSizeFittingSize:</code></li>
<li>根据 index path 的一套高度缓存机制<br>计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了非常可观的多余计算。</li>
<li>自动的缓存失效机制<br>无须担心你数据源的变化引起的缓存失效，当调用如<code>-reloadData</code>，<code>-deleteRowsAtIndexPaths:withRowAnimation:</code>等任何一个触发 UITableView 刷新机制的方法时，已有的高度缓存将以最小的代价执行失效。如删除一个 indexPath 为 [0:5] 的 cell 时，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。</li>
</ul>
</blockquote>
<h3 id="UITableView-FDTemplateLayoutCell代码分析"><a href="#UITableView-FDTemplateLayoutCell代码分析" class="headerlink" title="UITableView+FDTemplateLayoutCell代码分析"></a>UITableView+FDTemplateLayoutCell代码分析</h3><p>好了，上面说了<code>UITableView+FDTemplateLayoutCell</code>具有这么多功能，那这部分就来分析一下这些功能的实现方式。先说一下实现的方式路再上代码。</p>
<h4 id="高度计算"><a href="#高度计算" class="headerlink" title="高度计算"></a>高度计算</h4><p><code>UITableView+FDTemplateLayoutCell</code>在TableVie内部维护了一个模板Cell结构，它不会加入TableView中，模板Cell会自动调用Cell默认的方法实例化，然后根据传入的数据对这个模板进行填充，再计算高度。Cell的高度计算使用了两种方式，一种针对于Autolayout写的Cell调用<code>[cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize]</code>自动计算行高；另一种是对于Frame调用<code>[cell sizeThatFits:CGSizeMake(contentViewWidth, 0)]</code>手动计算行高。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>基于NSDictionary的缓存。如果调用的是带缓存的API，那在计算出高度后会缓存结果，下次再计算时会先查询缓存。这个框架已经把会引起TableView重新加载的方法都做了替换，在这些方法被调用时会先清空缓存再调用以前的方法。</p>
<p><code>- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration;</code></p>
<p>这个方法是高度计算的核心，API很简单，<code>identifier</code>是复用的标识，<code>configuration</code>主要用于你来用数据填充Cell<br>下面来看一下内部的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration &#123;</span><br><span class="line">    </span><br><span class="line">    UITableViewCell *templateLayoutCell &#x3D; [self fd_templateCellForReuseIdentifier:identifier];</span><br><span class="line">    </span><br><span class="line">    [templateLayoutCell prepareForReuse];</span><br><span class="line">    </span><br><span class="line">    if (configuration) &#123;</span><br><span class="line">        configuration(templateLayoutCell);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为了突出主干逻辑，删掉了断言还有注释以及一部分非必要逻辑。从代码上看流程非常清晰，第一行获取到模板Cell，然后调用Cell的<code>prepareForReuse</code>方法来确保对Cell的调用行为和真实的一样(其实如果你所有的cell都没有在<code>prepareForReuse</code>方法里面写初始化代码的话，那这一行可有可无)。接着调用<code>configuration</code>来配置模板Cell，然后调用<code>[self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell]</code>来计算高度。</p>
<p>下面来深入<code>fd_systemFittingHeightForConfiguratedCell:</code>这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)fd_systemFittingHeightForConfiguratedCell:(UITableViewCell *)cell &#123;</span><br><span class="line">    CGFloat contentViewWidth &#x3D; CGRectGetWidth(self.frame);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    if (cell.accessoryView) &#123;</span><br><span class="line">        contentViewWidth -&#x3D; 16 + CGRectGetWidth(cell.accessoryView.frame);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        static const CGFloat systemAccessoryWidths[] &#x3D; &#123;</span><br><span class="line">            [UITableViewCellAccessoryNone] &#x3D; 0,</span><br><span class="line">            [UITableViewCellAccessoryDisclosureIndicator] &#x3D; 34,</span><br><span class="line">            [UITableViewCellAccessoryDetailDisclosureButton] &#x3D; 68,</span><br><span class="line">            [UITableViewCellAccessoryCheckmark] &#x3D; 40,</span><br><span class="line">            [UITableViewCellAccessoryDetailButton] &#x3D; 48</span><br><span class="line">        &#125;;</span><br><span class="line">        contentViewWidth -&#x3D; systemAccessoryWidths[cell.accessoryType];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    CGFloat fittingHeight &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    if (!cell.fd_enforceFrameLayout &amp;&amp; contentViewWidth &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">        NSLayoutConstraint *widthFenceConstraint &#x3D; [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:contentViewWidth];</span><br><span class="line">        [cell.contentView addConstraint:widthFenceConstraint];</span><br><span class="line">        </span><br><span class="line">        fittingHeight &#x3D; [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;</span><br><span class="line">        [cell.contentView removeConstraint:widthFenceConstraint];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (fittingHeight &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        fittingHeight &#x3D; [cell sizeThatFits:CGSizeMake(contentViewWidth, 0)].height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    return fittingHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法首先获取到Cell的宽度，得到宽度后根据是否有自定义的accessoryView来调整Cell的宽度。（这里关于关于静态数组systemAccessoryWidths的使用可能不太常见，这个是C的写法，就是静态不定长度的数组的初始化，这里面数组的长度等于花括号里面给出的最大索引值+1，其他没有给定明确初始值的都是0）然后调用 <code>[cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize]</code>来自动计算出Cell的高度，这里在计算之前临时添给Cell.contentView添加了一个和Cell等宽的约束是为了让内部View知道自己的父View的大小，减少因无法得知contentView的宽度而导致约束计算失败的情况。最后一步是判断Autolayout计算的结果是否正确，因为需要兼容使用Frame布局的Cell的情况，当Autolayout计算失败后再尝试着调用<code>[cell sizeThatFits:CGSizeMake(contentViewWidth, 0)]</code>来计算高度。</p>
<p>下面来看带缓存的方法:</p>
<p><code>- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration</code></p>
<p><code>- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id&lt;NSCopying&gt;)key configuration:(void (^)(id cell))configuration</code></p>
<p>这两个方法一个是按IndexPath做缓存一个是按Key做缓存。两者都是基于NSDictionary实现的，按Key缓存比较简单，内部实现基本上可以理解为cache[Key]=rowHeight这样的形式，具体的代码就不赘述。IndexPath缓存因为涉及IndexPath数组的增删改的操作而稍稍复杂一点，不过虽然比前者复杂但是本质也是在维护一个NSDictionary，这里就不再详细介绍，而是讲一下IndexPath缓存中实现的比较有意思的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)buildSectionsIfNeeded:(NSInteger)targetSection &#123;</span><br><span class="line">    [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123;</span><br><span class="line">        for (NSInteger section &#x3D; 0; section &lt;&#x3D; targetSection; ++section) &#123;</span><br><span class="line">            if (section &gt;&#x3D; heightsBySection.count) &#123;</span><br><span class="line">                heightsBySection[section] &#x3D; [NSMutableArray array];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里面有意思的地方在于当你传入的Section如果大于当前的最大Section时，会自动创建后续的所有Section，比如现在Section数组有3个元素，然后你的入参为20，那这个循环会创建剩下的17个Section数组。这里作者用到了一个NSMutableArray的一个不太常用的语法，就是<code>NSMutableArray[最大索引值]=NewItem</code>，这个等价于<code>[NSMutableArray addObject:NewItem]</code>，使用不太常见的语法让代码更精炼的例子在这个框架里面还有几个，可见作者OC的基本功非常扎实。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)fd_deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation &#123;</span><br><span class="line">        [sections enumerateIndexesUsingBlock:^(NSUInteger section, BOOL *stop) &#123;</span><br><span class="line">            [self.fd_indexPathHeightCache buildSectionsIfNeeded:section];</span><br><span class="line">            [self.fd_indexPathHeightCache enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123;</span><br><span class="line">                [heightsBySection removeObjectAtIndex:section];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)fd_moveSection:(NSInteger)section toSection:(NSInteger)newSection &#123;</span><br><span class="line">        [self.fd_indexPathHeightCache buildSectionsIfNeeded:section];</span><br><span class="line">        [self.fd_indexPathHeightCache buildSectionsIfNeeded:newSection];</span><br><span class="line">        [self.fd_indexPathHeightCache enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123;</span><br><span class="line">            [heightsBySection exchangeObjectAtIndex:section withObjectAtIndex:newSection];</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码有意思的地方是作者的编程的思路。删除或者移动索引的时候可能相应的索引可能并不存在，有的人会在这里先判断，然后根据不同情况做不同的处理，这样做肯定是没问题的。不过作者在这里的做法是统统调一遍<code>[self.fd_indexPathHeightCache buildSectionsIfNeeded:section]</code>保证索引肯定存在，避免了加一些冗长的判断语句，代码比显得较干净。这里把未知问题转换成已知问题的思路体现得淋漓尽致，而且特别能体现出程序设计的模块化设计与复用的美感。</p>
<p>好了，到这里<code>UITableView+FDTemplateLayoutCell</code>的分析就写完了，可能有的人会感觉怎么才这点东西。东西确实不多，因为这个框架本身很简单，全部代码加上注释才600多行代码。不过见微知著，寥寥几百行代码体现了作者良好的编程思维以及扎实的语言基本功。这也是我们需要学习的地方。</p>
<h3 id="UITableView-FDTemplateLayoutCell集成"><a href="#UITableView-FDTemplateLayoutCell集成" class="headerlink" title="UITableView+FDTemplateLayoutCell集成"></a>UITableView+FDTemplateLayoutCell集成</h3><p>其实最后一部分内容很少。主要是针对于老的使用Frame布局的Cell使用这个框架的实践。前面也说过如果用Autolayout的Cell是自动计算的，Frame布局的Cell是通过<code>[cell sizeThatFits:CGSizeMake(contentViewWidth, 0)]</code>来做，所以需要把Frame布局的Cell的<code>sizeThatFits</code>方法重载，因为<code>sizeThatFits</code>方法没有入参，所以需要让Cell持有数据Model，然后在<code>sizeThatFits</code>里调用以前计算高度的方法就行了。这里Cell持有数据Model可以用weak的属性来修饰，避免可能的引用循环问题。</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>他山之石，可以攻玉。这篇文章的核心就是基于<code>UITableView+FDTemplateLayoutCell</code>的工程实践，感谢作者sunnyxx的无私奉献。sunnyxx的博客中还有不少有深度的iOS技术分析。这里贴一下他的</p>
<p><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">博客地址：</a><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/</a></p>
<p><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">GitHub地址：</a><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a></p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS界面渲染机制]]></title>
      <url>http://petpwiuta.github.io/2016/10/07/advanced_graphics_and_animation_performance/</url>
      <content type="html"><![CDATA[<h3 id="Core-Animation-Pipeline"><a href="#Core-Animation-Pipeline" class="headerlink" title="Core Animation Pipeline"></a>Core Animation Pipeline</h3><p>Core Animation是iOS和Mac OS界面渲染的核心组件，其实动画仅仅算是本身的部分功能，所以这个这个组件的名字不太贴切。桌面和移动端的GPU性能差别很大，所以两端的组件底层细节估计会不一样，这个主要是讲iOS系统上的Core Animation的工作流程。</p>
<p>当你把一个View提交到视图树上并写好约束以后，系统会先进行layot确定其在屏幕上的位置，然后根据是否重载draw方法来调用draw函数（如果重写了就调用），并把绘制结果转换成位图保存起来，再把视图中的图片等数据解压成bitmap或者做一些变换，最后再按照视图树递归式把树形结构打包成数据模型发送给渲染进程，整个过程称之为Commit Transaction。</p>
<p>渲染进程收到IPC调用以后把收到的数据还原成树形结构，经过一些处理逻辑后，调用硬件的绘制方法完成绘制。整个流程如下图所示：</p>
<p><img src="/images/advanced_graphics_and_animation_performance/cap1.png" style="zoom:100%" /></p>
<p>Commit Transaction 主要有4个过程：</p>
<ol>
<li><p>Layout</p>
<p>在这个阶段会按照视图树调用view的layoutSubviews方法，以及数据库查询、一些业务逻辑计算等。这个阶段一般是CPU或IO密集型操作。</p>
</li>
<li><p>Draw</p>
<p>调用<code>drawRect:</code> 方法来绘图，以及绘制文本，一般是CPU或者内存密集型操作。</p>
</li>
<li><p>Prepare</p>
<p>做一些提交前的准备工作，如图片解码（如果是压缩图片的话，会解压成bitmap），或者图片格式转换。</p>
</li>
<li><p>Commit</p>
<p>把layer tree打包成数据模型发送渲染进程，这个过程是递归进行的，所以如果layer tree比较复杂的话，这个过程会很花时间。</p>
</li>
</ol>
<h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><p>iOS动画的执行需要先了解iOS中的视图树和呈现树。视图树存储的就是视图的树形结构，当的执行下面类似的代码时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:1 animations:^&#123;</span><br><span class="line">        view.frame &#x3D; CGRectMake(new, new, new, new);</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<p>对视图树的修改会立即生效，设置了新的frame后马上再读发现值已经是最新的了，视图树始终存储着是最终的值。反之呈现树就是当前view的数值，当在做一段动画效果时，可以通过<code>self.view.layer.presentationLayer</code>来获取呈现树的值。它的值会随着动画的执行而变化。</p>
<p>当给一个View添加动画时，可以分为3个阶段：</p>
<ol>
<li>创建动画效果，一般就是用UIView的block方法来创建隐式动画</li>
<li>向渲染进程提交动画请求，这个过程和前面的Core Animation Pipeline一样</li>
<li>渲染进程解析出动画对象，根据持续时间和效果插值绘制对应的动画效果</li>
</ol>
<p><img src="/images/advanced_graphics_and_animation_performance/cap2.png" style="zoom:100%" /></p>
<h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><p>iOS的GPU以前是用的Imagination的PowerVR架构，后来和Imagination闹掰，但是GPU架构基本上还是沿袭了PowerVR那一套的设计。PowerVR的看家本领就是Tile Based Deferred Rendering（TBDR），字面意义就是分片式延迟渲染。</p>
<p>这种渲染方式是先把屏幕分割成一定大小的独立区域（例如32px * 32px），如图3-1所示，这样GPU每次仅仅处理一个小块，因为移动GPU的总线带宽有限，所以分解成多块能减轻带宽压力。</p>
<p>在TBDR的渲染流水线里，几何阶段生成（已经经过裁剪，屏幕外的部分已经被丢弃）的多边形或者说三角形参数信息都存放在一个名为Parameter Buffer缓存里（这个缓存在soc芯片上，类似于桌面cpu的L1、L2缓存），理论上里面保存的应该是同一帧画面里的所有三角形信息，为了提高能效，GPU会对所有三角形运行HSR算法（Hidden Surface Removal，隐面消除，这里的隐面是指被其他实体多边形遮盖的多边形）来消除被挡住的部分，最终只渲染屏幕上能看到的三角形所覆盖的片元。</p>
<p>这一步是TBDR独有的，相较之下，传统的GPU在几何阶段扔出到三角形后纹理单元/着色单元就马上渲染，因此人们将传统的GPU渲染方式称作立即渲染器。把上面的加入了HSR逻辑的叫做延迟渲染。</p>
<p><img src="/images/advanced_graphics_and_animation_performance/cap3.png" style="zoom:30%" />       <img src="/images/advanced_graphics_and_animation_performance/cap4.png" style="zoom:29%" />          <img src="/images/advanced_graphics_and_animation_performance/cap5.png" style="zoom:29%" /></p>
<p>​            图3-1                                                         图3-2                                                                     图3-3</p>
<p>得到屏幕上能看到的三角形以后，会把这些数据发送到后续的光栅化流程中去，在经过后续的处理后GPU就绘制出了对应的像素，最后输出到frame buffer中。</p>
<p><img src="/images/advanced_graphics_and_animation_performance/cap6.png" style="zoom:40%" /></p>
<h3 id="复杂效果的渲染"><a href="#复杂效果的渲染" class="headerlink" title="复杂效果的渲染"></a>复杂效果的渲染</h3><p>在上一节说的是简单效果的渲染，如果效果中有遮罩，毛玻璃等较复杂的效果，则需要经过多次简单渲染后才能达到最终效果。</p>
<ul>
<li><p>遮罩效果</p>
<p>遮罩效果是经过3次简单渲染流程合成的，第一步先渲染出遮罩层；接着再渲染出类容，然后最后一步是把前两步的结果再合并起来，得到最终结果。这里绘制的图像并不是直接绘制到frame buffer中，所以也叫做离屏渲染。在实际开发中，经常会用到圆角，一般是设置<code>cornerRadius</code>和<code>masksToBounds</code>两个属性，其实这两个属性都设置时就是在layer上添加了一个遮罩效果，所以也会触发离屏渲染。</p>
<p>不过离屏渲染并不是总是低效的，这里是GPU用硬件来离屏渲染，所以速度仍然很快。如果重载draw方法来绘图，这种离屏渲染是CPU来执行，而且渲染后还要再发送到GPU中处理，效率就比前者低很多。</p>
<p><img src="/images/advanced_graphics_and_animation_performance/cap7.png" style="zoom:50%" /></p>
</li>
</ul>
<ul>
<li><p>毛玻璃效果</p>
<p>毛玻璃效果的主要流程和遮罩差不多，就是流程会多很多步，最终效果需要由5个中间步骤合成。所以毛玻璃效果对硬件的要求比较高。</p>
<p><img src="/images/advanced_graphics_and_animation_performance/cap8.png" style="zoom:50%" /></p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.evolife.cn/html/2016/87798_5.html" target="_blank" rel="noopener">移动图形芯片的故事（上）GPU是什么鬼？</a></p>
<p><a href="https://www.evolife.cn/html/2016/87847_2.html" target="_blank" rel="noopener">移动图形芯片的故事（下）IMR与TBR/TBDR两大流派的爱恨情仇</a></p>
<p><a href="https://www.imgtec.com/blog/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/" target="_blank" rel="noopener">A look at the PowerVR graphics architecture: Tile-based rendering</a></p>
<p><a href="https://www.imgtec.com/blog/the-dr-in-tbdr-deferred-rendering-in-rogue/" target="_blank" rel="noopener">A look at the PowerVR graphics architecture: Deferred rendering</a></p>
<p><a href="https://www.imgtec.com/blog/dialling-it-up-on-powervr-gpus-how-to-optimise-automotive-dashboards-for-efficient-rendering/" target="_blank" rel="noopener">Dialling it up on PowerVR GPUs: how to optimise automotive dashboards for efficient rendering</a></p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS事件处理]]></title>
      <url>http://petpwiuta.github.io/2016/10/07/event_chain/</url>
      <content type="html"><![CDATA[<h2 id="定义手势识别如何交互"><a href="#定义手势识别如何交互" class="headerlink" title="定义手势识别如何交互"></a>定义手势识别如何交互</h2><h3 id="1-有限状态机中手势识别的操作"><a href="#1-有限状态机中手势识别的操作" class="headerlink" title="1 有限状态机中手势识别的操作"></a>1 有限状态机中手势识别的操作</h3><p> 手势识别器使用状态机来进行控制。识别器所在的每一个状态，都会依照它们所符合的特定条件向另一个可能的状态进行跳转。如图1-3所示。所有的状态识别器都会有一个初始的状态(UIGestureRecognizerStatePossible)，然后分析其所接收到的所有的多点触摸序列，分析的过程中，对应的手势要么成功识别、要么失败。如果失败，那就意味着将手势识别器的状态转向“失败状态(UIGestureRecognizerStateFailed)”。</p>
<p><img src="/images/event_chain/gesture_state.png" alt="gesture_state" style="zoom:50%;" /></p>
<p>对于非持续手势识别，如果是被成功，就会从某个状态转向“已识别(UIGestureRecognizerStateRecognized)”状态 ，也就意味着手势分析的整个过程完成。 </p>
<p>对于持续手势识别，一旦识别成功，则会首先从某个状态转向“已开始(UIGestureRecognizerStateBegan)”状态 ，当手势持续操作并运动时就会由“已开始”转到 “已变化(UIGestureRecognizerStateChanged)”  并持续由该状态继续，当用户的最后一根手指离开视图进行操作，就会转入“已结束(UIGestureRecognizerStateEnded)”状态，该手 势识别过程也就结束。需要注意的是，结束状态也是手势识别状态的一个。</p>
<p>如果连续手势识别发现用户的手势不符合预期的模式，其状态也可能从“已改变”状态，转到“已取消(UIGestureRecognizerStateCancelled)”状态。手势识别器的状态每次发生改变，都会向其目标对象发送一条消息，除非其状态转为“失败”或者“取消”。如此，非持续的手势识别器的状态发生转变，就发送一个消息给其目标对象，连续手势识别器，则会连续发送许多消息。</p>
<p>当手势识别器状态转为“已识别”或者“已结束”时，其状态值就会被重置到初始状态， 转向初始状态时不会触发消息发送。</p>
<h3 id="2-与其他手势识别器进行交互"><a href="#2-与其他手势识别器进行交互" class="headerlink" title="2 与其他手势识别器进行交互"></a>2 与其他手势识别器进行交互</h3><p>视图对象可以添加多个手势识别器， <code>gestureRecognizers</code> 属性可以查看所有的手势识别器。 <code>addGestureRecognizer</code> 和 <code>removeGestureRecognizer</code> 方法能增加或删除手势识别器。</p>
<p>视图添加多个手势识别器时，默认情况下，手势识别器的相应顺序是随机的，所以每次用户的手势触摸操作都可能由不同的手势识别器接受到并被处理。所以需要有指定手势识别器优先级的能力。开发者就想要修改此“默认”设定，已达到以下目的:</p>
<p>• 指定某个识别器优先于另一个识别器，来接收并处理用户的触摸操作。 </p>
<p>• 让两个识别器同时进行操作处理。</p>
<p>• 阻止某个手势识别器对某个触摸操作进行分析。</p>
<p>使用被 UIGestureRecognizer 子类覆盖重写的的类方法、代理方法以及成员函数方法来改 变这些行为操作。</p>
<h4 id="2-1-申明两个识别器的特定顺序"><a href="#2-1-申明两个识别器的特定顺序" class="headerlink" title="2.1 申明两个识别器的特定顺序"></a>2.1 申明两个识别器的特定顺序</h4><p>假设开发者想要识别用户的“滑动(swipe)”和“平移(pan)”手势，而这两个手势需要触发两个不同的消息。默认情况下，当用户进“滑动(swipe)”操作时，这个手势会被默认识别为“平移(pan)”。这是因为“滑动”手势操作在被系统识别为“滑动”手势(持久的连续性手势)之前，系统进行判断时，发现其操作行为完全符合“平移”(这是一个瞬发的非持续手势)操作的所有必要的属性条件，所以系统就将其识别为“平移”。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123; </span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span>.panRecognizer requireGestureRecognizerToFail:<span class="keyword">self</span>.swipeRecognizer]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用该方法的手势识别器 A 会给接收消息的手势识别器 B 发送一个消息，指定一定是 B 对手势操作识别失败之后，A 才开始接收并分析用户的手势操作。在 A 进行等待 B 对用户的手势操作进行分析并直到识别失败的过程中，A 的状态一直会处于某个可能初始状态， 除非B到达了分析识别“失败”的状态，A才开始分析并开始转向下一个状态。另一方面，如果 B 识别成功或者识别(成功)开始，A 就会被转向失败状态。</p>
<h4 id="2-2-禁止手势识别器进行触摸分析"><a href="#2-2-禁止手势识别器进行触摸分析" class="headerlink" title="2.2 禁止手势识别器进行触摸分析"></a>2.2 禁止手势识别器进行触摸分析</h4><p>通过给识别器添加代理对象，开发者可以修改识别器的行为。协议 UIGestureRecognizerDelegate 提供了几个方法给开发者用来禁止手势识别器的触摸分析功 能。<code>gestureRecognizer:shoulReceiveTouch:</code>和 <code>gestureRecognizerShouldBegin:</code>两个方法都可选用。</p>
<p>当用户“触摸”操作开始时，开发者可以使用 <code>gestureRecognizer:shoulReceiveTouch:</code>方法立即决定手势识别器是否需要处理用户的操作。每当“触摸”发生，该方法就会被调用。 如果不想对用户的触摸操作进行处理直接将该方法返回“NO”即可，默认情况下返回的 是“YES”。该方法并不会修改识别器的状态值。</p>
<h4 id="2-3-允许手势识别同时异步进行"><a href="#2-3-允许手势识别同时异步进行" class="headerlink" title="2.3 允许手势识别同时异步进行"></a>2.3 允许手势识别同时异步进行</h4><p>默认情况下，两个不同的手势识别器是不允许同时对手势进行识别处理的，但是假如开发者想要让用户在对某个视图同时进行捏合缩放和旋转操作，开发者就需要改变此默认设 定，通过实现方法 <code>gestureRecognizer:shouldRecognizeSimutaneouslyWithGestureRecognizer:</code> 可以达到此目的，这是由协议 UIGestureRecognizerDelegate 提供的一个可选方法。该方法会在某个识别器进行手势事件识别处理时被调用，从而决定是否需要􏰀定事件不让其他识 别器进行识别处理。默认情况下，该方法返回“NO”，如果开发者想要两个不同的手势 识别器同时对手势进行识别处理，让该方法返回“YES”即可。</p>
<blockquote>
<p>备注:开发者只需要对其中一个手势的代理对象实现该方法并返回YES即可。这就意味着，两 个手势识别器中只要有一个返回YES，另外一个返回NO就不起作用了。</p>
</blockquote>
<h4 id="2-4-指定两个手势识别器的单向关系"><a href="#2-4-指定两个手势识别器的单向关系" class="headerlink" title="2.4 指定两个手势识别器的单向关系"></a>2.4 指定两个手势识别器的单向关系</h4><p>如果开发者想让两个识别器进行交互，但是指定为一种单向关系，开发者就可以通过重写方法 <code>canPreventGestureRecognizer:</code>或者 <code>canBePreventedByGestureRecognizer:</code>之一并返回</p>
<p>“NO”(默认返回的是“YES”)来达到此目的。举个例子，如果想要在进行旋转操作的</p>
<p>时候屏蔽掉捏合缩放操作、而在捏合缩放操作的时候可以进行旋转，开发者就可以这样设</p>
<p>置 <code>[rotationGestureRecognizer canPreventGestureRecognizer:pinchGestureRecognizer]</code></p>
<p>然后重写“旋转”手势识别器的子类方法并返回“NO”。关于如何创建继承 UIGestureRecognizer 子类的信息请参阅“创建自定义手势识别器”章节。</p>
<p>如果这两个手势识别器需要同时进行不相互干预，请参阅章节 2.3.默认情况下，这两个不同的手势识别器是不能同时进行手势识别操作的，也就是互相屏蔽的，其中任何一个处于活动状态，另外一个都是被屏蔽的。</p>
<h2 id="与其他用户界面操作进行交互"><a href="#与其他用户界面操作进行交互" class="headerlink" title="与其他用户界面操作进行交互"></a>与其他用户界面操作进行交互</h2><p>在 iOS6 以及之后的版本中，默认情况下，所有的控制器都不允许手势识别器重复交叠。 比如，按钮(button)的默认操作行为是“单击”，然后，有一个“按钮”所在的视图 (view)绑定了一个“单击”手势识别器对手势进行处理，当用户“单击”这个按钮的时候，按钮指定的动作处理方法会接收到这个“单击”事件，然而视图的手势识别器却接收不到。</p>
<p>这种策略仅应用于: <em>UIButton</em>，<em>UISwitch</em>，<em>UISlider</em>，<em>UIStepper</em>，<em>UISegementedControl</em> 和 <em>UIPageControl</em> 上的单击或者滑动事件。</p>
<p>如果自定义控件继承自以上的类，又想要改变系统的默认设定，那就应该直接将手势识别器和其子类控件进行绑定，而不是和控件的父视图或者其他上层控件进行绑定。只有这样，手识别器才会优先接收到用户的触摸操作事件。</p>
<h2 id="手势识别器处理原生触摸事件"><a href="#手势识别器处理原生触摸事件" class="headerlink" title="手势识别器处理原生触摸事件"></a>手势识别器处理原生触摸事件</h2><h3 id="1-点击事件的数据结构"><a href="#1-点击事件的数据结构" class="headerlink" title="1 点击事件的数据结构"></a>1 点击事件的数据结构</h3><p>在 iOS 中，每一个“触摸(touch)”行为对象就代表单根手指在屏幕上的一次运动操作。一个“手势(gesture)”可以有一个或者多个“触摸”行为对象，在 iOS 中以 UITouch 类对象进行抽象表示。例如，一个捏合缩小手势就有两个“触摸”行为对象：两根手指在屏幕上以相反运动方向相互靠拢运动。</p>
<p>一个事件(Event)包含了这次多点触摸行为序列的所有“触摸”对象。一个多点触摸行为序列开始于用户第一根手指触摸到屏幕、终止于用户的最后一根手指抬起并离开屏幕。 当一根手指进行运动时，iOS 系统就会实例化 UITouch 对象并发送给对应的事件对象。一个多点触摸事件会被抽象成一个类型为 UIEventTypeTouches 的 UIEvent 对象。</p>
<p>每一个“触摸”对象都只追踪一根手指的轨迹，其生命周期也仅限于整个触摸序列的起止期间。在此这段时间内，UIKit 跟踪手指的轨迹并及时更行其对象的属性。这些属性包括触摸的行为的方式、在当前视图对象中的位置、之前的位置以及时间戳。</p>
<h3 id="2-App在”触摸处理“方法中接受”触摸“对象"><a href="#2-App在”触摸处理“方法中接受”触摸“对象" class="headerlink" title="2 App在”触摸处理“方法中接受”触摸“对象"></a>2 App在”触摸处理“方法中接受”触摸“对象</h3><p>在一次多点触摸序列事件中，当有新的触摸行为或者触摸行为发生变化时，app 会发送以下消息：</p>
<ul>
<li><em>touchesBegan:withEvent:</em> 当一个或者多根手指开始触摸屏幕时调用。</li>
<li><em>touchesMoved:withEvent:</em> 当手指开始移动时调用。</li>
<li><em>touchesEnded:withEvent:</em> 当有手指离开屏幕时调用。</li>
<li><em>touchedCancelled:withEvent:</em> 当触摸序列事件被系统事件取消时调用，比如来了电话。</li>
</ul>
<p>以上每一个方法都对应着一个“触摸阶段”，比如第一个方法会和 UITouchPhaseBegan 相对应。它的值存储在 UITouch 的 phase 属性中。</p>
<h2 id="调整触摸事件路由"><a href="#调整触摸事件路由" class="headerlink" title="调整触摸事件路由"></a>调整触摸事件路由</h2><h3 id="1-默认行为"><a href="#1-默认行为" class="headerlink" title="1 默认行为"></a>1 默认行为</h3><p>默认情况下，事件会优先发送给手势识别器进行识别，当手势识别器识别失败后才会发送给同层级的视图。如果识别成功，同层级的视图不会受到触摸事件。</p>
<p>当触摸事件发生时，UITouches 触摸对象会先由 UIApplication 对象传递给 UIWindow 对象，然后，在传递给最底层的视图对象之前，UIWindow 对象会逐层向下， 将“触摸”对象传递给触摸事件发生位置所在的视图对象所绑定的手势识别器进行识别处理。</p>
<p>window 对象会延迟将“触摸”对象发送给视图对象，从而让手势识别器最先对“触摸” 进行分析处理。在延迟期间，如果识别器识别出来触摸手势，window 对象就不会将“触摸对象”传递给视图对象了，并将识别出来的手势序列中其他之前本该发送给视图对象的触摸对象取消掉。</p>
<p><img src="/images/event_chain/gestureandview.png" alt="gestureandview" style="zoom:50%;" /></p>
<h3 id="2-修改默认行为"><a href="#2-修改默认行为" class="headerlink" title="2 修改默认行为"></a>2 修改默认行为</h3><p>UIGestureRecognizer 的下面这些属性可以调整事件传递的顺序：</p>
<ul>
<li><p>delaysTouchesBegan(默认值是 NO)。通常情况下，window 会在 Began 和 Moved 阶 段将触摸事件发送给 view 和手势识别器对象。如果将此属性值设置成 YES，window 就不会在 Began 阶段将“触摸”(UITouch)对象发送给视图对象，这样可以保证当手势识别器识别到某个手势时，就不有任何相关的 UITouch 对象被发送给 绑定的视图。</p>
<p>该属性值的设置类似于 UIScrollView 的 delaysContentTouches 属性;在这种情况 下，UIScrollView 就立即随着用户“触摸”动作的进行滚动，而不会将“触摸” (UITouch)对象发送给 SrollView 的子视图对象，所以也就不会有视觉上的反馈效果。</p>
</li>
</ul>
<ul>
<li>delaysTouchesEnded(默认值为 YES)。当该属性被设置成 YES 时，可以保证视图对象的动作处理不会结束，这样一来该手势动作还有机会被取消。当手势识别器对触摸事件进行分析时，在 End 阶段window 不会将 UITouch 对象发送给发绑定的视图。如果识别器成功识别出来手势操作，UITouch 对象会被取消掉;若是识别 失败，window 对象就会将它们通过消息 touchesEnded:wihtEvent:发送给视图对象。如果将该属性值设置成 NO，就会把这些“触摸”(UITouch)对象发送给手势识别器的同时，也发送给视图对象进行分析处理。</li>
</ul>
<h2 id="自定义手势"><a href="#自定义手势" class="headerlink" title="自定义手势"></a>自定义手势</h2><p>自定义手势需要实现下列方法，在实现方法时，注意需要先调用父类方法。另外还需要精确设置state属性，系统是严格根据state属性来进行手势状态识别的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)reset;</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure>
<h4 id="1-自定义手势的事件处理方法"><a href="#1-自定义手势的事件处理方法" class="headerlink" title="1 自定义手势的事件处理方法"></a>1 自定义手势的事件处理方法</h4><p>创建了一个非持续手势单指触摸的对勾手势识别器。通过记录手势操作的中心点、亦即向上勾动的转折位置点，所以就可以让外部捕获该坐标点的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit&#x2F;UIGestureRecognizerSubclass.h&gt;</span><br><span class="line"> &#x2F;&#x2F; Implemented in your custom subclass</span><br><span class="line"> - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    [super touchesBegan:touches withEvent:event]; </span><br><span class="line">    if ([touches count] !&#x3D; 1) &#123;</span><br><span class="line">        self.state &#x3D; UIGestureRecognizerStateFailed; </span><br><span class="line">        return;</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event &#123; </span><br><span class="line">    [super touchesMoved:touches withEvent:event];</span><br><span class="line">    if (self.state &#x3D;&#x3D; UIGestureRecognizerStateFailed) return; </span><br><span class="line">    UIWindow *win &#x3D; [self.view window];</span><br><span class="line"></span><br><span class="line">    CGPoint nowPoint &#x3D; [touches.anyObject locationInView:win]; </span><br><span class="line">    CGPoint nowPoint &#x3D; [touches.anyObject locationInView:self.view]; </span><br><span class="line">    CGPoint prevPoint &#x3D; [touches.anyObject previousLocationInView:self.view];</span><br><span class="line">    &#x2F;&#x2F; strokeUp is a property</span><br><span class="line">    if (!self.strokeUp) &#123;</span><br><span class="line">        &#x2F;&#x2F; On downstroke, both x and y increase in positive direction</span><br><span class="line">        if (nowPoint.x &gt;&#x3D; prevPoint.x &amp;&amp; nowPoint.y &gt;&#x3D; prevPoint.y) &#123;</span><br><span class="line">            self.midPoint &#x3D; nowPoint;</span><br><span class="line">            &#x2F;&#x2F; Upstroke has increasing x value but decreasing y value</span><br><span class="line">        &#125; </span><br><span class="line">        else if (nowPoint.x &gt;&#x3D; prevPoint.x &amp;&amp; nowPoint.y &lt;&#x3D; prevPoint.y) &#123;</span><br><span class="line">            self.strokeUp &#x3D; YES; &#125; </span><br><span class="line">        else &#123;</span><br><span class="line">            self.state &#x3D; UIGestureRecognizerStateFailed; &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    [super touchesEnded:touches withEvent:event];</span><br><span class="line">    if ((self.state &#x3D;&#x3D; UIGestureRecognizerStatePossible) &amp;&amp; self.strokeUp) &#123;</span><br><span class="line">        self.state &#x3D; UIGestureRecognizerStateRecognized; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    [super touchesCancelled:touches withEvent:event]; </span><br><span class="line">    self.midPoint &#x3D; CGPointZero;</span><br><span class="line">    self.strokeUp &#x3D; NO;</span><br><span class="line">    self.state &#x3D; UIGestureRecognizerStateFailed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连续动作手势的识别和非持续动作手势的识，识别器的状态值的转变是不一样的，在章节 “有限状态机中手势识别的操作”中有介绍。自定义手势识别器时，通过给其状态state 属性赋予相应的值，来指定手势识别对应的连续的还是非持续的手势。对勾手势作为一个非持续手势，就不要给其状态赋予Began或者Changed状态值了。</p>
<p>所以，在进行创建手势识别器的子类进行自定义手势识别时，最重要的一点就是准确为其状态属性state赋予准确的值。iOS系统需根据此状态属性，确保手势识别器能够按照预期对手势进行识别。</p>
<p>欲知更多如何自定义手势识别器知识，请观看《WWDC 2012: Building Advanced Gesture Recognizers 》。</p>
<h4 id="2-重置手势识别器的状态"><a href="#2-重置手势识别器的状态" class="headerlink" title="2 重置手势识别器的状态"></a>2 重置手势识别器的状态</h4><p>如果手势识别器的状态值转为 Recognized(识别成功)/Ended(结束识别)，Canceled (取消)，UIGestureRecognizer 在其状态回滚到 Possible 初始状态前，会调用 reset 方法。</p>
<p>通过实现 reset 方法，将所有的内部状态重置，以便手势识别器可以用于识别用户下一次手势操作，一旦手势识别器从该方法返回之后，就不再对后续的触摸操作进一步更新处理了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)reset &#123; </span><br><span class="line">    super reset];</span><br><span class="line">    self.midPoint &#x3D; CGPointZero;</span><br><span class="line">    self.strokeUp &#x3D; NO; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件响应链"><a href="#事件响应链" class="headerlink" title="事件响应链"></a>事件响应链</h2><p>事件需要投递给负责处理该事件的对象，按优先级从高到低的顺序投递，如此形成的链式责任链就是事件响应链。</p>
<p>单例对象 UIApplication 从事件队列取出事件后，会被转发给 app 的window对象，然后由此 window 对象将事件传递给事件发生所在的对象进行处理，这个初始对象是什么，取决于事件的类型:</p>
<ul>
<li>Touch Event(触摸事件)。对于触摸事件，window对象首先尝试将事件传递给事件发生所在的 view 。该view 就是所谓的 hit-test 对象。寻找 hit-test 对象的过程被称作 hit-testing。</li>
<li>Motion and remote control events(运动和远程控制事件)。对于远程控制和运动事件，window对象会将事件发送给第一响应者(the first responder)进行处理。</li>
</ul>
<h4 id="1-Hit-Testing-过程"><a href="#1-Hit-Testing-过程" class="headerlink" title="1 Hit-Testing 过程"></a>1 Hit-Testing 过程</h4><p>用户在使用手机时，会觉得滑动一个 TableView 然后内容随之滚动是理所应当的事情。但是把视角切换到屏幕和视图树两者时，就会发现两者完全是两个系统。用户本质上是做了在屏幕上移动手指的动作，这和屏幕上显示什么东西没有任何关系。</p>
<p>屏幕上的虚拟对象能响应用户的操作，这中间有着巨大的工作量，其中Hit-Testing 过程是非常重要的一环。经过这个过程以后，系统能把用户在一块玻璃上点击的位置转换成该位置上显示的虚拟对象。</p>
<p>Hit-Testing过程大致如下： 先检查点击的位置是否落在了对应的视图对象的范围内。如果在的话，就开始对此视图对象的子视图对象进行同样的检查。视图树中最底层那个包含此触摸点位置的视图对象，就是要查找的 hit-test 视图对象。一旦确定 hit-test 视图对象，系统就会把触摸事件传递给它进行处理。</p>
<p>举个例子，假设用户触摸了视图 E，如图所示。iOS 就会按照以下顺序对子视图进行 检查来查找 hit-test 视图:</p>
<p><img src="view_inheritance.png" alt="view_inheritance" style="zoom:50%;" /></p>
<ol>
<li>触摸点在视图 A 的区域范围内，然后开始检查子视图 B 和 C</li>
<li>触摸点不在 B 的范围而在 C 的范围，于是就开始检查 D 和 E 视图</li>
<li>触摸点不在 D 的范围而在 E 的范围，而 E 视图是视图树最底层的并包含触摸点的视图对象，所以 E 就成为了 hit-test 视图</li>
</ol>
<p>整个Hit-Testing 过程可以用下面的伪代码来描述：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> pointInside:point withEvent:event]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> <span class="keyword">self</span>.subviews) &#123;</span><br><span class="line">            <span class="built_in">CGPoint</span> pointOnsubview = [<span class="keyword">self</span> convertPoint:point toView:subview];</span><br><span class="line">            <span class="built_in">UIView</span> *subone = [subview hitTest:pointOnsubview withEvent:event];</span><br><span class="line">            <span class="keyword">if</span> (subone) &#123;</span><br><span class="line">                <span class="keyword">return</span> subone;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hitTest:withEvent</code> 方法根据 CGPoint 和 UIEvent 参数查找 hit-test 视图对象。 它会先调用 <code>pointInside:withEvent:</code>方法。如果传入 <code>hitTest:withEvent:</code>的 CGPoint 点对象位于视图对象的区域范围内，<code>pointInside:withEvent:</code>返回值就是 YES，然后就会递归式地在返回 YES 的子视图对象上调用 <code>hitTest:withEvent:</code>，直到找到底层的视图。</p>
<p>如果传入 <code>hitTest:withEvent:</code>的点不在视图对象的范围内，第一次调用 <code>pointInside:withEvent:</code>就会返回 NO，这个点就被忽略掉了，<code>hitTest:withEvent:</code>就返回 nil。 如果子视图返回 NO，那么整个视图树的分支都会被忽略掉。所以如果父视图不包含某个触摸事件的点，子视图即使包含了这个点，也不会接收到此触摸事件。因为在父视图进行pointInside检查时就中断了事件的投递。</p>
<p>所以如果想要实现子视图超出父视图还能相应事件，需要改写父视图默认的hitTest:withEvent方法。</p>
<blockquote>
<p>触摸对象UITouch 在其生命周期内会和hit-test 视图对象一直关联在一起，即使UITouch在后续的时间里移动并离开该视图对象的范围也是一样的。</p>
</blockquote>
<p>hit-test 视图对象拥有最先对触摸事件进行处理的机会，如果 hit-test 视图对象无法处理该事件，事件对象就会沿着响应者的视图链向上传递，直到找到最适合处理该事件的对象或者到最顶层的window为止。</p>
<h4 id="2-响应者组成的响应链"><a href="#2-响应者组成的响应链" class="headerlink" title="2 响应者组成的响应链"></a>2 响应者组成的响应链</h4><p>许多事件都依赖于响应者链(responder chain)进行事件传递。响应者链就是一系列的相关联的响应者。如果第一个响应者无法处理事件，响应者就会将事件传递给下一个响应者。</p>
<p>UIResponder 类是所有响应者的基类，不仅定义了事件处理的编程接口，同时还定义了通用的响应者行为。UIApplication、UIViewController、UIView 类的实体对象都是响应者。</p>
<p>第一响应者第一个接收事件。通常来讲，第一响应者是一个视图 view 对象。通过做两件事，一个对象就变成了第一响应者:</p>
<ol>
<li>重写 canBecomeFirstResponder 并返回 YES;</li>
<li>接收 becomeFirstResponder 消息。如果有必要，对象本身可以自己发送此消息。</li>
</ol>
<blockquote>
<p>将某个对象变成第一响应者之前，一定要确保APP已经建立好了视图树。如通常应该在重写的 viewDidAppear:方法中调用becomeFirstResponder 方法，但是如果写在了 viewWillAppear 里面，此时因为视图树还没有建立起来，becomeFirstResponder 的返回值就 NO 了。</p>
</blockquote>
<p>也不仅仅只是事件对象依赖于响应者链，响应者链可以被用于处理以下所有对象:</p>
<ul>
<li><strong>Touch Events</strong>(触摸事件)。如果 hit-test 视图对象无法处理触摸事件，事件就会从hit-test 视图沿着响应链往上传递，直到找到合适的处理该事件的对象。</li>
<li><strong>Motion Events</strong>(运动事件)。要使用 UIKit 处理“摇动”(shake-motion)事件， 第一响应者就必须实现方法 motionBegan:withEvent:或者 motionEnded:withEvent:之一。</li>
<li><p><strong>Remote Control Events</strong>(远程控制事件)。要对远程控制事件进行处理，第一响应者必须实现基类 UIResponder 的 remoteControlReceivedWithEvent:方法。</p>
</li>
<li><p><strong>Action messages</strong>(动作消息)。当用户操作了某个控件，如按钮 button、switch， 对应的动作方法的目标是 nil，该消息会从以控件视图对象为开始的响应者链被发送出去。</p>
</li>
<li><p><strong>Editing-menu messages</strong>(编辑菜单消息)。当用户点击了编辑菜单的指令，iOS 系统就会使用响应者链去查找到对应实现了必要处理方法(如 cut:,copy:以及 paste:) 的对象。</p>
</li>
<li><p><strong>Text Editing</strong>(文本编辑)。当用户点击某个文本区域(UITextField)或者文本视图 (UITextView)时，对应的视图就会成为第一响应者。默认情况下，虚拟键盘会弹 出来，而且对应的 UITextField 或者 UITextView 就会被选中并变成正在编辑状态。</p>
<p>当用户点击某个 UITextField 或者 UITextView 的时候，UIKit 会自动把将对应的对象设置为第一响应者。对于其他类型，App 必须使用 becomeFirstResponder 方法显示地进行设置。</p>
</li>
</ul>
<h4 id="3-响应链的传递路径"><a href="#3-响应链的传递路径" class="headerlink" title="3 响应链的传递路径"></a>3 响应链的传递路径</h4><p>如果初始对象(要么是 hit-test 视图，要么是第一响应者)无法对事件进行处理，UIKit 就会把事件传递给响应者链的下一个响应者。每个响应者都可以决定是自己进行事件处理，还是将事件通过方法 nextResponder 的调用，传递给下一个事件响应者。此过程一直进行下去，直到找到了处理该事件的对象，或者到达了响应者链的最后一个响应者。</p>
<p>响应者链开始于 iOS 检测到事件并将其传递到(事件发生所在的)初始对象，通常来讲这个对象是一个视图对象 view。初始视图对象会最先有机会对事件进行处理。如图所示，就是两个不同的 app 中事件的不同的两条事件传递路径。App 的事件传递路径由其特 定的结构所决定，但所有的事件传递路径都遵循同样的逻辑方法。</p>
<p>左边 APP 的事件传递路径如下:</p>
<ol>
<li>初始视图对象尝试对事件进行处理，如果无法处理，就会将事件传递给其父视图对 象，因为视图树中，初始视图对象也并不是最顶端的对象。</li>
<li>父视图也进行同样的尝试，因为同样的原因也只能将事件继续向上传递。</li>
<li>视图控制器中最顶层的视图也进行同样的尝试，结果发现也处理不了，于是就传递了视图控制器。</li>
<li>视图控制器也一样无法处理，于是继续向上传递给了主窗体对象(window)。</li>
<li><p>主窗体也无法处理，于是就继续传递给 app 的单例实体对象。 6. 如果最后单例实体对象还无法处理，此事件就被丢弃了。</p>
</li>
<li><p><img src="/images/event_chain/event_route.png" alt="event_route" style="zoom:50%;" /></p>
</li>
</ol>
<p>虽然右边的 APP 传递路径略微不一样，但是事件传递遵循的逻辑方法还是一样的:</p>
<ol>
<li>视图将事件沿着其视图控制器的视图树向上传递，直到最顶端的视图。</li>
<li>顶端是图无法处理，就直接传递给视图控制器。</li>
<li>视图控制器无法处理，就会将事件传递给其顶端视图所在的父视图。重复 1-3，直到到达最顶端的根视图控制器(root view controller)。</li>
<li>跟视图控制器将事件传递给主窗体对象。</li>
<li>主窗体对象传递给 app 的单例实体对象。</li>
</ol>
<blockquote>
<p>自定义视图来处理响应链时，不要直接将事件或者消息直接发送给 nextResponder，而是调用父类的事件处理方法，来达到将事件沿着响应器链向上传递的目的，让 UIKit 框架来完成响应器链的事件消息传递。</p>
</blockquote>
<h2 id="View的事件交互模型"><a href="#View的事件交互模型" class="headerlink" title="View的事件交互模型"></a>View的事件交互模型</h2><p>无论是用户主动触发还是程序主动改变，从事件产生到界面发生变化，系统会周期性地执行一系列程序来达成这一目的。这一系列的程序大致分成如图所示的几个部分：</p>
<p><img src="/images/event_chain/app_event_structure.png" alt="app_event_structure" style="zoom:70%;" /></p>
<p>下面分步骤进一步解释了图中的事件序列，并说明了每个阶段发生的情况以及希望应用程序作出响应的方式。</p>
<ol>
<li><p>用户触摸屏幕。</p>
</li>
<li><p>硬件将触摸事件报告给UIKit框架。</p>
</li>
<li><p>UIKit框架将触摸打包到<code>UIEvent</code>对象中并将其分派到适当的视图。</p>
</li>
<li><p>视图的事件处理代码会响应事件。例如：</p>
<ul>
<li>更改视图或其子视图的属性（frame, bounds, alpha等）。</li>
<li>调用<code>setNeedsLayout</code>方法将视图（或其子视图）标记为需要布局更新。</li>
<li>调用<code>setNeedsDisplay</code>或<code>setNeedsDisplayInRect:</code>方法将视图（或其子视图）标记为需要重绘。</li>
<li>通知控制器有关某些数据的更改。</li>
</ul>
<p>当然，由您来决定视图应该做哪些事情以及应该调用哪些方法。</p>
</li>
<li><p>如果视图的大小被修改，UIKit将根据以下规则更新其子视图：</p>
<ol>
<li>如果设置了autoresizing属性，UIKit会根据这些规则调整每个视图。</li>
<li>调用<code>layoutSubviews</code>方法，更新子视图。</li>
</ol>
</li>
<li><p>如果任何视图的任何部分被标记为需要重绘，UIKit会要求视图重绘。对于实现了<code>drawRect:</code>方法的自定义视图，UIKit会调用该方法，进行重绘。</p>
</li>
<li><p>任何更新的视图都与应用程序的其他可见内容合成，并发送到图形硬件进行显示。</p>
</li>
<li><p>图形硬件将渲染的内容传输到屏幕。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Core Animation Basic]]></title>
      <url>http://petpwiuta.github.io/2016/10/07/core_animation_basic/</url>
      <content type="html"><![CDATA[<h2 id="图层是绘图和动画的基础"><a href="#图层是绘图和动画的基础" class="headerlink" title="图层是绘图和动画的基础"></a>图层是绘图和动画的基础</h2><p><em>Layer</em> 是Core Animation所有操作的核心。iOS中view其实仅仅做了布局和事件处理，和视觉相关的所有操作都是由所关联的Layer对象完成。</p>
<h4 id="基于layer的绘图模型"><a href="#基于layer的绘图模型" class="headerlink" title="基于layer的绘图模型"></a>基于layer的绘图模型</h4><p>大部分图层都不会进行实际的绘图操作。它会根据view的内容生成对应的位图，并将其缓存。随后更改图层的属性时，系统仅仅只是更改与图层对象关联的状态信息。当触发动画时，Core Animation会将图层的位图和状态信息传递给图形硬件，图形硬件会使用新信息渲染位图，如图1-1所示。在硬件中操作位图会产生比在软件中更快的动画。</p>
<p><img src="/images/core_animation_basic/basics_layer_rendering_2x.png" style="zoom:50%" /></p>
<p>因为它操纵静态位图，所以基于图层的绘图与更传统的基于视图的绘图技术有很大不同。使用基于视图的绘图时，对视图本身的更改通常会导致调用视图的<code>drawRect:</code>方法以使用新参数重绘内容。但是以这种方式绘制是很昂贵的，因为它是在主线程上使用CPU完成的。核心动画通过在硬件中操纵缓存的位图来实现相同或类似的效果。</p>
<p>尽管Core Animation尽可能使用缓存内容，但仍必须提供初始内容并不时更新。应用有多种方法可以为图层对象提供内容，详细信息请参阅<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/SettingUpLayerObjects/SettingUpLayerObjects.html#//apple_ref/doc/uid/TP40004514-CH13-SW4" target="_blank" rel="noopener">Providing a Layer’s Contents</a>。</p>
<h4 id="设置Layer的内容"><a href="#设置Layer的内容" class="headerlink" title="设置Layer的内容"></a>设置Layer的内容</h4><p>图层的内容由包含要显示的可视数据的位图组成。可以通过以下三种方式之一为该位图提供内容：</p>
<ul>
<li>将图像对象直接指定给图层对象的contents属性。（适用于从未或很少更改的图层内容）</li>
<li>实现图层的delegate方法，让delegate绘制图层内容。（适用于可能会定期更改并可由外部对象提供的图层内容）</li>
<li>定义图层子类并覆盖其绘图方法以提供图层内容。（如果必须创建自定义图层子类或者如果要更改图层的基本绘图行为，则此技术是合适的）</li>
</ul>
<h4 id="使用图像作为图层的内容"><a href="#使用图像作为图层的内容" class="headerlink" title="使用图像作为图层的内容"></a>使用图像作为图层的内容</h4><p>由于图层只是用于管理位图图像的容器，因此可以将图像直接指定给图层的contents属性。分配给图层的图像必须是CGImageRef类型。（在OS X v10.6及更高版本中，您还可以分配NSImage对象。）分配图像时，要注意提供其分辨率与本机设备分辨率匹配的图像。对于具有Retina显示屏的设备，可能还需要调整contentsScale属性。</p>
<h4 id="使用delegate提供图层的内容"><a href="#使用delegate提供图层的内容" class="headerlink" title="使用delegate提供图层的内容"></a>使用delegate提供图层的内容</h4><p>如果图层的内容动态更改，则可以使用delegate对象在需要时提供和更新该内容。在显示时，图层调用delegate方法提供所需的内容：</p>
<ul>
<li>如果您的delegate实现了<code>displayLayer:</code>方法，那么该实现负责创建位图并将其分配给图层的<code>contents</code>属性。</li>
<li>如果delegate实现了<code>drawLayer:inContext:</code>方法，Core Animation会创建一个位图，创建一个图形上下文以绘制到该位图，然后调用您的委托方法来填充位图。您的所有委托方法都要绘制到所提供的图形上下文中。</li>
</ul>
<p>委托对象必须实现<code>displayLayer:</code>或<code>drawLayer:inContext:</code>方法。如果同时实现了<code>displayLayer:</code>和<code>drawLayer:inContext:</code>方法，则仅调用<code>displayLayer:</code>方法。</p>
<p>覆盖该<code>displayLayer:</code>方法最适合自己加载或创建想要显示的位图的情况。清单2-3显示了<code>displayLayer:</code>委托方法的示例实现。在此示例中，委托使用辅助对象来加载和显示所需的图像。委托方法根据自己的内部状态选择要显示的图像，在示例中，该状态是调用的自定义属性<code>displayYesImage</code>。</p>
<p><strong>Listing 2-3</strong>  Setting the layer contents directly</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)displayLayer:(CALayer *)theLayer &#123;</span><br><span class="line">    &#x2F;&#x2F; Check the value of some state property</span><br><span class="line">    if (self.displayYesImage) &#123;</span><br><span class="line">        &#x2F;&#x2F; Display the Yes image</span><br><span class="line">        theLayer.contents &#x3D; [someHelperObject loadStateYesImage];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; Display the No image</span><br><span class="line">        theLayer.contents &#x3D; [someHelperObject loadStateNoImage];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有预渲染图像或辅助对象来创建位图，则delegate可以使用<code>drawLayer:inContext:</code>方法动态绘制内容。清单2-4显示了该<code>drawLayer:inContext:</code>方法的示例实现。在此示例中，委托使用固定宽度和当前渲染颜色绘制简单的弯曲路径。</p>
<p><strong>Listing 2-4</strong>  Drawing the contents of a layer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- （void）drawLayer：（CALayer *）theLayer inContext：（CGContextRef）theContext &#123;</span><br><span class="line">    CGMutablePathRef thePath &#x3D; CGPathCreateMutable（）;</span><br><span class="line"> </span><br><span class="line">    CGPathMoveToPoint（thePath，NULL，15.0f，15.f）;</span><br><span class="line">    CGPathAddCurveToPoint（thePath，</span><br><span class="line">                          null，</span><br><span class="line">                          15.f，250.0f，</span><br><span class="line">                          295.0f，250.0f，</span><br><span class="line">                          295.0f，15.0f）;</span><br><span class="line"> </span><br><span class="line">    CGContextBeginPath（theContext）;</span><br><span class="line">    CGContextAddPath（theContext，thePath）;</span><br><span class="line"> </span><br><span class="line">    CGContextSetLineWidth（theContext，5）;</span><br><span class="line">    CGContextStrokePath（theContext）;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;release path</span><br><span class="line">    CFRelease（thePath）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过子类提供层内容"><a href="#通过子类提供层内容" class="headerlink" title="通过子类提供层内容"></a>通过子类提供层内容</h4><p>如果要实现自定义图层类，则可以重载图层类的绘图方法来绘图。图层本身生成内容的情况并不常见，不过图层可以管理内容的显示。例如，<code>CATiledLayer</code>该类通过将大图像分成可以单独管理和呈现的较小图块来管理大图像。因为只有图层具有关于在任何给定时间需要渲染哪些图块的信息，所以它直接管理绘图行为。</p>
<p>子类化时，您可以使用以下任一技术绘制图层的内容：</p>
<ul>
<li>重载<code>display</code>方法并直接设置图层的<code>contents</code>属性。</li>
<li>重载<code>drawInContext:</code>方法并使用它绘制到提供的图形上下文中。</li>
</ul>
<p>使用哪种方法取决于在绘图过程中需要多少控制粒度。<code>display</code>方法是更新图层内容的主要入口点，重载这个方法可以完全控制该过程。重载以后就需要自己来创建<code>CGImageRef</code>并赋值给<code>contents</code>属性。所以，如果只是想绘制内容（或让图层管理绘图操作），则重载<code>drawInContext:</code>方法就行了，后面的细节让系统来处理。</p>
<h2 id="图层的几何特性"><a href="#图层的几何特性" class="headerlink" title="图层的几何特性"></a>图层的几何特性</h2><p>视图的frame是一个虚拟属性，是根据 bounds，position以及transform计算而来，所以当其中任何一个值发生改变，frame都会变化。反之，改变frame的值同样会影响到他们中的值。</p>
<p>当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说 frame的宽高可能和bounds的宽高不再一致。</p>
<p><img src="/images/core_animation_basic/rotated_layer.png" alt="image-20200414163505778" style="zoom:50%;" /></p>
<h2 id="视觉效果"><a href="#视觉效果" class="headerlink" title="视觉效果"></a>视觉效果</h2><h4 id="图层蒙板"><a href="#图层蒙板" class="headerlink" title="图层蒙板"></a>图层蒙板</h4><p>CALayer的mask属性可以设置图层蒙板。mask本身就是个CALayer类型，它定义了父图层的部分可见区域，mask本身的颜色不起作用，起作用的是alpha值，它决定了是隐藏还是部分/全部显示父图层的内容。前面说到过CALayer的content可以是一张图，可以直接用带alpha通道的图来设置mask；也可以自定义绘图逻辑，这也意味着mask的内容可以编程动态来更新。</p>
<h4 id="拉伸过滤"><a href="#拉伸过滤" class="headerlink" title="拉伸过滤"></a>拉伸过滤</h4><p>􏱲􏳊􏱾图片在放大或者缩小时，系统会进行从新采样。CALayer提供了3中采样模式：</p>
<ul>
<li>kCAFilterLinear </li>
<li><p>kCAFilterTrilinear</p>
</li>
<li><p>kCAFilterNearest </p>
</li>
</ul>
<p>默认是kCAFilterLinear，不过如果有时候放大太多会不清晰，此时使用kCAFilterTrilinear就会好一点。kCAFilterNearest适用于颜色值较小，纯色较多的情况。</p>
<h4 id="组透明"><a href="#组透明" class="headerlink" title="组透明"></a>组透明</h4><p>有时给空间设置了透明度，但是控件的子视图也有一定的透明度，此时看起来就会比较怪异。可以启用 shouldrasterize属性来解决这个问题。在设置这个属性后，还要确保对应的rasterizationscale和屏幕分辨率相匹配。</p>
<h2 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h2><p>CALayer的动画是默认开启的，如果改变一个单独的Layer(非UIView的内部layer)的可做动画的属性，它会自动播放一个从原值到新值的动画，因为都是系统默认的，没有额外的动画逻辑所以也叫隐式动画。</p>
<p>动画的类型和属性有关，如颜色和大小的动画就会有区别，动画的时间有默认设置，这些都是由CATransaction类来做管理。CATransaction可以用begin和commit方法来提交动画事务，用setAnimationduration：方法设置当前事务的动面时间。在iOS4以后的API中，基本上都用 <code>[UIView animateWithDuration: animations:^{ }]</code> 来完成这个步骤，它在内部也是调用的CATransaction 的方法。</p>
<h4 id="隐式动画的实现"><a href="#隐式动画的实现" class="headerlink" title="隐式动画的实现"></a>隐式动画的实现</h4><p>需要注意的是，UIView关联的CALayer的隐式动画默认被禁用了。关于被禁用的细节，需要先了解隐式动画的实现。</p>
<p>CALayer的属性被修改时候，它会调用actionForKey:方法，传递被修改属性的名称。后面的处理逻辑大致如下：</p>
<ul>
<li>图层首先检测它是否有委托，并且是否实现CALayerDelegate协议指定的actionForLayer:forKey方法。</li>
<li>如果有，直接调用并返回结果。如果没有委托，或者委托没有实现actionForLayer:forKey方法，图层接着检查包含属性名称对应行为映射的actions字典。</li>
<li>如果actions字典没有包含对应的属性，那么图层接着在它的style字典接着搜索属性名。</li>
<li>最后，如果在style里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的defaultActionForKey:方法。</li>
</ul>
<p>所以一轮完整的搜索结束之后，actionForKey:要么返回空（这种情况下将不会有动面发生），要么是CAAction协议对应的对象，最后CALayer拿这个结果去对先前和当前的值做动画.</p>
<p>于是这就解释了UKit是如何禁用隐式动画的：每个UIView对它关联的图层都扮演了一个委托，并实现了actionForLayer:forKey。当不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动面block范围之内，它就返回了一个非空值。</p>
<p>不过这并不是禁止隐式动画的唯一办法。CATransaction有个方法叫setDisableActions:可以设置全局开启/关闭隐式动画。</p>
<h4 id="呈现树和数值树"><a href="#呈现树和数值树" class="headerlink" title="呈现树和数值树"></a>呈现树和数值树</h4><p>当你修改一个CALayer的属性，它的属性值是马上更新到新值的（如果你读取它的数据，你会发现它的值在你设置它的那一刻就已经生效了）。但是屏幕上的绘制效果并不是瞬间更新。这是因为设置的属性并没有直接调整图层的外观，相反，他只是定义了图层动画结束之后将要变化的外观。</p>
<p>CALayer的属性，实际上是在定义当前事务结束之后图层如何显示的模型。Core Animation扮演了一个控制器的角色，并且负责根据图层行为和事务设置去不断更新视图的这些属性在屏幕上的状态。</p>
<p>它是一个典型的微型MVC模式。CALayer是一个连接用户界面（就是MVC中的view）虚构的类，但是在界面本身这个场景下，CALAyer的行为更像是存储了视图如何显示和动画的数据模型。</p>
<p>在iOS中，屏幕每秒钟重绘60次。如果动画时长比1/60秒要长，Core Animation就需要根据动画属性给每一帧生成动画效果，所以必须要知道当前显示在屏幕上的属性值的记录。每个图层属性的显示值都被存储在一个叫做呈现图层的独立图层当中，他可以通过presentationLayer方法来访问。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以通过呈现图层的值来获取当前屏幕上真正显示出来的值。</p>
<p>呈现树通过图层树中所有图层的呈现图层所形成。注意呈现图层仅仅当图层首次被提交（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用presentationLayer将会返回nil。</p>
<p>呈现树也可以反查自己对应的数值树。在呈现图层上调用modelLayer方法将会返回它对应的数值树的CALAyer。而在一个数值树上调用modeller会返回self。</p>
<p><img src="/images/core_animation_basic/modeandlayer.png" alt="image-20200415115134567" style="zoom:50%;" /></p>
<p>大多数情况下直接设置CALayer的属性就够了，不过在做同步动画以及做用户交互时，用呈现树会更精确一些：</p>
<ul>
<li>做基于定时器的动画，这个时候准确地知道在某一时刻图层显示在什么位置就比较重要。</li>
<li>动画的图层响应用户输入时，可以使用hitTest:来判断指定图层是否被触摸，这时候对呈现图层而不是模型图层调用hitTest:会更精确，因为呈现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置。</li>
</ul>
<h2 id="显式动画"><a href="#显式动画" class="headerlink" title="显式动画"></a>显式动画</h2><h4 id="常用动画"><a href="#常用动画" class="headerlink" title="常用动画"></a>常用动画</h4><p><code>CABasicAnimation</code>是执行显式动画的类。建议在将动画添加到图层之前设置动画的开始和结束值，持续时间或其他参数。下面代码显示了如何使用动画对象淡出图层。创建对象时，指定要设置动画的属性的关键路径，然后设置动画参数。要执行动画，可以使用该<code>addAnimation:forKey:</code>方法将其添加到要设置动画的图层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation* fadeAnim &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];</span><br><span class="line">fadeAnim.fromValue &#x3D; [NSNumber numberWithFloat:1.0];</span><br><span class="line">fadeAnim.toValue &#x3D; [NSNumber numberWithFloat:0.0];</span><br><span class="line">fadeAnim.duration &#x3D; 1.0;</span><br><span class="line">[theLayer addAnimation:fadeAnim forKey:@&quot;opacity&quot;];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Change the actual data value in the layer to the final value.</span><br><span class="line">theLayer.opacity &#x3D; 0.0;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>  创建显式动画时，建议设置<code>fromValue</code>。如果未指定此属性的值，Core动画将使用图层的当前值作为起始值。如果已将属性更新为最终值，可能没有效果。</p>
</blockquote>
<p>和通过更新view属性触发的隐式动画不同，显式动画不会修改图层树中的数据。显式动画仅生成动画。在动画结束时，Core Animation从图层中移除动画对象，并使用当前数据值重绘图层。如果希望显式动画的更改是永久性的，则还必须更新图层的属性。</p>
<p>隐式和显式动画通常在当前运行循环周期结束后开始执行，并且当前线程必须具有run loop才能执行动画。如果更改多个属性，或者向图层添加多个动画对象，则会同时对所有这些属性更改进行动画处理。</p>
<p>除了<code>CABasicAnimation</code>还有一些动画类可以使用，如用来做关键帧动画的<code>CAKeyframeAnimation</code>、以及有弹性效果的<code>CASpringAnimation</code></p>
<h4 id="虚拟属性"><a href="#虚拟属性" class="headerlink" title="虚拟属性"></a>虚拟属性</h4><p>􏷄属性动画在设置时，往往要设置keyPath来指定是哪个属性。其实这个keyPath不仅仅可以写属性名。还可以和它的名字一样，写属性路径。如做一个旋转效果，可以用<code>transform.rotation</code>这个路径来达到效果。如下面的代码一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">    CALayer *shipLayer &#x3D; [CALayer layer];</span><br><span class="line">    shipLayer.frame &#x3D; CGRectMake(0, 0, 128, 128);</span><br><span class="line">    shipLayer.position &#x3D; CGPointMake(150, 150);</span><br><span class="line">    [self.containerView.layer addSublayer:shipLayer]; &#x2F;&#x2F;animate the ship rotation</span><br><span class="line">    CABasicAnimation *animation &#x3D; [CABasicAnimation animation];</span><br><span class="line">    animation.keyPath &#x3D; @&quot;transform.rotation&quot;;</span><br><span class="line">    animation.duration &#x3D; 2.0;</span><br><span class="line">    animation.byValue &#x3D; @(M_PI * 2);</span><br><span class="line">    [shipLayer addAnimation:animation forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个效果要比设置keyPath为transform，然后toValue设置成一个旋转完毕的transform好。这样的好处在于：</p>
<ul>
<li>可以一步旋转多于180度的动面</li>
<li>可以用相对值而不是绝对值旋转(设置 byvalue而不是 tovalue)。</li>
<li>可以不用创建 CATransform3D,而是使用一个简单的数值来指定角度</li>
<li>不会和 transform.position或者 transform.scale冲突(如果同样是使用关键路径来做动画属性的话)</li>
</ul>
<p>transform.rotation属性本身并不存在，它实际上是一个 CALayer用于处理动画变换的虚拟属性。同样的也不能直接设置transform.rotation或者transform.scale,他们不能被直接使用。当你对它们做动画时，Core animation自动地根据通过 CAValuefunction来计算的值来更新 transform属性。</p>
<p>CAValuefunction用于把我们赋给虚拟的 transform.rotation简单浮点值转换成真正的用于摆放图层的CATransform3D矩阵值。默认的CAValuefunction的行为可以修改，设置CAPropertyAnimation的valuefunction属性后，默认的行为就会用自定义的函数替代。</p>
<h4 id="动画组"><a href="#动画组" class="headerlink" title="动画组"></a>动画组</h4><p>CABasicAnimation和 CAKeyframeAnimation仅仅作用于单独的属性。而CAAnimationGroup可以把这些动画组合在一起。 CAAnimationGroup是另外继承于CAAnimation的子类，它添加了一个animations数组的属性，用来组合别的动面。</p>
<h4 id="过渡效果"><a href="#过渡效果" class="headerlink" title="过渡效果"></a>过渡效果</h4><p>属性动画只对图层的可动画属性起作用，有时候想对视图的层级关系变化做动画，就有了过渡效果的概念。过渡动画首先展示之前的图层外观，然后通过一个交换过渡到新的外观。CATransition是专门用来实现过渡效果的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)switchImage &#123;</span><br><span class="line">    CATransition *transition &#x3D; [CATransition animation];</span><br><span class="line">    transition.duration &#x3D; 0.25;</span><br><span class="line">    transition.type &#x3D; kCATransitionFade;</span><br><span class="line">    transition.subtype &#x3D; kCATransitionFromRight;</span><br><span class="line">    [self.imgView.layer addAnimation:transition forKey:nil]; </span><br><span class="line">    self.currentIndex &#x3D; (self.currentIndex + 1) % [self.images count];</span><br><span class="line">    self.imgView.image &#x3D; self.images[self.currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过渡动面和之前的属性动面或者动面组添加到图层上的方式一致，都是通过addanimation:forKey:方法。但是和属性动画不同的是，对指定的图层一次只能使用一次 CATransition，无论你对动画的key设置什么值，系统都会把它的key设置成kCATransition。</p>
<p>除了CATransition，UIView还提供了两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[UIView transitionFromView:nil toView:nil duration:0 options:1 completion:^(BOOL finished) &#123;&#125;];</span><br><span class="line">[UIView transitionWithView:nil duration:0 options:1 animations:^&#123;&#125; completion:^(BOOL finished) &#123;&#125;];</span><br></pre></td></tr></table></figure>
<p>这两个方法也能实现过渡效果。</p>
<h2 id="图层时间"><a href="#图层时间" class="headerlink" title="图层时间"></a>图层时间</h2><h4 id="CAMediaTiming协议"><a href="#CAMediaTiming协议" class="headerlink" title="CAMediaTiming协议"></a>CAMediaTiming协议</h4><h5 id="持续和重复"><a href="#持续和重复" class="headerlink" title="持续和重复"></a>持续和重复</h5><p>duration表示动画持续时间，repeatCount表示动画持续次数。两者默认都是0，表示重复一次，时长0.25秒。</p>
<p>如果想重复指定时长的话，可用repeatDuration属性指定。</p>
<p>另外autoreverses属性很有用，用来做循环往复动画的时候，直接指定这个属性为YES就能达到效果。</p>
<h5 id="相对时间"><a href="#相对时间" class="headerlink" title="相对时间"></a>相对时间</h5><p>每个动画都有它自己的描述时间，可以独立地加速，延时或者偏移。</p>
<p>beginTime指定了动画开始前的延迟时间。这里延迟是从动画添加到可见图层开始算。</p>
<p>speed是一个时间倍数，默认为1.0，如果速度变成2.0，那么duration为1的动画，实际时间将变成0.5秒</p>
<p>timeOffset和beginTime类似，但是timeOffset是让动画快进到某一点，有点像拖动视频进度条的概念。对于duration为1秒的动画，timeOffset为0.5表示动画从一半的地方开始。</p>
<h5 id="填充模式"><a href="#填充模式" class="headerlink" title="填充模式"></a>填充模式</h5><p>如果beginTime大于0，那动画添加到图层上以后，会有一段时间啥动画都没有。类似的，当removeOnCompletion被设置成NO后，动画结束时，仍旧会保持最后一帧。那动画开始之前和动画结束之后，动画的属性是什么？这个就需要用fillMode属性来指定。</p>
<p>fillMode是个字符串类型，取值有一下几种，默认是kCAFillModeRemoved。</p>
<ul>
<li>kCAFillModeForwards 动画开始前，保持动画开始的效果</li>
<li>kCAFillModeBackwards 动画结束后，保持动画结束的效果</li>
<li>kCAFillModeBoth  两者都有</li>
<li>kCAFillModeRemoved  当动画结束时，显示图层模型指定的值</li>
</ul>
<h4 id="用户交互动画"><a href="#用户交互动画" class="headerlink" title="用户交互动画"></a>用户交互动画</h4><p>timeOffset一个很有用的功能就是可以和用户的交互关联起来，变成用户控制的交互式动画。</p>
<h2 id="渐入渐出"><a href="#渐入渐出" class="headerlink" title="渐入渐出"></a>渐入渐出</h2><h4 id="常用效果"><a href="#常用效果" class="headerlink" title="常用效果"></a>常用效果</h4><p>渐入渐出效果是动画中常用的效果。CAAnimation的timingFunction可以指定更丰富的动画加速度效果。</p>
<ul>
<li>kCAMediaTimingFunctionLinear  线性</li>
<li>kCAMediaTimingFunctionEaseIn 渐入</li>
<li>kCAMediaTimingFunctionEaseOut 渐出</li>
<li>kCAMediaTimingFunctionEaseInEaseOut 渐入渐出</li>
<li>kCAMediaTimingFunctionDefault 默认</li>
</ul>
<h4 id="自定义效果"><a href="#自定义效果" class="headerlink" title="自定义效果"></a>自定义效果</h4><p>动画加速度函数除了系统预置的几个外，还可以自己定义。除了functionwithName:之外，CAMediaTiming Function同样有另一个构造函数，一个有四个浮点参数的<code>functionwithcontrolpoints::::</code> 使用这个方法，可以自定义一个加速度函数，这个函数的参数是一个三次贝塞尔曲线，4个参数分别是曲线的四个控制点。</p>
<h2 id="基于定时器的动画"><a href="#基于定时器的动画" class="headerlink" title="基于定时器的动画"></a>基于定时器的动画</h2><p>CADisplayLink是CoreAnimation提供的另一个类似于NSTimer的类，它总是在屏幕完成一次更新前启动。它有个整型的frameInterval属性，制定了间隔多少帧之后才执行。默认是1，意味着每次屏幕每次更新之前都会执行一次。</p>
<p>创建CADisplayLink时，需要制定一个runloop和runloop mode。</p>
<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><h4 id="动画的组成部分"><a href="#动画的组成部分" class="headerlink" title="动画的组成部分"></a>动画的组成部分</h4><p>动画和屏幕上的图层混合是由一个单独的进程执行，这个进程也叫渲染服务。当运行一段动画的时候，这个过程会被四个分离的阶段打破：</p>
<ul>
<li>布局。这个是准备视图层级以及设置图层属性的阶段</li>
<li>绘制。这个是图层对应的内容被绘制的阶段。可能涉及到drawRect:和drawLayer:inContext:等方法</li>
<li>准备。这个是Core Animation准备发送动画数据到渲染服务的阶段。这个阶段同时也会进行图片解码。</li>
<li>提交。这个是最后阶段。Core Animation会打包所有图层和动画属性，然后通过IPC发送到渲染服务进行显示</li>
</ul>
<p>这些步骤是发生在应用程序之内的部分。当动画在屏幕上显示之前仍然有更多的工作。一旦打包的图层和动画达到渲染服务进程，它们会被反序列化来形成另一个叫做渲染树的图层树。使用这个树状结构，渲染服务队动画的每一帧做出如下工作：</p>
<ul>
<li>对所有的图层属性计算中间值，形状来执行渲染</li>
<li>在屏幕上渲染可可见的三角形</li>
</ul>
<p>所有一共有六个阶段。最后两个阶段在动画过程中不停地重复。前五个阶段都在软件层面处理（通过CPU），只有最后一个被GPU执行。</p>
<h5 id="CPU相关"><a href="#CPU相关" class="headerlink" title="CPU相关"></a>CPU相关</h5><p>在动画产生的过程中，CPU的工作更多集中在动画开始之前的准备工作上。所以如果动画效果中有CPU瓶颈，不会影响到帧率，但是会有延迟感。</p>
<p>下面这些CPU操作都会延迟动画的开始时间：</p>
<ul>
<li>布局计算。如果视图层级结构非常复杂，而且使用了复杂的自动布局约束，那会增加不少CPU的计算量</li>
<li>视图资源的Lazy Loading。这个技术是为了节省内存等资源而产生的，不过在这里临时进行加载时会进行很多IO以及潜在的内存交换工作，也会有很多CPU计算量</li>
<li>Core Graphics绘图。</li>
<li>解压图片。</li>
</ul>
<h5 id="GPU相关"><a href="#GPU相关" class="headerlink" title="GPU相关"></a>GPU相关</h5><p>大部分的CALayer的属性都是用GPU来绘制的。如背景以及边框，如果contents是一张图片，也会直接被GPU渲染出来。通过GPU硬件能极大的加速工作速度，不过下面这些因素会增大GPU的工作负担，在开发中应该避免：</p>
<ul>
<li>视图层级结构非常复杂。现在GPU的性能没什么问题，但因为绘图时图层要通过IPC发送到渲染服务进程，太多的图层会达到CPU的瓶颈，而造成GPU也跟着受牵连。</li>
<li>大量重绘。重叠的半透明图层需要进行混合，这会增加GPU的工作量。如果图层和背景颜色一样，那就可以把图层设置成不透明，省去混合的步骤。</li>
<li>离屏渲染。圆角、遮罩、阴影、图层光栅化等效果都会强制Core Animation提前进行预渲染。</li>
<li>较大的图片。如果图片过大超过GPU的支持范围。需要用CPU进行预处理。</li>
</ul>
<h5 id="IO相关"><a href="#IO相关" class="headerlink" title="IO相关"></a>IO相关</h5><p>有时候影响性能的的主要原因并不在处理器上，而是在IO性能上，所以排查问题时，也不要忘记这个方向。</p>
<h4 id="常用图形性能debug思路"><a href="#常用图形性能debug思路" class="headerlink" title="常用图形性能debug思路"></a>常用图形性能debug思路</h4><ul>
<li>帧率是否是60帧？</li>
<li>CPU或GPU是否有性能瓶颈？</li>
<li>有不必要的CPU渲染吗？</li>
<li>是否有太多的离屏渲染？</li>
<li>是否有太多的透明图层，导致需要执行大量的混合操作？</li>
<li>是否用到了不常用的图片格式，或者超大的图片？</li>
<li>是否有高计算量的视觉效果？</li>
<li>是否有异常的视图层次结构，或者有些视图渲染了，但是没有出现在屏幕上？</li>
</ul>
<h4 id="Instruments工具"><a href="#Instruments工具" class="headerlink" title="Instruments工具"></a>Instruments工具</h4><h5 id="Time-Profiler"><a href="#Time-Profiler" class="headerlink" title="Time Profiler"></a>Time Profiler</h5><p>代码执行时间分析能诊断出那个方法正在消耗CPU。发现潜在的造成CPU瓶颈的代码。</p>
<h5 id="View-Debugging-（以前的Core-Animation选项）"><a href="#View-Debugging-（以前的Core-Animation选项）" class="headerlink" title="View Debugging （以前的Core Animation选项）"></a>View Debugging （以前的Core Animation选项）</h5><p>主要用来监测Core Animation的性能。以前是放在Instruments工具的Core Animation中，后来从Xcode9.3开始移到Xcode中，在Debug / View Debugging / Rendering 菜单下面就能找到。</p>
<ul>
<li>Color Blended Layers 多个半透明图层叠加会导致混合，增加GPU负担。这里显示出半透明的图层。</li>
<li>Color Hits Green and Misses Red 显示光栅化的图层缓存命中情况，如果miss过多需要考虑优化。</li>
<li>Color Copied Images 图片数据是通过IPC服务发送到渲染进行，可能是Core Animation自己合成的图片，不是现成的图片资源。</li>
<li>Color Layer Formats 把相同类型的Layer用相同颜色标志出来。</li>
<li>Color Misaligned Images 高亮一些被拉伸或者缩放以及没有对齐到整型坐标的图层。</li>
<li>Color Offscreen-Rendered Yellow 使用离屏渲染的地方会标记为黄色</li>
<li>Color Compositing Fast-Path Blue 用于标记由硬件绘制的路径，蓝色越多越好</li>
<li>Flash Updated Regions 标记频繁发生重绘的区域，越小越好</li>
<li>Color Immediately 一般Core Animation每隔10ms刷新调试图层的颜色状态，对有些调试功能，它可能间隔太长，开启这个选项能每帧都更新这些调试图层的颜色状态。不过可能会引起性能问题，或者造成测试不准的情况。</li>
</ul>
<h5 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a>Metal</h5><p>监测GPU的利用率，发现潜在的GPU瓶颈。</p>
<h2 id="高效绘图"><a href="#高效绘图" class="headerlink" title="高效绘图"></a>高效绘图</h2><h4 id="软绘制"><a href="#软绘制" class="headerlink" title="软绘制"></a>软绘制</h4><p>软件绘图通常要比GPU绘制慢得多。不过GPU并不是万能的，在有些情况下还是需要用软绘制。</p>
<p>一般用Core Graphics框架实现的绘制就是软绘制。􏰶􏰋􏱒􏴘当实现CALayer的Delegate的drawLayer:inContext:方法，或者UIView的drawRect方法后，系统就启用了一个drawing context，这个上下文环境保存了屏幕上的绘制信息，即屏幕上所有的像素的色值信息，所以内存的占用量也是巨大的。</p>
<p>综上，软绘制一般尽量避免。</p>
<h4 id="矢量图形"><a href="#矢量图形" class="headerlink" title="矢量图形"></a>矢量图形</h4><p>Core Graphics一般用来实现图片或者图层难以达到的效果，如用户的手绘效果等。一般在实现手绘路径都是用UIBezierPath来实现，它在路径复杂时，性能会遇到瓶颈。Core Animation其实为这类需求专门提供了有硬件加速的CALayer，如绘制图形的CAShapeLayer、绘制文本的CATextLayer、绘制渐变的CAGradientLayer。</p>
<h4 id="脏矩形"><a href="#脏矩形" class="headerlink" title="脏矩形"></a>脏矩形</h4><p>进一步提高效率的办法就是局部绘制，大部分时候，用户手绘效果都是局部的，所以只用更新局部的内容就行了。所以，加上更新范围监测，调用setNeedsDisplayInRect:方法来进行局部刷新也是个好办法。</p>
<h4 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h4><p>CATiledLayer可以把大的layer分割成小块，每个块在不同线程中同时绘制。所以使用CATiledLayer是实现多线程绘制的一种方案。</p>
<p>drawsAsynchronously是CALayer的一个属性，当开启时。它会把接收到的绘制指令保存到一个队列中，等draw方法体执行完毕以后（相当于收集到了所有的绘制指令），再并行执行绘制指令。未开启时这个在需要频繁绘制的视图上有比较好的效果，反之可能效果不大。所以开启这个属性前后需要进行性能测试，保证开启后确实有性能提升。</p>
<h2 id="图像IO"><a href="#图像IO" class="headerlink" title="图像IO"></a>图像IO</h2><h4 id="加载和潜伏"><a href="#加载和潜伏" class="headerlink" title="加载和潜伏"></a>加载和潜伏</h4><p>图片的加载也会影响到性能，所以在进行性能分析时也需要考虑到这一点。加载是可以用多线程技术，充分利用多核硬件。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p><code>[UIImage imageNamed:]</code>方法以及nib引用的图片是带缓存的，不过它仅用于bundle中的图片。自定义缓存可以用NSCache来实现。</p>
<h4 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h4><p>一般来说压缩比高的，文件体积小，解压慢；压缩比低的，文件体积大，解压快。</p>
<p>现在的图片都是压缩过的，显示到屏幕上时，都需要提前先解压缩成位图。图片像素尺寸以及像素分布范围还有图片文件格式都会影响到图片的显示速度。所以做性能测试时，这些因素都需要考虑。</p>
<h2 id="图层性能"><a href="#图层性能" class="headerlink" title="图层性能"></a>图层性能</h2><h4 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h4><p>CALayer的shouldRasterize是个很有用的功能。可以很有效地解决图层过多导致的性能问题。不过启用后，系统将会进行离屏渲染，并最终绘制到contents中，这也会有额外的内存和CPU开销，所以一般在内容比较复杂而且也不会频繁变化的图层中使用这个属性。</p>
<p>开启后可以用instrument工具来进行测试，看看光栅化后缓存的命中率怎么样。</p>
<h4 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h4><p>有些较为复杂的图形效果需要多个渲染结果组合起来，渲染的中间结果会保存到一块内存中，不是直接渲染到frame buffer，所以也叫离屏渲染。下面这些效果会产生离屏渲染：</p>
<ul>
<li>Core Graphics相关的API</li>
<li>drawRect相关的方法</li>
<li><p>文本相关的绘制，包括Core Text</p>
</li>
<li><p>圆角（maskToBounds和cornerRadius同时开启）</p>
</li>
<li>图层蒙板（圆角其实也是蒙板的一种）</li>
<li>阴影</li>
<li>光栅化</li>
<li>group opacity</li>
</ul>
<p>离屏渲染主要的性能开销在于GPU的上下文切换，<a href="https://lobste.rs/s/ckm4uw/a_performance-minded_take_on_ios_design" target="_blank" rel="noopener">切换时会清空流水线以及管线屏障</a>。（有点类似于CPU的jmp语句，会清空指令流水线）有时候如果简单的绘制操作，其切换上下文的时间成本比绘制所花费的时间还高。所以尽量避免大量使用这些效果，或者针对性的做一些优化。</p>
<h5 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h5><p>有时候遇到形状复杂的ui需求，用CAShapeLayer是个比较好的选择。</p>
<p>如果有大量使用圆角的情况，为了避免离屏渲染，可以直接用 [UIBezierPath bezierPathWithRoundedRect:cornerRadious:] 这个方法直接指定圆角路径，这样能直接使用硬件加速。</p>
<h5 id="Stretchable-Images"><a href="#Stretchable-Images" class="headerlink" title="Stretchable Images"></a>Stretchable Images</h5><p>使用可拉伸图片也可能实现圆角、以及阴影效果。</p>
<h5 id="ShadowPath"><a href="#ShadowPath" class="headerlink" title="ShadowPath"></a>ShadowPath</h5><p>图形如果有圆角或者阴影，使用这个属性能避免离屏渲染。</p>
<h4 id="混合以及过度绘制"><a href="#混合以及过度绘制" class="headerlink" title="混合以及过度绘制"></a>混合以及过度绘制</h4><p>GPU每一帧可以绘制的像素有一个最大限制（填充率），一般情况下情况下GPU绘制整个屏幕的所有像素是很轻松的。但如果有很多重叠图层导致需要不停重绘同一区域的话，就可能掉帧。GPU在渲染时会根据z坐标深度计算完全被挡住的部分，这个过程花费的计算量和图层数量成正比。不同图层的透明重叠像素(即混合)到一个图层时，消耗的资源也是相当客观的。所以为了加速处理进程，要尽量减少图层数，并且尽量不要用透明图层。</p>
<p>如果图层内的子图层较多，可以开启光栅化，这样所有图层会合并成一个图像缓存起来，减少GPU的工作量。</p>
<h4 id="减少图层数量"><a href="#减少图层数量" class="headerlink" title="减少图层数量"></a>减少图层数量</h4><p>初始化图层，处理图层，打包通过IPC发给渲染引擎，转化成Metal几何图形，这些是一个图层的大致资源开销。减少图层数量能减少CPU的工作量，在做性能优化时，不要忘记这一点。</p>
<h5 id="避免不必要的绘制"><a href="#避免不必要的绘制" class="headerlink" title="避免不必要的绘制"></a>避免不必要的绘制</h5><ul>
<li>在屏幕外，或者父view的边界外</li>
<li>在一个完全不透明的view后</li>
<li>完全透明的图层</li>
</ul>
<p>这是避免不必要绘制的典型，在编码阶段就要避免。</p>
<h5 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h5><p>使用对象池来复用高成本的UI对象，比如UICollectionView和UITableView的复用机制。</p>
<h5 id="Core-Graphics绘制"><a href="#Core-Graphics绘制" class="headerlink" title="Core Graphics绘制"></a>Core Graphics绘制</h5><p>虽然drawRect方法比较慢，但是如果视图层级结构比较复杂，用这个方法可能还是更快一点。不过这个也要和光栅化做对比着做性能测试，根据实际场景做技术选型。</p>
<h5 id="renderInContext方法"><a href="#renderInContext方法" class="headerlink" title="renderInContext方法"></a>renderInContext方法</h5><p>大量的视图或者图层关联到了屏幕上将会是一个大的性能问题，但是没有与屏幕关联的图层树不会被送到渲染引擎，也不会和主线程竞争渲染服务资源。所以一些复杂的UI可以先用renderInContext渲染成单个图片，然后再合适的时机再显示。这样就把原来的负载错峰处理了。</p>
<h2 id="专用图层"><a href="#专用图层" class="headerlink" title="专用图层"></a>专用图层</h2><p>使用专用图层的方式有两种，一种是直接实例化专用图层，然后添加到对应的视图树上，这样的好处是比较方便，在轻量级的使用中非常灵活。但是如果遇到布局调整，以及较复杂的调整逻辑时，这种方法就略显不足了。</p>
<p>另外一种方法就是自定义一个UIView的子类，在layerClass方法中返回对应的专用图层类。如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CustomView</span></span></span><br><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CAShapeLayer</span>.class;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这样实例化一个自定义的View后，内部的Layer就是专用的Layer，这样就能方便地进行自定义。</p>
<h4 id="CAShapeLayer-1"><a href="#CAShapeLayer-1" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h4><p>它是一个通过矢量图形来进行绘制的Layer。它直接使用硬件加速、而且它没有对应的contents的bitmap、边界之外的内容也会被绘制。</p>
<h4 id="CATextLayer"><a href="#CATextLayer" class="headerlink" title="CATextLayer"></a>CATextLayer</h4><p>显示文本的Layer，如果有自定义文本的需求可以考虑使用它。</p>
<h4 id="CATransformLayer"><a href="#CATransformLayer" class="headerlink" title="CATransformLayer"></a>CATransformLayer</h4><p>适用于3D仿射变换较多的情况。</p>
<h4 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h4><p>渐变专属。</p>
<h4 id="CAReplicatorLayer"><a href="#CAReplicatorLayer" class="headerlink" title="CAReplicatorLayer"></a>CAReplicatorLayer</h4><p>界面需要重复大量的相同图形， 或者对图形进行大量规则的变化，如仿射变换等，就可以用这个Layer提高性能。</p>
<h4 id="CAScrollLayer"><a href="#CAScrollLayer" class="headerlink" title="CAScrollLayer"></a>CAScrollLayer</h4><p>自己实现ScrollView的类似功能时，可以在它基础上进行，不用从零开始。</p>
<h4 id="CATiledLayer"><a href="#CATiledLayer" class="headerlink" title="CATiledLayer"></a>CATiledLayer</h4><p>在绘制超大图片时，可能会遇到内存问题，这时候可以只显示一小部分内容。使用CATiledLayer是个不错的选择。实现它的代理方法，然后动态绘制当前显示的一小部分内容，这样能节省大量的内存资源。</p>
<p>而且它的绘制方法会异步调用，系统能最大化利用多核CPU加速绘制。</p>
<h4 id="CAEmitterLayer"><a href="#CAEmitterLayer" class="headerlink" title="CAEmitterLayer"></a>CAEmitterLayer</h4><p>高性能的粒子引擎，实现粒子动画可以考虑用它。</p>
<h4 id="CAEAGLLayer-CAMetalLayer"><a href="#CAEAGLLayer-CAMetalLayer" class="headerlink" title="CAEAGLLayer / CAMetalLayer"></a>CAEAGLLayer / CAMetalLayer</h4><p>调用底层OpenGL和Metal的Layer，由于太过底层，实现具体逻辑的的代码量巨大。一般使用GLKit或者MetalKit，它们对前面提到的Layer都有对应的UIView的封装。</p>
<h4 id="AVPlayerLayer"><a href="#AVPlayerLayer" class="headerlink" title="AVPlayerLayer"></a>AVPlayerLayer</h4><p>它是用来播放视频的，MPMoviePlayer的底层实现就是它。</p>
]]></content>
      
        <categories>
            
            <category> iOS开发 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
