<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS平台Webview和原生代码交互 | Ney的技术博客</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS平台Webview和原生代码交互</h1><a id="logo" href="/.">Ney的技术博客</a><p class="description">Learning，sharing，improving</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS平台Webview和原生代码交互</h1><div class="post-meta">Feb 20, 2017<span> | </span><span class="category"><a href="/categories/iOS开发/">iOS开发</a></span></div><div class="post-content"><h1 id="iOS平台Webview和原生代码交互"><a href="#iOS平台Webview和原生代码交互" class="headerlink" title="iOS平台Webview和原生代码交互"></a>iOS平台Webview和原生代码交互</h1><p>最近遇到很多原生和前端进行交互的业务逻辑，前前后后做了一些调研。现在把常用的方法总结一下。<br>前端和原生交互大致分为这几种方式:拦截URL、WKWebView、JavaScriptCore，下面来分别说一下这几种方式的实现以及优缺点。</p>
<h2 id="1-拦截URL"><a href="#1-拦截URL" class="headerlink" title="1.拦截URL"></a>1.拦截URL</h2><h3 id="1-1-通过Webview的委托方法拦截"><a href="#1-1-通过Webview的委托方法拦截" class="headerlink" title="1.1 通过Webview的委托方法拦截"></a>1.1 通过Webview的委托方法拦截</h3><p>UIWebview<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(<span class="type">BOOL</span>)webView:(<span class="type">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="type">NSURLRequest</span> *)request navigationType:(<span class="type">UIWebViewNavigationType</span>)navigationType</div><div class="line">&#123;</div><div class="line">    <span class="type">NSString</span> *url = request.<span class="type">URL</span>.absoluteString;</div><div class="line">	<span class="comment">//判断url特征，进行对应的逻辑处理</span></div><div class="line">    <span class="keyword">return</span> <span class="type">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WKWebview<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(void)webView:(<span class="type">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="type">WKNavigationAction</span> *)navigationAction decisionHandler:(void (^)(<span class="type">WKNavigationActionPolicy</span>))decisionHandler</div><div class="line">&#123;</div><div class="line">    <span class="type">NSString</span> *url = navigationAction.request.<span class="type">URL</span>.absoluteString;</div><div class="line">    <span class="comment">//判断url特征，进行对应的逻辑处理</span></div><div class="line">    decisionHandler(<span class="type">WKNavigationActionPolicyAllow</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>优势：实现简单方便</li>
<li>缺点：如果是用GET请求的话在原生和webview之间传参会有长度限制。而POST请求的话需要只能在UIWebview上才能获取到请求体，在WKWebview里面是无法获取到POST请求体的。</li>
</ul>
<h3 id="1-2-使用WebViewJavascriptBridge"><a href="#1-2-使用WebViewJavascriptBridge" class="headerlink" title="1.2 使用WebViewJavascriptBridge"></a>1.2 使用WebViewJavascriptBridge</h3><p>这个是iOS上使用的比较多的js交互框架，也是基于拦截URL的方式来实现的。不过在自己公司项目中用的不多，所以没有做深入的了解。</p>
<h3 id="1-3-通过NSURLProtocol拦截"><a href="#1-3-通过NSURLProtocol拦截" class="headerlink" title="1.3 通过NSURLProtocol拦截"></a>1.3 通过NSURLProtocol拦截</h3><p>这个是利用了NSURLProtocol会拦截webview的网络请求而实现的，本质上和通过Webview的委托方法拦截差不多。不过据说WKWebView貌似不支持NSURLProtocol，没有做实验，具体是否可行还需要测试。</p>
<h2 id="2-WKWebView"><a href="#2-WKWebView" class="headerlink" title="2.WKWebView"></a>2.WKWebView</h2><p>iOS8，苹果新推出了WebKit，用WKWebView代替UIWebView和WebView。相关的使用和特性可以细读<a href="http://nshipster.cn/wkwebkit/" target="_blank" rel="external">WKWebView</a>和<a href="http://www.appcoda.com/webkit-framework-intro/" target="_blank" rel="external">A Look at the WebKit</a>、<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView那些坑</a>(林泽水原创发表在bugly公众号上的一篇文章，基本上把它的缺陷都点出来了，入坑前必读)。</p>
<p>优点:功能比UIWebview强大很多，调用js的时候可以返回对象以及错误状态；而且js也可以直接反向回调<br>缺点:WKWebview的坑很多，参见上一段落提到的“<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebview那些坑</a>”</p>
<ul>
<li><p>App调用js<br>WKWebView调用js方法和UIWebView类似，一个是<code>evaluateJavaScript</code>，一个是<code>stringByEvaluatingJavaScriptFromString</code>。不过获取返回值的方式不同，WKWebView用的是闭包回调;UIWebview返回的是一个string。</p>
</li>
<li><p>js调用App<br>UIWebView中js是没办法直接回调App的(只能用url的方式间接回调)，而在WKWebView中有了改进。具体步骤分为App注册handler，js调用，App处理handler委托三个步骤</p>
<ol>
<li><p>注册handler</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">config = <span class="type">WKWebViewConfiguration</span>()</div><div class="line"> <span class="comment">//注册js方法</span></div><div class="line">config.userContentController.addScriptMessageHandler(<span class="keyword">self</span>, name: <span class="string">"WebApp"</span>)</div><div class="line"> <span class="comment">// 初始化</span></div><div class="line">webView = <span class="type">WKWebView</span>(frame: <span class="keyword">self</span>.webWrap.frame, configuration: config)</div></pre></td></tr></table></figure>
</li>
<li><p>js调用<br>通过window.webkit.messageHandlers.WebApp找到之前注册的handler对象，然后调用postMessage方法把数据传到WebApp通过上一步的方法解析方法名和参数。WebApp是之前注册的name。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = &#123;</div><div class="line">                 'method' : 'hello',</div><div class="line">                 'param1' : 'liuyanwei',</div><div class="line">               &#125;;</div><div class="line"> window.webkit.messageHandlers.<span class="type">WebApp</span>.postMessage(message);</div></pre></td></tr></table></figure>
</li>
<li><p>处理handler委托<br>之前初始化Webview时指定的MessageHandler要实现WKScriptMessageHandler的协议方法<code>userContentController(userContentController: WKUserContentController, didReceiveScriptMessage message: WKScriptMessage)</code>然后在这里面处理事件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">userContentController</span><span class="params">(<span class="number">_</span> userContentController: WKUserContentController, didReceive message: WKScriptMessage)</span></span> &#123;</div><div class="line">       <span class="comment">//根据传过来数据从而决定app调用的方法</span></div><div class="line">       <span class="keyword">let</span> dict = message.body <span class="keyword">as</span>! <span class="type">Dictionary</span>&lt;<span class="type">String</span>,<span class="type">Any</span>&gt;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="3-JavaScriptCore"><a href="#3-JavaScriptCore" class="headerlink" title="3.JavaScriptCore"></a>3.JavaScriptCore</h2><p>JavaScriptCore中类及协议：<br>JSContext：给JavaScript提供运行的上下文环境,通过-evaluateScript:方法就可以执行js代码<br>JSValue：封装了js与OC中的对应的类型，以及调用js的API等<br>JSManagedValue：管理数据和方法的类<br>JSVirtualMachine：处理线程相关，使用较少<br>JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议，在协议中声明的API都会在js中暴露出来，才能调用</p>
<ul>
<li><p>OC调用js<br>在JavaScriptCore中提供的调用js的方法<code>-(JSValue *)evaluateScript:(NSString *)script</code>方法就可以执行一段JavaScript脚本，并且如果其中有方法、变量等信息都会被存储在其中以便在需要的时候使用。<br>JSValue提供了<code>-(JSValue *)callWithArguments:(NSArray *)arguments</code>方法来将参数传进去调用方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个JSContext对象，就类似于js中的window</span></div><div class="line"> <span class="comment">// 只需要创建一次即可。</span></div><div class="line"><span class="type">JSContext</span> *context = [[<span class="type">JSContext</span> alloc] <span class="keyword">init</span>];</div><div class="line"><span class="comment">// 执行一段js</span></div><div class="line">[context evaluateScript:@<span class="string">"function add(a, b) &#123; return a + b; &#125;"</span>];</div><div class="line"><span class="comment">// 根据下标取出方法</span></div><div class="line"><span class="type">JSValue</span> *add = context[@<span class="string">"add"</span>];</div><div class="line"><span class="type">NSLog</span>(@<span class="string">"Func: %@"</span>, add);</div><div class="line"><span class="comment">// 传入参数 调用取到的方法</span></div><div class="line"><span class="type">JSValue</span> *sum = [add callWithArguments:@[@(<span class="number">7</span>), @(<span class="number">21</span>)]];</div><div class="line"><span class="type">NSLog</span>(@<span class="string">"Sum: %d"</span>,[sum toInt32]);</div><div class="line"><span class="comment">//OutPut:</span></div><div class="line"><span class="comment">// Func: function add(a, b) &#123; return a + b; &#125;</span></div><div class="line"><span class="comment">// Sum: 28</span></div></pre></td></tr></table></figure>
</li>
<li><p>js调用OC<br>使用JavaScriptCore在JS端调用原生代码的时候主要有两种方式：block和方法注入。</p>
<ol>
<li><p>Block方式</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    <span class="type">JSContext</span> *context = [[<span class="type">JSContext</span> alloc] <span class="keyword">init</span>];</div><div class="line">	<span class="comment">// 定义一个block</span></div><div class="line">	context[@<span class="string">"log"</span>] = ^() &#123;</div><div class="line">  	  <span class="type">NSArray</span> *args = [<span class="type">JSContext</span> currentArguments];</div><div class="line">    	<span class="keyword">for</span> (<span class="type">JSValue</span> *jsVal <span class="keyword">in</span> args) &#123;</div><div class="line">  	 		<span class="type">NSLog</span>(@<span class="string">"%@"</span>, jsVal);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="type">JSValue</span> *this = [<span class="type">JSContext</span> currentThis];</div><div class="line">		<span class="type">NSLog</span>(@<span class="string">"this: %@"</span>,this);</div><div class="line">		<span class="type">NSLog</span>(@<span class="string">"-------End Log-------"</span>);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 调用js执行log方法</span></div><div class="line"> [context evaluateScript:@<span class="string">"log('ider', [7, 21],&#123; hello:'world', js:100 &#125;);"</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>OC方法注入<br>这里需要原生自定义一个协议，并且它还需要遵守JSExport协议。协议里的方法，就是暴露给js端的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@<span class="class"><span class="keyword">protocol</span> <span class="title">JavaScriptObjectiveCDelegate</span> &lt;<span class="title">JSExport</span>&gt;</span></div><div class="line">-(<span class="title">void</span>)<span class="title">callWithDict</span>:(<span class="title">NSDictionary</span> *)<span class="title">params</span>;</div><div class="line">@<span class="title">end</span></div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>然后自定义一个对象，让这个对象来实现上面所说的协议<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 此模型用于注入JS的模型，这样就可以通过模型来调用方法。</span></div><div class="line">@interface <span class="type">HYBJsObjCModel</span> : <span class="type">NSObject</span> &lt;<span class="type">JavaScriptObjectiveCDelegate</span>&gt;</div><div class="line">@property (nonatomic, <span class="keyword">weak</span>) <span class="type">JSContext</span> *jsContext;</div><div class="line">@property (nonatomic, <span class="keyword">weak</span>) <span class="type">UIWebView</span> *webView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation <span class="type">HYBJsObjCModel</span></div><div class="line">- (void)callWithDict:(<span class="type">NSDictionary</span> *)params &#123;</div><div class="line"> <span class="type">NSLog</span>(@<span class="string">"Js调用了OC的方法，参数为：%@"</span>, params);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>对象实现完了，在哪里注入呢。在controller的webView加载完成后我们是通过webView的valueForKeyPath获取的，其路径为documentView.webView.mainFrame.javaScriptContext。这样就可以获取到js的context，然后为这个context注入我们的模型对象。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)webViewDidFinishLoad:(<span class="type">UIWebView</span> *)webView </div><div class="line">&#123;</div><div class="line"> <span class="keyword">self</span>.jsContext = [webView valueForKeyPath:@<span class="string">"documentView.webView.mainFrame.javaScriptContext"</span>];</div><div class="line">  <span class="comment">// 通过模型调用方法，这种方式更好些。</span></div><div class="line">  <span class="type">HYBJsObjCModel</span> *model  = [[<span class="type">HYBJsObjCModel</span> alloc] <span class="keyword">init</span>];</div><div class="line">  <span class="comment">// 模型</span></div><div class="line">  <span class="keyword">self</span>.jsContext[@<span class="string">"OCModel"</span>] = model;</div><div class="line">  model.jsContext = <span class="keyword">self</span>.jsContext;</div><div class="line">  model.webView = <span class="keyword">self</span>.webView;</div><div class="line">  <span class="comment">// 增加异常的处理</span></div><div class="line">  <span class="keyword">self</span>.jsContext.exceptionHandler = ^(<span class="type">JSContext</span> *context,   </div><div class="line"> <span class="type">JSValue</span> *exceptionValue) &#123;</div><div class="line">    context.exception = exceptionValue;</div><div class="line">    <span class="type">NSLog</span>(@<span class="string">"异常信息：%@"</span>, exceptionValue);</div><div class="line"> &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的在js端调用的代码如下<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 100px"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>OC方法注入<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Call OC method"</span> <span class="attr">onclick</span>=<span class="string">"OCModel.callWithDict()"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>JavaScript调用本地方法是在子线程中执行的，这里要根据实际情况考虑线程之间的切换。</p>
<h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考:"></a>相关参考:</h2><ul>
<li><a href="http://www.jianshu.com/p/0042d8eb67c0" target="_blank" rel="external">WebView与JS的几种交互</a></li>
<li><a href="http://www.jianshu.com/p/f896d73c670a" target="_blank" rel="external">Objective-C与JavaScript交互的那些事</a></li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a href="/2017/09/10/NSURLProtocol介绍/" class="pre">NSURLProtocol总结</a><a href="/2017/02/06/HTTP权威指南/" class="next">《HTTP权威指南》笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CS基础/">CS基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS开发/">iOS开发</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/25/iOS Fastlane打包教程/">iOS Fastlane打包教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/25/移动开发中的CI方案简介/">移动开发中的CI方案简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/06/Match工具介绍/">Match工具介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/06/Xcode签名机制/">Xcode Signing 机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/13/给Xcode8安装插件/">给Xcode8安装插件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/NSURLProtocol介绍/">NSURLProtocol总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/20/iOS平台Webview和原生代码交互/">iOS平台Webview和原生代码交互</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/06/HTTP权威指南/">《HTTP权威指南》笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/16/What's-New-in-iOS10/">What's New in iOS</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/13/cell-height-calc-with-autolayout/">项目中Cell自动计算行高的实践</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Ney的技术博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>