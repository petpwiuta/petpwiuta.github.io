<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />




  


  <link rel="alternate" href="/atom.xml" title="Ney的技术博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="《程序员的自我修养》的读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="程序员的自我修养：装载与动态链接">
<meta property="og:url" content="http://petpwiuta.github.io/2020/05/09/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/index.html">
<meta property="og:site_name" content="Ney的技术博客">
<meta property="og:description" content="《程序员的自我修养》的读书笔记">
<meta property="og:image" content="http://petpwiuta.github.io/images/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/6.3.2-1.png">
<meta property="og:image" content="http://petpwiuta.github.io/images/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/6.4.2-1.png">
<meta property="article:published_time" content="2020-05-09T05:38:40.974Z">
<meta property="article:modified_time" content="2020-05-09T05:38:40.974Z">
<meta property="article:author" content="Ney">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://petpwiuta.github.io/images/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/6.3.2-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://petpwiuta.github.io/2020/05/09/程序员的自我修养：装载与动态链接/"/>





  <title>程序员的自我修养：装载与动态链接 | Ney的技术博客</title>
  














<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ney的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Learning，sharing，improving</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://petpwiuta.github.io/2020/05/09/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ney">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ney的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">程序员的自我修养：装载与动态链接</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-09T13:38:40+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">CS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  《程序员的自我修养》的读书笔记
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="6-可执行文件的装载与进程"><a href="#6-可执行文件的装载与进程" class="headerlink" title="6 可执行文件的装载与进程"></a>6 可执行文件的装载与进程</h2><h3 id="6-1-进程虚拟地址空间"><a href="#6-1-进程虚拟地址空间" class="headerlink" title="6.1 进程虚拟地址空间"></a>6.1 进程虚拟地址空间</h3><p>程序被运行起来以后，它将拥有自己独立的虚拟地址空间（Virtual Address Space），这个虚拟地址空间的大小由CPU的位数决定的。硬件决定了地址空间的最大理论上限，比如32位的硬件平台决定了虚拟地址空间的大小是$ 2^{32}$也就是我们常说的4GB虚拟空间大小；而64位的硬件平台具有64位寻址能力，它的虚拟地址空间达到了$2^{64}$，即16384PB大小。</p>
<p>在程序实际运行的过程中，虚拟地址空间也不是全部被程序所使用。如Linux下，操作系统会占据一部分高地址空间，剩下的部分才是分配给应用程序的。</p>
<h3 id="6-2-装载的方式"><a href="#6-2-装载的方式" class="headerlink" title="6.2 装载的方式"></a>6.2 装载的方式</h3><p>现在的操作系统装载可执行文件都是使用分页式加载，即把虚拟内存空间分割成固定大小的页面，当实际有代码或数据使用的内存空间时，才会把虚拟的内存空间映射到物理内存中。</p>
<h3 id="6-3-从操作系统角度看可执行文件的装载"><a href="#6-3-从操作系统角度看可执行文件的装载" class="headerlink" title="6.3 从操作系统角度看可执行文件的装载"></a>6.3 从操作系统角度看可执行文件的装载</h3><h4 id="6-3-1-进程的建立"><a href="#6-3-1-进程的建立" class="headerlink" title="6.3.1 进程的建立"></a>6.3.1 进程的建立</h4><p>从操作系统的角度来看，一个进程最关键的特征是它拥有独立的虚拟地址空间，这使得它有别于其他进程。很多时候一个程序被执行同时都伴随着一个新的进程的创建 ，那么我们就来看看这种最通常的情形；创建一个进程，然后装载相应的可执行文件并且执行。在有虚拟存储的情况下，上述过程最开始只需要做三件事情：</p>
<ul>
<li>创建一个独立的虚拟地址空间</li>
<li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</li>
<li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</li>
</ul>
<h5 id="创建虚拟地址空间"><a href="#创建虚拟地址空间" class="headerlink" title="创建虚拟地址空间"></a>创建虚拟地址空间</h5><p>一个虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间，那么创建一个虚拟空间实际上并不是创建空间而是创建映射函数所需要的相应的数据结构，在x86的Linux下，创建虚拟地址空间实际上只是分配一个页目录（Page Directory）就可以了，甚至不设置页映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置都行。</p>
<h5 id="映射可执行文件到虚拟内存空间"><a href="#映射可执行文件到虚拟内存空间" class="headerlink" title="映射可执行文件到虚拟内存空间"></a>映射可执行文件到虚拟内存空间</h5><p>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。上一步的页映射关系函数是虚拟空间到物理内存的映射关系，这一步所做的是虚拟空间与可执行文件的映射关系。我们知道，当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。当操作系统捕获到缺页错误时，它应知道程序当前所需要的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系。从某种角度来看，这一步是整个装载过程中最重要的一步，也是传统意义上“装载”的过程。</p>
<h5 id="跳转到可执行文件入口，运行可执行文件"><a href="#跳转到可执行文件入口，运行可执行文件" class="headerlink" title="跳转到可执行文件入口，运行可执行文件"></a>跳转到可执行文件入口，运行可执行文件</h5><p>操作系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行。这一步看似简单，实际上在操作系统层面上比较复杂，它涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换。不过从进程的角度看这一步可以简单地认为操作系统执行了一条跳转指令直接跳转到可执行文件的入口地址。ELF文件头中保存有入口地址，CPU也就是从这个地址开始执行代码。</p>
<h4 id="6-3-2-页错误"><a href="#6-3-2-页错误" class="headerlink" title="6.3.2 页错误"></a>6.3.2 页错误</h4><p>上面的步骤执行完以后，其实可执行文件的真正指令和数据都没有被装入到内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系。当CPU开始打算执行入口地址的指令时，发现内存所属页面是个空页面，于是它就认为这是一个页错误（Page Fault）。CPU将控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况。</p>
<p>这时候前面提到的虚拟空间与可执行文件的映射关系结构起到了很关键的作用，操作系统将查询这个数据结构，找到空页面所在的段，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还回给进程，进程从刚才页错误的位置重新开始执行。</p>
<p>随着进程的执行，页错误也会不断地产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求。有时进程所需内存会超过实际可用的内存，这时候系统会把不常用的内存数据转移到磁盘中，来提升内存使用效率。</p>
<p><img src="/images/程序员的自我修养：装载与动态链接/6.3.2-1.png" alt="6.3.2-1" style="zoom:50%;" /></p>
<h3 id="6-4-进程虚拟内存空间分布"><a href="#6-4-进程虚拟内存空间分布" class="headerlink" title="6.4 进程虚拟内存空间分布"></a>6.4 进程虚拟内存空间分布</h3><h4 id="6-4-1-ELF文件链接视图和执行视图"><a href="#6-4-1-ELF文件链接视图和执行视图" class="headerlink" title="6.4.1 ELF文件链接视图和执行视图"></a>6.4.1 ELF文件链接视图和执行视图</h4><p>在ELF文件中，一般会有很多段，在把段加载到内存中时，会分配单独的内存页来控制段的内存权限。不过很多段都很小，这样单独分配一个内存页太浪费空间。所以处于节省内存的考虑，就在ELF文件中新增了Segment的概念，即把内存属性相似的段合在一起，形成Segment。</p>
<p>Segment的概念实际上是从装载的角度重新划分了ELF的各个分段。在将目标文件链接成可执行文件的时候，链接器会尽可能把相同权限属性的段分配在同一空间。</p>
<p>这样本来以前可能有几十个段，现在合并内存权限相似的同类项，最后只形成几个Segment。这样系统在加载时只用进行有限的几种内存权限控制就行了。</p>
<p>所以总的来说，“Segment”和“Section”是从不同的角度来划分同一个EF文件。这个在ELF中被称为不同的视图（View），从“Section”的角度来看ELF文件就是链接视图（Linking view），从“Segment”的角度来看就是执行视图（Execution view）。当我们在谈到ELF装载时，“段”专门指“Segment”；而在其他的情况下，“段”指是“Section”</p>
<p>ELF文件保存“Segment”信息的数据结构叫做程序头表（Program Header Table）。因为ELF目标文件不需要被装载，所以它没有程序头表；而经过静态/动态链接的ELF的可执行文件以及共享库文件都有。</p>
<p>和段表结构一样，程序头表也是一个数组结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word p_type;</span><br><span class="line">    Elf32_Off  p_offset;</span><br><span class="line">    Elf32_Addr p_vaddr;</span><br><span class="line">    Elf32_Addr p_paddr;</span><br><span class="line">    Elf32_Word p_filesz;</span><br><span class="line">    Elf32_Word p_memsz;</span><br><span class="line">    Elf32_Word p_flags;</span><br><span class="line">    Elf32_Word p_align;</span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure>
<p>具体的字段解释如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>p_type</td>
<td>这里主要关注“LOAD”类型。它的常量为1。还有“DYNAMIC”等类型（动态链接用）</td>
</tr>
<tr>
<td>p_offset</td>
<td>在ELF文件中的偏移量</td>
</tr>
<tr>
<td>p_vaddr</td>
<td>在进程虚拟内存空间中的起始位置。整个程序头表中，所有“LOAD”类型的元素按照p_addr从小到大排列</td>
</tr>
<tr>
<td>p_paddr</td>
<td>物理装载地址。一般和p_vaddr一样</td>
</tr>
<tr>
<td>p_filesz</td>
<td>在ELF文件中所占字节数</td>
</tr>
<tr>
<td>p_memse</td>
<td>在进程虚拟内存空间中所占字节数。可能大于p_filesz</td>
</tr>
<tr>
<td>p_flags</td>
<td>权限属性，如可写、可读、可执行</td>
</tr>
<tr>
<td>p_align</td>
<td>对齐属性。对齐字节数等于$ 2^{align}$。如p_align=10，那对齐字节数就是2的10次方，即1024</td>
</tr>
</tbody>
</table>
</div>
<p>对于“LOAD”类型的“Segment”来说，p_memse的值不可以小于p_files。但可以大于p_files。当大于p_files就表示该“Segment”在内存中所分配的空间大小超过文件中实际的大小。这部分“多余”的内存全部填充为“0”。这样做的好处是在构造ELF可执行文件时不需要再额外设立BSS的“Segment”了，可以把数据“Segment”的p_mems扩大，那些额外的部分就是BSS。</p>
<h4 id="6-4-2-堆和栈"><a href="#6-4-2-堆和栈" class="headerlink" title="6.4.2 堆和栈"></a>6.4.2 堆和栈</h4><p>Linux把进程虚拟空间中的一个段叫做虚拟内存区域（VMA，Virtual Memory Area）。之前说的Segment都会映射的VMA里。操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间。应用程序使用的栈和堆也是通过VMA来进行管理的。一个常见的进程虚拟空间如下图所示：</p>
<p><img src="/images/程序员的自我修养：装载与动态链接/6.4.2-1.png" alt="6.4.2-1" style="zoom:50%;" /></p>
<h2 id="7-动态链接"><a href="#7-动态链接" class="headerlink" title="7 动态链接"></a>7 动态链接</h2><h3 id="7-1-为什么要动态链接"><a href="#7-1-为什么要动态链接" class="headerlink" title="7.1 为什么要动态链接"></a>7.1 为什么要动态链接</h3><p>静态链接使得程序可以模块化开发和测试大幅提高开发效率。不过随着程序规模越来越大静态链接的诸多缺点也逐步暴露出来：</p>
<ul>
<li><p>内存和磁盘空间浪费</p>
<p>比如有个流行的库文件LibA，很多软件产品都使用，这些软件产品的最终可执行文件中都会包含LibA。某个用户电脑上安装多个软件产品后，电脑中就会存在多分LibA的副本。而且运行多个程序时，内存中也会存在多个LibA的副本。</p>
</li>
<li><p>程序开发和发布比较麻烦</p>
<p>如果LibA有bug，厂商发布了补丁以后，必须重新链接。用户需要重新下载整个可执行文件， 但是除了LibA意外，其他的都没有必要再下载一次。</p>
</li>
</ul>
<p>解决空间浪费和更新困难的办法就是把程序的模块相互分割开来，形成独立的文件，当程序要运行时再进行链接。这样库LibA是以独立的文件存在，多个程序可以共享，避免内存和磁盘的浪费；也能独立地发布和更新，提高软件产品的生产效率。上面这种按模块分割、到运行的时候再链接就是动态链接（Dynamic Linking）。</p>
<h3 id="7-3-地址无关代码"><a href="#7-3-地址无关代码" class="headerlink" title="7.3 地址无关代码"></a>7.3 地址无关代码</h3><h4 id="7-3-1-固定装载地址的困扰"><a href="#7-3-1-固定装载地址的困扰" class="headerlink" title="7.3.1 固定装载地址的困扰"></a>7.3.1 固定装载地址的困扰</h4><p>因为动态链接的库可能被多个程序使用，会被不同的程序加载到不同的位置。所以动态链接文件在编译时不能假设自己在进程的虚拟内存空间中的位置。</p>
<h4 id="7-3-2-装载时重定位"><a href="#7-3-2-装载时重定位" class="headerlink" title="7.3.2 装载时重定位"></a>7.3.2 装载时重定位</h4><p>在静态链接时说起过，符号要在编译时进行解析和重定位。这里也可以用同样的做法，即程序在运行时把动态链接库像静态库一样进行解析和重定位，这时的重定位叫做装载时重定位（Load Time Relocation），之前提到的重定位叫链接时重定位（Link Time Relocation）。</p>
<p>装载时重定位技术对于动态链接库的指令部分和数据部分有不同的影响。</p>
<p>对于数据部分来说。每个进程的数据都需要独立存在，所以动态链接库的数据部分在每个进程中都需要一个副本。</p>
<p>对于指令部分来说，从同一个可执行文件运行的进程，其指令部分必然是一样的。所以同一份动态链接库在内存中有多个副本是没有必要的。但是动态链接模块在装载时要进行重定位，需要修改指令引用的地址，A进程重定位后的动态链接库内指令引用的地址已经被修改，以适应A的进程空间里。这时，动态链接库肯定不能用到B上，所以B只能再把动态链接库重新制作一份副本，再进行一次装载时重定位。所以就造成在内存中存在同一份动态库的多个副本。</p>
<h4 id="7-3-3-地址无关代码"><a href="#7-3-3-地址无关代码" class="headerlink" title="7.3.3 地址无关代码"></a>7.3.3 地址无关代码</h4><p>要解决动态库指令部分重复的办法关键在于指令的地址。程序模块中共享的指令部分在装载时不要因为装载地址的改变而改变。</p>
<p>解决方案的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为地址无关代码（PC，Position-independent Code）的技术。</p>
<p>因为模块内的引用可以用模块内的相对地址偏移来实现，比较简单，所以地址无关的代码重点放在模块间的数据和指令的引用。</p>
<h5 id="模块间的数据访问"><a href="#模块间的数据访问" class="headerlink" title="模块间的数据访问"></a>模块间的数据访问</h5><p>之前提到，要使得代码地址无关，基本的思想就是把跟地址相关的部分放到数据段里面。很显然，这些其他模块的全局变量的地址是跟模块装载地址有关的。ELF的做法是在数据段里面建立一个指向这些变量的指针数组，也被称为全局偏移表（GOT，Global Offset Table），当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用。</p>
<p>当指令中需要访问某个模块外的全局变量时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4个字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。</p>
<h5 id="模块间的函数跳转"><a href="#模块间的函数跳转" class="headerlink" title="模块间的函数跳转"></a>模块间的函数跳转</h5><p>对于模块间的函数跳转也可以用GOT的方法，即在GOT表项中保存目标函数地址，当模块要调用函数时，通过GOT间接跳转。</p>
<h4 id="7-3-4-共享模块的全部变量问题"><a href="#7-3-4-共享模块的全部变量问题" class="headerlink" title="7.3.4 共享模块的全部变量问题"></a>7.3.4 共享模块的全部变量问题</h4><p>有一种很特殊的情况是，当一个模块引用了一个定义在共享对象的全局变量的时候，比如一个共享对象定义了一个全局变量global，而模块module.c中是这么引用的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> global;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    global = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当编译器编译module.c时，它无法根据这个上下文判断global是定义在同一个模块的的其他目标文件还是定义在另外一个共享对象之中，即无法判断是否为跨模块间的调用。</p>
<p>假设module.c是程序可执行文件的一部分，那么在这种情况下，由于程序主模块的代码并不是地址无关代码。由于可执行文件在运行时并不进行代码重定位，所以变量的地址必须在链接过程中确定下来。为了能够使得链接过程正常进行，链接器会在创建可执行文件时，在它的“.bss”段创建一个global变量的副本。那么问题就很明显了，现在global变量定义在原先的共享对象中，而在可执行文件的“.bss”段还有一个副本。如果同一个变量同时存在于多个位置中，这在程序实际运行过程中肯定是不可行的。</p>
<p>解决的办法只有一个，那就是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。ELF共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量，通过GOT来实现变量的访问。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把GOT中的相应地址指向该副本，这样该变量在运行时实际上最终就只有一个实例。如果变量在共享模块中被初始化，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本里；如果该全局变量在程序主模块中没有副本，那么GOT中的相应地址就指向模块内部的该变量副本。</p>
<h4 id="7-3-5-数据段地址无关性"><a href="#7-3-5-数据段地址无关性" class="headerlink" title="7.3.5 数据段地址无关性"></a>7.3.5 数据段地址无关性</h4><p>通过上面的方法，我们能够保证共享对象中的代码部分地址无关，其实数据部分也有绝对地址引用的问题。不过对于数据段来说，它在每个进程都有一份独立的副本，所以并不担心被进程改变。从这点来看，我们可以选择装载时重定位的方法来解决数据段中绝对地址引用问题。</p>
<p>对于共享对象来说，如果数据段中有绝对地址引用，那么编译器和链接器就会产生一个重定位表，用于解决上述问题。当动态链接器装载共享对象时，如果发现该共享对象有这样的重定位入口，那么动态链接器就会对该共享对象进行重定位。</p>
<p>实际上，我们甚至可以让代码段也使用这种装载时重定位的方法，而不使用地址无关代码。不过如果代码不是地址无关的，它就不能被多个进程之间共享，于是也就失去了节省内存的优点。但是装载时重定位的共享对象的运行速度要比使用地址无关代码的共享对象快，因为它省去了地址无关代码中每次访问全局数据和函数时需要做一次计算当前地址以及间接地址寻址的过程。</p>
<h3 id="7-4-延迟绑定（PLT）"><a href="#7-4-延迟绑定（PLT）" class="headerlink" title="7.4 延迟绑定（PLT）"></a>7.4 延迟绑定（PLT）</h3><p>动态链接比静态链接灵活，但是这是以牺牲一部分性能为代价的。动态链接比静态链接慢的主要原因是动态链接下要进行复杂的GOT定位以及间接寻址。另外一个原因是动态链接的链接工作在程序启动前完成，在启动前动态链接器会寻找并装载所需要的共享对象，进行符号査找地址重定位等工作，这一套流程下来势会必减慢程序的启动速度。下面就来介绍下优化动态链接性能的一些方法。</p>
<h5 id="延迟绑定实现"><a href="#延迟绑定实现" class="headerlink" title="延迟绑定实现"></a>延迟绑定实现</h5><p>在动态链接下，程序模块之间包含了大量的函数引用（全局变量往往比较少，因为大量的全局变量会导致模块之间耦合度变大），所以在程序开始执行前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号査找以及重定位，这也是我们上面提到的减慢动态链接性能的第二个原因。</p>
<p>不过在一个程序运行过程中，可能很多冷门模块的函数在程序执行完时都不会被用到。所以没必要一开始就把所有函数都链接好。因此ELF采用了一种叫做延迟绑定（Lazy Binding）的做法，就是当函数第一次被用到时才进行绑定（符号查找、重定位等），如果没有用到则不进行绑定。所以可以大大加快程序的启动速度</p>
<p>ELF使用PLT（Procedure Linkage Table）的方法来实现。PLT为了实现延迟绑定，在GOT间接跳转这个过程中间又增加了一层间接跳转。所有外部函数在PLT中都有一个对应项，调用函数时，会先调用PLT对应项的处理函数，它会先检查GOT中函数指针是否已经绑定，如果没有绑定会进行绑定，把正确的函数地址填入GOT表中，然后再调用GOT中的函数。</p>
<h3 id="7-5-动态链接相关结构"><a href="#7-5-动态链接相关结构" class="headerlink" title="7.5 动态链接相关结构"></a>7.5 动态链接相关结构</h3><h4 id="7-5-1-“-interp”段"><a href="#7-5-1-“-interp”段" class="headerlink" title="7.5.1 “.interp”段"></a>7.5.1 “.interp”段</h4><p>在Linux下，动态链接器ld.so实际上也是一个共亨对象，操作系统同样通过映射的方式将它加载到进程的地址空间中。操作系统在加载完动态链接器之后，就将控制权交给动态链接器的入口地址（与可执行文件一样，共享对象也有入口地址）。当动态链接器得到控制权之后，它开始执行一系列自身的初始化操作，然后根据当前的环境参数，开始对可执行文件进行动态链接工作。当所有动态链接工作完成以后，动态链接器会将控制权转交到可执行文件的入口地址，程序开始正式执行。</p>
<p>在ELF文件中，有个叫“.interp”的段，专门用来保存可执行文件所需要的动态链接器的路径。</p>
<h4 id="7-5-2-“-dynamic”段"><a href="#7-5-2-“-dynamic”段" class="headerlink" title="7.5.2 “.dynamic”段"></a>7.5.2 “.dynamic”段</h4><p>动态链接ELF中最重要的结构就是“.dynamic”段，这个段里面保存了动态链接器所需要的基本信息，比如依赖哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。它的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>
<p>EI32Dyn结构由一个类型值加上一个附加的数值或指针，对于不同的类型，后面附加的数值或者指针有着不同的含义。这里列举几个比较常见的类型值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>d_tag类型</th>
<th>d_un含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>DT_SYMTAB</td>
<td>动态链接符号表地址，d_ptr表示“.dynamic”的地址</td>
</tr>
<tr>
<td>DT_STRTAB</td>
<td>动态链接字符串表地址，d_ptr表示“.dynstr”的地址</td>
</tr>
<tr>
<td>DT_STRSZ</td>
<td>动态链接字符串表大小，d_val表示大小</td>
</tr>
<tr>
<td>DT_HASH</td>
<td>动态链接哈希表地址，d_val表示“.hash”的地址</td>
</tr>
<tr>
<td>DT_SONAME</td>
<td>本共享对象的“SO-NAME”</td>
</tr>
<tr>
<td>DT_RPATH</td>
<td>动态链接共享对象搜索路径</td>
</tr>
<tr>
<td>DT_INIT</td>
<td>初始化代码地址</td>
</tr>
<tr>
<td>DT_FINIT</td>
<td>反初始化代码地址</td>
</tr>
<tr>
<td>DT_NEED</td>
<td>依赖的其他共享对象文件，d_ptr表示所依赖的共享对象文件名</td>
</tr>
<tr>
<td>DT_REL / DT_RELA</td>
<td>动态链接重定位表地址</td>
</tr>
<tr>
<td>DT_RELENT / DT_RELAENT</td>
<td>动态重定位表入口数量</td>
</tr>
</tbody>
</table>
</div>
<h4 id="7-5-3-动态符号表"><a href="#7-5-3-动态符号表" class="headerlink" title="7.5.3 动态符号表"></a>7.5.3 动态符号表</h4><p>在静态链接中，有一个专门的段叫做符号表“symtab”（Symbol Table），里面保存了所有关于该目标文件的符号的定义和引用。动态链接的符号表跟它十分相似，叫做动态符号表（Dynamic Symbol Table），用来保存模块间的符号导入导出关系，这个段的段名通常叫做“.dynsym”（Dynamic Symbol）。</p>
<p>与“.symtab”不同的是，“.dynsym”只保存了与动态链接相关的符号，对于那些模块内部的符号则不保存。很多时候动态链接的模块同时拥有“.dynsym”和“.symtab”两个表，“.symtab”中往往保存了所有符号，包括“.dynsym”中的符号。</p>
<p>与“.symtab”类似，动态符号表也需要一些辅助的表，比如用于保存符号名的字符串表。静态链接时叫做符号字符串表“.strtab”（String Table），在这里就是动态符号字符串表”.dynstr”（Dynamic String Table）；由于动态链接下，我们需要在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的符号哈希表（“.hash”）。</p>
<h4 id="7-5-4-动态链接重定位表"><a href="#7-5-4-动态链接重定位表" class="headerlink" title="7.5.4 动态链接重定位表"></a>7.5.4 动态链接重定位表</h4><p>共享对象的重定位与静态链接”的目标文件的重定位十分类似，唯一有区别的是目标文件的重定位是在静态链接时完成的，而共享对象的重定位是在装载时完成的。</p>
<p>在静态链接中，日标文件里面包含有专门用于表示重定位信息的重定位表，比如“.rel.text”表示是代码段的重定位表，“.rel.data”是数据段的重定位表。动态链接的文件中，也有类似的重定位表分别叫做“rel.dyn”和“rel.plt’”，它们分别相当于“.rel.text”和“.rel.data”。“rel.dyn”是对数据引用的修正，它所修正的位置位于“got”以及数据段；而“rel.plt”是对函数引用的修正，它所修止的位置位于“.got.plt”。</p>
<h3 id="7-6-动态链接的步骤和实现"><a href="#7-6-动态链接的步骤和实现" class="headerlink" title="7.6 动态链接的步骤和实现"></a>7.6 动态链接的步骤和实现</h3><h4 id="7-6-1-动态链接器自举"><a href="#7-6-1-动态链接器自举" class="headerlink" title="7.6.1 动态链接器自举"></a>7.6.1 动态链接器自举</h4><p>动态链接器本身也是一个共享对象，但是它有一些特殊性。对于普通共享对象文件来说，它的重定位工作由动态链接器来完成；它也可以依赖于其他共亨对象，其中的被依赖的共亨对象由动态链接器负责链接和装载。可是对于动态链接器本身来说，它是一切动态加载的起源，所以它有一些特殊。</p>
<p>动态链接器本身不可以依赖于其他任何共享对象；其次是动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成。对于第一个条件我们可以人为地控制，在编写动态链接器时保证不使用任何系统库、运行库；对于第二个条件，动态链接器必须在启动时有段非常精巧的代码可以完成这项艰巨的工作而同时又不能用到全局和静态变量。这种具有一定限制条件的启动代码往往被称为自举（Boot strap）。</p>
<p>动态链接器入口地址即是自举代码的入口，当操作系统将进程控制权交给动态链接器时，动态链接器的自举代码即开始执行。自举代码首先会找到它自己的GOT。而GOT的第一个入口保存的即是“.dynamic”段的偏移地址，由此找到了动态连接器本身的“.dynamic”段。通过“.dynamic”中的信息，自举代码便可以获得动态链接器本身的重定位表和符号表等，从而得到动态链接器本身的重定位入口，先将它们全部重定位。从这一步开始，动态链接器代码中才可以开始使用自己的全局变量和静态变量。</p>
<p>实际上在动态链接器的自举代码中，除了不可以使用全局变量和静态变量之外，甚至不能调用函数，即动态链接器本身的函数也不能调用。因为动态链接库模块使用GOT/PLT的方式编译，对于模块内部的函数调用也是采用跟模块外部函数调用一样的方式，所以在GOT/PLT没有被重定位之前，自举代码不可以使用任何全局变量，也不可以调用函数。</p>
<h4 id="7-6-2-装载共享对象"><a href="#7-6-2-装载共享对象" class="headerlink" title="7.6.2 装载共享对象"></a>7.6.2 装载共享对象</h4><p>完成基本自举以后，动态链接器将可执行文件和链接器本身的符号表都合并到一个全局符号表（Global Symbol Table）。然后链接器开始寻找可执行文件所依赖的共享对象，前面提到过“.dynamic”段中，有一种类型的是DT_NEEDED，它所指出的是该可执行文件（或共享对象）所依赖的共享对象。由此，链接器可以列出可执行文件所需要的所有共享对象，并将这些共享对象的名字放入到一个装载集合中。然后链接器开始从集合里取个所需要的共享对象的名字，找到相应的文件后打开该文件，读取相应的ELF文件头和“.dynamic”段，然后将它相应的代码段和数据段映射到进程空间中。如果这个ELF共享对象还依赖于其他共享对象，那么将所依赖的共享对象的名字放到装载集合中。如此循环直到所有依赖的共享对象都被装载进来为止，当然链接器可以有不同的装载顺序，如果我们把依赖关系看作一个图的话，那么这个装载过程就是一个图的遍历过程，链接器可能会使用深度优先或者广度优先或者其他的顺序来遍历整个图，这取决于链接器，比较常见的算法一般都是广度优先的。</p>
<p>当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中，所以当所有的共享对象都被装载进来的时候，全局符号表里面将包含进程中所有的动态链接所需要的符号。</p>
<h5 id="符号优先级"><a href="#符号优先级" class="headerlink" title="符号优先级"></a>符号优先级</h5><p>在加载多个动态链接库时，可能会遇到符号冲突的问题。Linux下的动态链接器规定：当一个符号需要被加入全局符号表时，如果相同符号已经存在，则后加入的符号被忽略。</p>
<p>由于存在这种重名符号被直接忽略的问题，当程序使用大量共享对象时应该非常小心符号的重名问题，如果两个符号重名又执行不同的功能，那么程序运行时可能会将所有该符号名的引用解析到第一个被加入全局符号表的使用该符号名的符号，从而导致程序莫名其妙的错误。</p>
<h5 id="全局符号介入与地址无关代码"><a href="#全局符号介入与地址无关代码" class="headerlink" title="全局符号介入与地址无关代码"></a>全局符号介入与地址无关代码</h5><p>前面说到地址无关代码时，对于模块内部调用或跳转处理，只是简单地将其当作是相对地址调用/跳转。但实际上这个问题比想象中要复杂。由于存在全局符号会覆盖的情况，调用或跳转一个模块内的符号时，它可能会被其他的全局符号覆盖，导致那个相对地址部分就需要重定位，这又与共享对象的地址无关性矛盾。所以对于模块内的调用，编译器只能当作模块外部符号处理。</p>
<p>不过也有一个补救办法。就是把函数变成编译单元私有函数，即使用“static”关键字定义函数，这种情况下，编译器要确定函数不被其他模块覆盖，就可以直接用模块内部调用指令，加快函数的调用速度。</p>
<h4 id="7-6-3-重定位和初始化"><a href="#7-6-3-重定位和初始化" class="headerlink" title="7.6.3 重定位和初始化"></a>7.6.3 重定位和初始化</h4><p>当上面的步骤完成之后，链接器开始重新遍历可执行文件和每个共享对象的重定位表，将它们的GOT/PLT中的每个需要重定位的位置进行修正。因为此时动态链接器已经拥有了进程的全局符号表，所以修正过程也比较容易，跟前面提到的地址重定位的原理基本相同。</p>
<p>重定位完成之后，如果某个共享对象有“.init”段，那么动态链接器会执行“.init”段中的代码，用以实现共享对象特有的初始化过程，比如最常见的，共享对象中的C++的全局/静态对象的构造就需要通过“.init”来初始化。相应地，共享对象中还可能有“.finit”段，当进程退出时会执行“.finit”段中的代码，可以用来实现类似C++全局对象析构之类的操作</p>
<p>如果进程的可执行文件也有“.init”段，那么动态链接器不会执行它，因为可执行文件中的“.init”段和“.finit”段由程序初始化部分代码负责执行。</p>
<p>当完成了重定位和初始化之后，所有的准备工作就宣告完成了，所需要的共享对象也都已经装载并且链接完成了，这时候动态链接器就将进程的控制权转交给程序的入口并且开始执行。</p>
<h3 id="7-7-显式运行时链接"><a href="#7-7-显式运行时链接" class="headerlink" title="7.7 显式运行时链接"></a>7.7 显式运行时链接</h3><p>支持动态链接的系统往往都支持一种更加灵活的模块加载方式，叫做显式运行时链接（Explicit Run-time Linking），有时候也叫做运行时加载。也就是让程序自己在运行时控制加载指定的模块，并且可以在不需要该模块时将其卸载。从前面我们了解到的来看，如果动态链接器可以在运行时将共享模块装载进内存并且可以进行重定位等操作，那么这种运行时加载在理论上也是很容易实现的。而且一般的共享对象不需要进行任何修改就可以进行运行时装载，这种共享对象往往被叫做动态装载库（DynamicLoadingLibrary），其实本质上它跟一般的共享对象没什么区别，只是程序开发者使用它的角度不同。</p>
<p>这种运行时加载使得程序的模块组织变得很灵活，可以用来实现一些诸如插件、驱动等功能。当程序需要用到某个插件或者驱动的时候，才将相应的模块装载进来，而不需要从开始就将他们全部装载进来，从而减少了程序启动时间和内存使用。并且程序可以在运行的时候重新加载某个模块，这样使得程序本身不必重新启动而实现模块的增加、删除、更新等，这对于很多需要长期运行的程序来说是很大的优势。最常见的例子是web服务器程序，对于web服务器程序来说，它需要根据配置来选择不同的脚本解释器、数据库连接驱动等，对于不同的脚本解释器分别做成一个独立的模块，当web服务器需要某种脚本解释器的时候可以将其加载进来；这对于数据库连接的驱动程序也是一样的原理。另外对于一个可靠的web服务器来说，长期的运行是必要的保证，如果我们需要增加某种脚本解释器，或者某个脚本解释器模块需要升级，则可以通知web服务器程序重新装载该共亨模块以实现相应的目的。</p>
<p>在Linux中，从文件本身的格式上来看，动态库实际上跟一般的共享对象没有区别，正如我们前面讨论过的。主要的区别是共享对象是由动态链接器在程序启动之前负责装载和链接的，这一系列步骤都由动态连接器自动完成，对于程序本身是透明的；而动态库的装载则是通过一系列由动态链接器提供的API，具体地讲共有4个函数：打开动态库（dlopen）、查找符号（dsym）、错误处理（dlerror）以及关闭动态库（dlclose），程序可以通过这几个API对动态库进行操作。这几个API的实现是在/lib/libdl.so2里面，它们的声明和相关常量被定义在系统标准头文件<dlfcn.h>。</p>
<ul>
<li><p>dlopen()</p>
<p>打开一个动态库，并将其加载到进程的地址空间，完成初始化过程。</p>
<p>如果参数filename为NUL，那返回的就是全局符号表。</p>
</li>
<li><p>dlsym()</p>
<p>通过这个函数来查找符号，包括函数和变量。</p>
<p>前面在介绍动态链接实现时，已经碰到过许多共享模块中符号名冲突的问题，结论是当多个同名符号冲突时，先装入的符号优先，我们把这种优先级方式称为装载序列。</p>
<p>当我们的进程中有模块是通过dlopen装入的共享对象时，这些后装入的模块中的符号可能会跟先前已经装入了的模块之间的符号重复。不管是通过动态链接器加载还是程序主动加载，都是采用装载序列。</p>
<p>dlsym()对符号的查找优先级分两种类型。第一种情况是，如果我们是在全局符号表中进行符号查找，即dlopen()时，参数filename为NUL，那就是和全局符号表生成时的顺序一样，采用装载序列。第二种情况是如果我们是对某个通过dlopen()打开的共享对象进行符号查找的话，那么采用的是一种叫做依赖序列的优先级。它是以被dlopen()打开的那个共享对象为根节点，对它所有依赖的共享对象进行广度优先遍历的顺序。</p>
</li>
<li><p>dlerror()</p>
<p>调用dlopen()、dlsym()、dlclose()后，都可以用dlerror()来检查是否成功</p>
</li>
<li><p>dlclose()</p>
<p>卸载一个已经加载的模块。</p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/09/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/" rel="next" title="程序员的自我修养：静态链接">
                <i class="fa fa-chevron-left"></i> 程序员的自我修养：静态链接
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/09/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E5%BA%93%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%BA%93/" rel="prev" title="程序员的自我修养：库与运行库">
                程序员的自我修养：库与运行库 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Ney" />
          <p class="site-author-name" itemprop="name">Ney</p>
           
              <p class="site-description motion-element" itemprop="description">Learning，sharing，improving</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-可执行文件的装载与进程"><span class="nav-number">1.</span> <span class="nav-text">6 可执行文件的装载与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-进程虚拟地址空间"><span class="nav-number">1.1.</span> <span class="nav-text">6.1 进程虚拟地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-装载的方式"><span class="nav-number">1.2.</span> <span class="nav-text">6.2 装载的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-从操作系统角度看可执行文件的装载"><span class="nav-number">1.3.</span> <span class="nav-text">6.3 从操作系统角度看可执行文件的装载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-进程的建立"><span class="nav-number">1.3.1.</span> <span class="nav-text">6.3.1 进程的建立</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建虚拟地址空间"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">创建虚拟地址空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#映射可执行文件到虚拟内存空间"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">映射可执行文件到虚拟内存空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#跳转到可执行文件入口，运行可执行文件"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">跳转到可执行文件入口，运行可执行文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-页错误"><span class="nav-number">1.3.2.</span> <span class="nav-text">6.3.2 页错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-进程虚拟内存空间分布"><span class="nav-number">1.4.</span> <span class="nav-text">6.4 进程虚拟内存空间分布</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-ELF文件链接视图和执行视图"><span class="nav-number">1.4.1.</span> <span class="nav-text">6.4.1 ELF文件链接视图和执行视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-堆和栈"><span class="nav-number">1.4.2.</span> <span class="nav-text">6.4.2 堆和栈</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-动态链接"><span class="nav-number">2.</span> <span class="nav-text">7 动态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-为什么要动态链接"><span class="nav-number">2.1.</span> <span class="nav-text">7.1 为什么要动态链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-地址无关代码"><span class="nav-number">2.2.</span> <span class="nav-text">7.3 地址无关代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-1-固定装载地址的困扰"><span class="nav-number">2.2.1.</span> <span class="nav-text">7.3.1 固定装载地址的困扰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-2-装载时重定位"><span class="nav-number">2.2.2.</span> <span class="nav-text">7.3.2 装载时重定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-3-地址无关代码"><span class="nav-number">2.2.3.</span> <span class="nav-text">7.3.3 地址无关代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#模块间的数据访问"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">模块间的数据访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#模块间的函数跳转"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">模块间的函数跳转</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-4-共享模块的全部变量问题"><span class="nav-number">2.2.4.</span> <span class="nav-text">7.3.4 共享模块的全部变量问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-5-数据段地址无关性"><span class="nav-number">2.2.5.</span> <span class="nav-text">7.3.5 数据段地址无关性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-延迟绑定（PLT）"><span class="nav-number">2.3.</span> <span class="nav-text">7.4 延迟绑定（PLT）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#延迟绑定实现"><span class="nav-number">2.3.0.1.</span> <span class="nav-text">延迟绑定实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-动态链接相关结构"><span class="nav-number">2.4.</span> <span class="nav-text">7.5 动态链接相关结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-1-“-interp”段"><span class="nav-number">2.4.1.</span> <span class="nav-text">7.5.1 “.interp”段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-2-“-dynamic”段"><span class="nav-number">2.4.2.</span> <span class="nav-text">7.5.2 “.dynamic”段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-3-动态符号表"><span class="nav-number">2.4.3.</span> <span class="nav-text">7.5.3 动态符号表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-4-动态链接重定位表"><span class="nav-number">2.4.4.</span> <span class="nav-text">7.5.4 动态链接重定位表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-动态链接的步骤和实现"><span class="nav-number">2.5.</span> <span class="nav-text">7.6 动态链接的步骤和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-1-动态链接器自举"><span class="nav-number">2.5.1.</span> <span class="nav-text">7.6.1 动态链接器自举</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-2-装载共享对象"><span class="nav-number">2.5.2.</span> <span class="nav-text">7.6.2 装载共享对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#符号优先级"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">符号优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#全局符号介入与地址无关代码"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">全局符号介入与地址无关代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-3-重定位和初始化"><span class="nav-number">2.5.3.</span> <span class="nav-text">7.6.3 重定位和初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-7-显式运行时链接"><span class="nav-number">2.6.</span> <span class="nav-text">7.7 显式运行时链接</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ney</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
